# Comparing `tmp/revolve2_modular_robot-1.1.1-py3-none-any.whl.zip` & `tmp/revolve2_modular_robot-1.2.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,54 +1,54 @@
-Zip file size: 36918 bytes, number of entries: 52
+Zip file size: 37868 bytes, number of entries: 52
 -rw-r--r--  2.0 unx      298 b- defN 80-Jan-01 00:00 revolve2/modular_robot/__init__.py
--rw-r--r--  2.0 unx      649 b- defN 80-Jan-01 00:00 revolve2/modular_robot/_modular_robot.py
--rw-r--r--  2.0 unx      466 b- defN 80-Jan-01 00:00 revolve2/modular_robot/_modular_robot_control_interface.py
--rw-r--r--  2.0 unx      253 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/__init__.py
--rw-r--r--  2.0 unx      377 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/_attachment_point.py
+-rw-r--r--  2.0 unx      679 b- defN 80-Jan-01 00:00 revolve2/modular_robot/_modular_robot.py
+-rw-r--r--  2.0 unx      500 b- defN 80-Jan-01 00:00 revolve2/modular_robot/_modular_robot_control_interface.py
+-rw-r--r--  2.0 unx      270 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/__init__.py
+-rw-r--r--  2.0 unx      643 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/_attachment_point.py
 -rw-r--r--  2.0 unx      470 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/_color.py
--rw-r--r--  2.0 unx     8473 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/_module.py
--rw-r--r--  2.0 unx      340 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/_right_angles.py
--rw-r--r--  2.0 unx      283 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/base/__init__.py
--rw-r--r--  2.0 unx     8054 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/base/_active_hinge.py
--rw-r--r--  2.0 unx      877 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/base/_attachment_face.py
--rw-r--r--  2.0 unx     5053 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/base/_body.py
--rw-r--r--  2.0 unx     3485 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/base/_brick.py
--rw-r--r--  2.0 unx     4159 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/base/_core.py
--rw-r--r--  2.0 unx      268 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/sensors/__init__.py
--rw-r--r--  2.0 unx      337 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/sensors/_active_hinge_sensor.py
--rw-r--r--  2.0 unx     1194 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/sensors/_camera_sensor.py
--rw-r--r--  2.0 unx      541 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/sensors/_imu_sensor.py
--rw-r--r--  2.0 unx     1062 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/sensors/_sensor.py
+-rw-r--r--  2.0 unx     9105 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/_module.py
+-rw-r--r--  2.0 unx      344 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/_right_angles.py
+-rw-r--r--  2.0 unx      292 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/base/__init__.py
+-rw-r--r--  2.0 unx     8405 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/base/_active_hinge.py
+-rw-r--r--  2.0 unx     1245 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/base/_attachment_face.py
+-rw-r--r--  2.0 unx     5277 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/base/_body.py
+-rw-r--r--  2.0 unx     3851 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/base/_brick.py
+-rw-r--r--  2.0 unx     4449 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/base/_core.py
+-rw-r--r--  2.0 unx      263 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/sensors/__init__.py
+-rw-r--r--  2.0 unx      298 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/sensors/_active_hinge_sensor.py
+-rw-r--r--  2.0 unx     1001 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/sensors/_camera_sensor.py
+-rw-r--r--  2.0 unx      596 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/sensors/_imu_sensor.py
+-rw-r--r--  2.0 unx     1104 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/sensors/_sensor.py
 -rw-r--r--  2.0 unx      230 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/v1/__init__.py
 -rw-r--r--  2.0 unx     1354 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/v1/_active_hinge_v1.py
--rw-r--r--  2.0 unx      422 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/v1/_body_v1.py
--rw-r--r--  2.0 unx      548 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/v1/_brick_v1.py
--rw-r--r--  2.0 unx      530 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/v1/_core_v1.py
--rw-r--r--  2.0 unx      230 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/v2/__init__.py
--rw-r--r--  2.0 unx     1221 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/v2/_active_hinge_v2.py
--rw-r--r--  2.0 unx     8538 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/v2/_attachment_face_core_v2.py
--rw-r--r--  2.0 unx      419 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/v2/_body_v2.py
--rw-r--r--  2.0 unx      549 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/v2/_brick_v2.py
+-rw-r--r--  2.0 unx      416 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/v1/_body_v1.py
+-rw-r--r--  2.0 unx      551 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/v1/_brick_v1.py
+-rw-r--r--  2.0 unx      533 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/v1/_core_v1.py
+-rw-r--r--  2.0 unx      231 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/v2/__init__.py
+-rw-r--r--  2.0 unx     1353 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/v2/_active_hinge_v2.py
+-rw-r--r--  2.0 unx     8520 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/v2/_attachment_face_core_v2.py
+-rw-r--r--  2.0 unx      607 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/v2/_body_v2.py
+-rw-r--r--  2.0 unx      550 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/v2/_brick_v2.py
 -rw-r--r--  2.0 unx     4052 b- defN 80-Jan-01 00:00 revolve2/modular_robot/body/v2/_core_v2.py
 -rw-r--r--  2.0 unx      165 b- defN 80-Jan-01 00:00 revolve2/modular_robot/brain/__init__.py
 -rw-r--r--  2.0 unx      611 b- defN 80-Jan-01 00:00 revolve2/modular_robot/brain/_brain.py
--rw-r--r--  2.0 unx      813 b- defN 80-Jan-01 00:00 revolve2/modular_robot/brain/_brain_instance.py
+-rw-r--r--  2.0 unx      785 b- defN 80-Jan-01 00:00 revolve2/modular_robot/brain/_brain_instance.py
 -rw-r--r--  2.0 unx      673 b- defN 80-Jan-01 00:00 revolve2/modular_robot/brain/cpg/__init__.py
--rw-r--r--  2.0 unx     3940 b- defN 80-Jan-01 00:00 revolve2/modular_robot/brain/cpg/_brain_cpg_instance.py
+-rw-r--r--  2.0 unx     3952 b- defN 80-Jan-01 00:00 revolve2/modular_robot/brain/cpg/_brain_cpg_instance.py
 -rw-r--r--  2.0 unx     3397 b- defN 80-Jan-01 00:00 revolve2/modular_robot/brain/cpg/_brain_cpg_network_neighbor.py
 -rw-r--r--  2.0 unx     1131 b- defN 80-Jan-01 00:00 revolve2/modular_robot/brain/cpg/_brain_cpg_network_neighbor_random.py
--rw-r--r--  2.0 unx     3016 b- defN 80-Jan-01 00:00 revolve2/modular_robot/brain/cpg/_brain_cpg_network_static.py
+-rw-r--r--  2.0 unx     3044 b- defN 80-Jan-01 00:00 revolve2/modular_robot/brain/cpg/_brain_cpg_network_static.py
 -rw-r--r--  2.0 unx     5501 b- defN 80-Jan-01 00:00 revolve2/modular_robot/brain/cpg/_cpg_network_structure.py
 -rw-r--r--  2.0 unx     1453 b- defN 80-Jan-01 00:00 revolve2/modular_robot/brain/cpg/_make_cpg_network_structure_neighbor.py
 -rw-r--r--  2.0 unx      173 b- defN 80-Jan-01 00:00 revolve2/modular_robot/brain/dummy/__init__.py
 -rw-r--r--  2.0 unx      379 b- defN 80-Jan-01 00:00 revolve2/modular_robot/brain/dummy/_brain_dummy.py
--rw-r--r--  2.0 unx      855 b- defN 80-Jan-01 00:00 revolve2/modular_robot/brain/dummy/_brain_dummy_instance.py
+-rw-r--r--  2.0 unx      767 b- defN 80-Jan-01 00:00 revolve2/modular_robot/brain/dummy/_brain_dummy_instance.py
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 revolve2/modular_robot/py.typed
 -rw-r--r--  2.0 unx      391 b- defN 80-Jan-01 00:00 revolve2/modular_robot/sensor_state/__init__.py
 -rw-r--r--  2.0 unx      309 b- defN 80-Jan-01 00:00 revolve2/modular_robot/sensor_state/_active_hinge_sensor_state.py
 -rw-r--r--  2.0 unx      336 b- defN 80-Jan-01 00:00 revolve2/modular_robot/sensor_state/_camera_sensor_state.py
 -rw-r--r--  2.0 unx      681 b- defN 80-Jan-01 00:00 revolve2/modular_robot/sensor_state/_imu_sensor_state.py
 -rw-r--r--  2.0 unx     1113 b- defN 80-Jan-01 00:00 revolve2/modular_robot/sensor_state/_modular_robot_sensor_state.py
--rw-r--r--  2.0 unx     3144 b- defN 80-Jan-01 00:00 revolve2_modular_robot-1.1.1.dist-info/METADATA
--rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 revolve2_modular_robot-1.1.1.dist-info/WHEEL
-?rw-r--r--  2.0 unx     5396 b- defN 16-Jan-01 00:00 revolve2_modular_robot-1.1.1.dist-info/RECORD
-52 files, 88297 bytes uncompressed, 27902 bytes compressed:  68.4%
+-rw-r--r--  2.0 unx     3144 b- defN 80-Jan-01 00:00 revolve2_modular_robot-1.2.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 revolve2_modular_robot-1.2.0.dist-info/WHEEL
+?rw-r--r--  2.0 unx     5397 b- defN 16-Jan-01 00:00 revolve2_modular_robot-1.2.0.dist-info/RECORD
+52 files, 90977 bytes uncompressed, 28852 bytes compressed:  68.3%
```

## zipnote {}

```diff
@@ -141,17 +141,17 @@
 
 Filename: revolve2/modular_robot/sensor_state/_imu_sensor_state.py
 Comment: 
 
 Filename: revolve2/modular_robot/sensor_state/_modular_robot_sensor_state.py
 Comment: 
 
-Filename: revolve2_modular_robot-1.1.1.dist-info/METADATA
+Filename: revolve2_modular_robot-1.2.0.dist-info/METADATA
 Comment: 
 
-Filename: revolve2_modular_robot-1.1.1.dist-info/WHEEL
+Filename: revolve2_modular_robot-1.2.0.dist-info/WHEEL
 Comment: 
 
-Filename: revolve2_modular_robot-1.1.1.dist-info/RECORD
+Filename: revolve2_modular_robot-1.2.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## revolve2/modular_robot/_modular_robot.py

```diff
@@ -10,24 +10,24 @@
     _uuid: uuid.UUID
 
     body: Body
     brain: Brain
 
     def __init__(self, body: Body, brain: Brain):
         """
-        Initialize this object.
+        Initialize the ModularRobot.
 
         :param body: The body of the modular robot.
         :param brain: The brain of the modular robot.
         """
         self._uuid = uuid.uuid1()
         self.body = body
         self.brain = brain
 
     @property
     def uuid(self) -> uuid.UUID:
         """
-        Get the uuid.
+        Get the uuid, used for identification.
 
         :returns: The uuid.
         """
         return self._uuid
```

## revolve2/modular_robot/_modular_robot_control_interface.py

```diff
@@ -5,12 +5,12 @@
 
 class ModularRobotControlInterface(ABC):
     """Interface for controlling modular robots."""
 
     @abstractmethod
     def set_active_hinge_target(self, active_hinge: ActiveHinge, target: float) -> None:
         """
-        Set the position target for an active hinge.
+        Set the position target for an active hinge on the modular robot.
 
-        :param active_hinge: The active hinge to set the target for.
-        :param target: The target to set.
+        :param active_hinge: The active hinge object to set the target for.
+        :param target: The target value to set.
         """
```

## revolve2/modular_robot/body/__init__.py

```diff
@@ -1,8 +1,8 @@
-"""Modular robot bodies."""
+"""Objects used for modular robot bodies."""
 
 from ._attachment_point import AttachmentPoint
 from ._color import Color
 from ._module import Module
 from ._right_angles import RightAngles
 
 __all__ = [
```

## revolve2/modular_robot/body/_attachment_point.py

```diff
@@ -1,13 +1,18 @@
 from dataclasses import dataclass
 
 from pyrr import Quaternion, Vector3
 
 
 @dataclass
 class AttachmentPoint:
-    """An attachment point on the parent module for the child."""
+    """
+    An attachment point is a theoretical location on the parent module for the child to be attached to.
+
+    The attachment of a module to its parent is not considered to be a separate AttachmentPoint.
+    This class simply is used for potential children to be placed on the correct positions of the current module.
+    """
 
     orientation: Quaternion
     """The orientation of the attachment point on the module."""
     offset: Vector3
     """The offset for the attachment point, with respect to the center of the module."""
```

## revolve2/modular_robot/body/_module.py

```diff
@@ -1,36 +1,41 @@
 from __future__ import annotations
 
 import uuid
 
+from pyrr import Quaternion
+
 from ._attachment_point import AttachmentPoint
 from ._color import Color
-from ._right_angles import RightAngles
 from .sensors import ActiveHingeSensor, CameraSensor, IMUSensor, Sensor
 
 
 class _AttachedSensors:
     """A class that contains all the attached Sensors of a Module."""
 
     _camera_sensor: CameraSensor | None
     _active_hinge_sensor: ActiveHingeSensor | None
     _imu_sensor: IMUSensor | None
 
     def __init__(self) -> None:
-        """Initialize the AttachedSensors."""
+        """
+        Initialize the AttachedSensors.
+
+        By default, we do not have sensors on base modules.
+        """
         self._camera_sensor = None
         self._imu_sensor = None
         self._active_hinge_sensor = None
 
     def add_sensor(self, sensor: Sensor) -> None:
         """
         Add a sensor to the attached Sensors of the module.
 
         :param sensor: The sensor.
-        :raises KeyError: If something went wrong with attaching.
+        :raises KeyError: If something went wrong with attaching the sensor.
         """
         match sensor:
             case CameraSensor():
                 if self._camera_sensor is None:
                     self._camera_sensor = sensor
                 else:
                     raise KeyError("Camera sensor already populated")
@@ -58,108 +63,119 @@
         :return: The sensors.
         """
         sensors = [self._active_hinge_sensor, self._imu_sensor, self._camera_sensor]
         return [s for s in sensors if s is not None]
 
     @property
     def imu_sensor(self) -> IMUSensor | None:
+        """
+        Get the potential IMU Sensor.
+
+        :returns: The IMU Sensor or None.
+        """
         return self._imu_sensor
 
     @property
     def active_hinge_sensor(self) -> ActiveHingeSensor | None:
+        """
+        Get the potential Active Hinge Sensor.
+
+        :returns: The ActiveHinge Sensor or None.
+        """
         return self._active_hinge_sensor
 
     @property
     def camera_sensor(self) -> CameraSensor | None:
+        """
+        Get the potential Camera Sensor.
+
+        :returns: The Camera Sensor or None.
+        """
         return self._camera_sensor
 
 
 class Module:
     """Base class for a module for modular robots."""
 
     _uuid: uuid.UUID
 
     _attachment_points: dict[int, AttachmentPoint]
     _children: dict[int, Module]
-    _rotation: float
+    _orientation: Quaternion
 
     _parent: Module | None
     """
     The parent module of this module.
     
-    None if this module has not yet been added to a body.
+    None if this module has not yet been added to a body or is the origin of the body.
     """
 
     _parent_child_index: int | None
     """
     Index of this module in the parent modules child list.
     
     None if this module has not yet been added to a body.
     """
 
     _sensors: _AttachedSensors
     _color: Color
 
     def __init__(
         self,
-        rotation: float | RightAngles,
+        orientation: Quaternion,
         color: Color,
         attachment_points: dict[int, AttachmentPoint],
         sensors: list[Sensor],
     ) -> None:
         """
         Initialize this object.
 
-        :param rotation: Orientation of this model relative to its parent.
+        :param orientation: Orientation of this model relative to its parent.
         :param color: The color of the module.
         :param attachment_points: The attachment points available on a module.
         :param sensors: The sensors associated with the module.
         """
-        self._sensors = _AttachedSensors()
-        for sensor in sensors:
-            self._sensors.add_sensor(sensor)
-
-        self._uuid = uuid.uuid1()
-
-        self._attachment_points = attachment_points
-        self._children = {}
-
-        self._rotation = (
-            rotation if isinstance(rotation, (float, int)) else rotation.value
-        )
-
+        """Set default values."""
         self._parent = None
         self._parent_child_index = None
+        self._children = {}
+        self._uuid = uuid.uuid1()
 
+        """Set parsed arguments."""
+        self._sensors = _AttachedSensors()  # Initialize the attached sensors.
+        for sensor in sensors:  # Add all desired sensors to the module.
+            self._sensors.add_sensor(sensor)
+        self._attachment_points = attachment_points
+        self._orientation = orientation
         self._color = color
 
     @property
     def uuid(self) -> uuid.UUID:
         """
         Get the uuid.
 
         :returns: The uuid.
         """
         return self._uuid
 
     @property
-    def rotation(self) -> float:
+    def orientation(self) -> Quaternion:
         """
         Get the orientation of this model relative to its parent.
 
         :returns: The orientation.
         """
-        return self._rotation
+        return self._orientation
 
     @property
     def parent(self) -> Module | None:
         """
         Get the parent module of this module.
 
-        None if this module has not yet been added to a body.
+        None if this module has not yet been added to a body or is the origin of the body.
 
         :returns: The parent module of this module, or None if this module has not yet been added to a body.
         """
         return self._parent
 
     @property
     def parent_child_index(self) -> int | None:
@@ -179,33 +195,33 @@
 
         :return: The children and their respective attachment point index.
         """
         return self._children
 
     def set_child(self, module: Module, child_index: int) -> None:
         """
-        Attach a module to a slot.
+        Attach a module to certain AttachmentPoint.
 
         :param module: The module to attach.
-        :param child_index: The slot to attach it to.
+        :param child_index: The index of the AttachmentPoint to attach it to.
         :raises KeyError: If attachment point is already populated.
         """
         assert (
             module._parent is None
         ), "Child module already connected to a different slot."
         module._parent = self
         module._parent_child_index = child_index
         if self.can_set_child(child_index):
             self._children[child_index] = module
         else:
             raise KeyError("Attachment point already populated")
 
     def can_set_child(self, child_index: int) -> bool:
         """
-        Check if a child can be set on the module.
+        Check if a child can be set on a specific attachment point on the module.
 
         :param child_index: The child index.
         :return: The boolean value.
         """
         if self._children.get(child_index, True):
             return True
         return False
```

## revolve2/modular_robot/body/_right_angles.py

```diff
@@ -1,13 +1,13 @@
 import math
 from enum import Enum
 
 
 class RightAngles(Enum):
-    """Standard angles at which  modular robot modules can be attached."""
+    """Standard angles at which some modular robot modules can be attached."""
 
     DEG_0 = 0
     DEG_90 = math.pi / 2.0
     DEG_180 = math.pi
     DEG_270 = math.pi / 2.0 * 3
     RAD_0 = 0
     RAD_HALFPI = math.pi / 2.0
```

## revolve2/modular_robot/body/base/__init__.py

```diff
@@ -1,8 +1,8 @@
-"""Base Modules for Robots."""
+"""Abstract Base Modules for Robots."""
 
 from ._active_hinge import ActiveHinge
 from ._attachment_face import AttachmentFace
 from ._body import Body
 from ._brick import Brick
 from ._core import Core
```

## revolve2/modular_robot/body/base/_active_hinge.py

```diff
@@ -4,15 +4,15 @@
 from .._color import Color
 from .._module import Module
 from .._right_angles import RightAngles
 from ..sensors import Sensor
 
 
 class ActiveHinge(Module):
-    """An Active Hinge."""
+    """An Active Hinge Module."""
 
     ATTACHMENT = 0
 
     _range: float
     _effort: float
     _velocity: float
 
@@ -98,17 +98,24 @@
 
         attachment_points = {
             self.ATTACHMENT: AttachmentPoint(
                 offset=Vector3([child_offset, 0.0, 0.0]),
                 orientation=Quaternion.from_eulers([0.0, 0.0, 0.0]),
             ),
         }
-
+        """
+        The base module only has orientation as its parameter since not all modules are square.
+        
+        Here we covert the angle of the module to its orientation in space.
+        """
+        orientation = Quaternion.from_eulers(
+            [rotation if isinstance(rotation, float) else rotation.value, 0, 0]
+        )
         super().__init__(
-            rotation, Color(255, 255, 255, 255), attachment_points, sensors
+            orientation, Color(255, 255, 255, 255), attachment_points, sensors
         )
 
         self._sensor = None
 
     @property
     def attachment(self) -> Module | None:
         """
@@ -173,35 +180,35 @@
         return self._velocity
 
     @property
     def servo1_bounding_box(self) -> Vector3:
         """
         Get the bounding box of the first servo part.
 
-        Sizes are total length, not half length from origin.
+        Sizes are total length, not half-length from origin.
         :return: Vector3 with sizes of bbox in x,y,z dimension (m).
         """
         return self._servo1_bounding_box
 
     @property
     def servo2_bounding_box(self) -> Vector3:
         """
         Get the bounding box of the second servo part.
 
-        Sizes are total length, not half length from origin.
+        Sizes are total length, not half-length from origin.
         :return: Vector3 with sizes of bbox in x,y,z dimension (m).
         """
         return self._servo2_bounding_box
 
     @property
     def frame_bounding_box(self) -> Vector3:
         """
         Get the bounding box of the frame.
 
-        Sizes are total length, not half length from origin.
+        Sizes are total length, not half-length from origin.
         :return: Vector3 with sizes of bbox in x,y,z dimension (m).
         """
         return self._frame_bounding_box
 
     @property
     def frame_offset(self) -> float:
         """
@@ -255,15 +262,15 @@
         :return: The value.
         """
         return self._joint_offset
 
     @property
     def armature(self) -> float:
         """
-        Get thearmature of the joint.
+        Get the armature of the joint.
 
         This represents the inertia of the motor itself when nothing is attached.
 
         :return: The value.
         """
         return self._armature
```

## revolve2/modular_robot/body/base/_attachment_face.py

```diff
@@ -1,7 +1,9 @@
+from pyrr import Quaternion
+
 from .._attachment_point import AttachmentPoint
 from .._color import Color
 from .._module import Module
 from .._right_angles import RightAngles
 
 
 class AttachmentFace(Module):
@@ -18,13 +20,21 @@
     ) -> None:
         """
         Initialize this object.
 
         :param rotation: Orientation of this model relative to its parent.
         :param attachment_points: The attachment points available on a module.
         """
+        """
+        The base module only has orientation as its parameter since not all modules are square.
+
+        Here we covert the angle of the module to its orientation in space.
+        """
+        orientation = Quaternion.from_eulers(
+            [rotation if isinstance(rotation, float) else rotation.value, 0, 0]
+        )
         super().__init__(
-            rotation=rotation,
+            orientation=orientation,
             attachment_points=attachment_points,
             color=Color(255, 255, 255, 255),
             sensors=[],
         )
```

## revolve2/modular_robot/body/base/_body.py

```diff
@@ -40,47 +40,56 @@
         position = Vector3()
 
         parent = module.parent
         child_index = module.parent_child_index
         while parent is not None and child_index is not None:
             child = parent.children.get(child_index)
             assert child is not None
-            assert np.isclose(child.rotation % (math.pi / 2.0), 0.0)
+            assert np.isclose(child.orientation.angle % (math.pi / 2.0), 0.0)
 
-            position = Quaternion.from_eulers((child.rotation, 0.0, 0.0)) * position
+            position = child.orientation * position
             position += Vector3([1, 0, 0])
 
             attachment_point = parent.attachment_points.get(child_index)
 
             if attachment_point is None:
                 raise KeyError("No attachment point found at the specified location.")
             position = attachment_point.orientation * position
             position = Vector3.round(position)
 
             child_index = parent.parent_child_index
             parent = parent.parent
         return position
 
     @classmethod
-    def __find_recur(cls, module: Module, module_type: Type[TModule]) -> list[TModule]:
+    def __find_recur(
+        cls, module: Module, module_type: Type[TModule], exclude: list[Type[TModule]]
+    ) -> list[TModule]:
         modules = []
-        if isinstance(module, module_type):
+        if isinstance(module, module_type) and not any(
+            [isinstance(module, e) for e in exclude]
+        ):
             modules.append(module)
         for child in module.children.values():
-            modules.extend(cls.__find_recur(child, module_type))
+            modules.extend(cls.__find_recur(child, module_type, exclude))
         return modules
 
-    def find_modules_of_type(self, module_type: Type[TModule]) -> list[TModule]:
+    def find_modules_of_type(
+        self, module_type: Type[TModule], exclude: list[Type[TModule]] | None = None
+    ) -> list[TModule]:
         """
         Find all Modules of a certain type in the robot.
 
         :param module_type: The type.
+        :param exclude: Module types to be excluded in search.
         :return: The list of Modules.
         """
-        return self.__find_recur(self._core, module_type)
+        return self.__find_recur(
+            self._core, module_type, [] if exclude is None else exclude
+        )
 
     def to_grid(self) -> tuple[NDArray[TModuleNP], Vector3[np.int_]]:
         """
         Convert the tree structure to a grid.
 
         The distance between all modules is assumed to be one grid cell.
         All module angles must be multiples of 90 degrees.
@@ -130,19 +139,17 @@
         self, module: Module, position: Vector3, orientation: Quaternion
     ) -> None:
         self._add(position, module)
 
         for child_index, attachment_point in module.attachment_points.items():
             child = module.children.get(child_index)
             if child is not None:
-                assert np.isclose(child.rotation % (math.pi / 2.0), 0.0)
+                assert np.isclose(child.orientation.angle % (math.pi / 2.0), 0.0)
                 rotation = (
-                    orientation
-                    * attachment_point.orientation
-                    * Quaternion.from_eulers([child.rotation, 0, 0])
+                    orientation * attachment_point.orientation * child.orientation
                 )
                 self._make_grid_recur(
                     child, position + rotation * Vector3([1.0, 0.0, 0.0]), rotation
                 )
 
     def _add(self, position: Vector3, module: Module) -> None:
         self._modules.append(module)
```

## revolve2/modular_robot/body/base/_brick.py

```diff
@@ -6,15 +6,15 @@
 from .._color import Color
 from .._module import Module
 from .._right_angles import RightAngles
 from ..sensors import Sensor
 
 
 class Brick(Module):
-    """A Brick."""
+    """A Brick Module."""
 
     FRONT = 0
     RIGHT = 1
     LEFT = 2
 
     _mass: float
     _bounding_box: Vector3
@@ -28,15 +28,15 @@
         sensors: list[Sensor],
     ):
         """
         Initialize this object.
 
         :param rotation: The Modules rotation.
         :param mass: The Modules mass (in kg).
-        :param bounding_box: The bounding box. Vector3 with sizes of bbox in x,y,z dimension (m). Sizes are total length, not half length from origin.
+        :param bounding_box: The bounding box. Vector3 with sizes of bbox in x,y,z dimension (m). Sizes are total length, not half-length from origin.
         :param child_offset: The offset of the child for each attachment point.
         :param sensors: The sensors associated with this module.
         """
         attachment_points = {
             self.FRONT: AttachmentPoint(
                 offset=Vector3([child_offset, 0.0, 0.0]),
                 orientation=Quaternion.from_eulers([0.0, 0.0, 0.0]),
@@ -48,15 +48,26 @@
             self.RIGHT: AttachmentPoint(
                 offset=Vector3([child_offset, 0.0, 0.0]),
                 orientation=Quaternion.from_eulers([0.0, 0.0, math.pi / 2.0 * 3]),
             ),
         }
         self._mass = mass
         self._bounding_box = bounding_box
-        super().__init__(rotation, Color(50, 50, 255, 255), attachment_points, sensors)
+
+        """
+        The base module only has orientation as its parameter since not all modules are square.
+
+        Here we covert the angle of the module to its orientation in space.
+        """
+        orientation = Quaternion.from_eulers(
+            [rotation if isinstance(rotation, float) else rotation.value, 0, 0]
+        )
+        super().__init__(
+            orientation, Color(50, 50, 255, 255), attachment_points, sensors
+        )
 
     @property
     def front(self) -> Module | None:
         """
         Get the front module of the brick.
 
         :returns: The attachment points module.
@@ -118,11 +129,11 @@
         return self._mass
 
     @property
     def bounding_box(self) -> Vector3:
         """
         Get the bounding box size.
 
-        Sizes are total length, not half length from origin.
+        Sizes are total length, not half-length from origin.
         :return: Vector3 with sizes of bbox in x,y,z dimension (in m).
         """
         return self._bounding_box
```

## revolve2/modular_robot/body/base/_core.py

```diff
@@ -55,17 +55,25 @@
             ),
             self.RIGHT: AttachmentPoint(
                 offset=Vector3([child_offset, 0.0, 0.0]),
                 orientation=Quaternion.from_eulers([0.0, 0.0, math.pi / 2.0 * 3]),
             ),
         }
 
-        super().__init__(rotation, Color(255, 50, 50, 255), attachment_points, sensors)
-        self._parent = None
-        self._parent_child_index = None
+        """
+        The base module only has orientation as its parameter since not all modules are square.
+
+        Here we covert the angle of the module to its orientation in space.
+        """
+        orientation = Quaternion.from_eulers(
+            [rotation if isinstance(rotation, float) else rotation.value, 0, 0]
+        )
+        super().__init__(
+            orientation, Color(255, 50, 50, 255), attachment_points, sensors
+        )
 
     @property
     def mass(self) -> float:
         """
         Get the mass of the Core (in kg).
 
         :return: The value.
```

## revolve2/modular_robot/body/sensors/__init__.py

```diff
@@ -1,8 +1,8 @@
-"""Base Sensors for Modular Robots."""
+"""Sensors for Modular Robots."""
 
 from ._active_hinge_sensor import ActiveHingeSensor
 from ._camera_sensor import CameraSensor
 from ._imu_sensor import IMUSensor
 from ._sensor import Sensor
 
 __all__ = ["ActiveHingeSensor", "CameraSensor", "IMUSensor", "Sensor"]
```

## revolve2/modular_robot/body/sensors/_active_hinge_sensor.py

```diff
@@ -1,13 +1,11 @@
+from pyrr import Quaternion, Vector3
+
 from ._sensor import Sensor
 
 
 class ActiveHingeSensor(Sensor):
     """A sensors for an active hinge that measures its angle."""
 
-    def __init__(self, rotation: float = 0.0) -> None:
-        """
-        Initialize the ActiveHinge sensor.
-
-        :param rotation: The rotation of the IMU.
-        """
-        super().__init__(rotation)
+    def __init__(self) -> None:
+        """Initialize the ActiveHinge sensor."""
+        super().__init__(Quaternion(), Vector3())
```

## revolve2/modular_robot/body/sensors/_camera_sensor.py

```diff
@@ -1,48 +1,37 @@
-from pyrr import Vector3
+from pyrr import Quaternion, Vector3
 
 from ._sensor import Sensor
 
 
 class CameraSensor(Sensor):
     """A camera for the Modular Robot."""
 
-    _position: Vector3
     _camera_size: tuple[int, int]
 
     def __init__(
         self,
         position: Vector3,
-        rotation: float = 0.0,
+        orientation: Quaternion = Quaternion(),
         camera_size: tuple[int, int] = (50, 50),
     ) -> None:
         """
         Initialize the Camera Sensor.
 
         Note that the camera_size can have a significant impact on performance.
-        For evolution related work sticked to 10x10 for sei fast reulst.
+        For evolution related work stick to 10x10 for fast results.
 
         :param position: The position of the camera.
-        :param rotation: The rotation of the camera.
+        :param orientation: The rotation of the camera.
         :param camera_size: The size of the camera image.
         """
-        super().__init__(rotation)
-        self._position = position
+        super().__init__(orientation, position)
         self._camera_size = camera_size
 
     @property
-    def position(self) -> Vector3:
-        """
-        Get the position of the camera.
-
-        :return: The position.
-        """
-        return self._position
-
-    @property
     def camera_size(self) -> tuple[int, int]:
         """
         Get the size of the camera.
 
         :return: The camera size.
         """
         return self._camera_size
```

## revolve2/modular_robot/body/sensors/_imu_sensor.py

```diff
@@ -1,20 +1,22 @@
-from pyrr import Vector3
+from pyrr import Quaternion, Vector3
 
 from ._sensor import Sensor
 
 
 class IMUSensor(Sensor):
     """
-    An inertial measurement unit.
+    An inertial measurement unit (IMU).
 
     Reports specific force(closely related to acceleration), angular rate(closely related to angular velocity), and orientation.
     """
 
-    def __init__(self, position: Vector3, rotation: float = 0.0) -> None:
+    def __init__(
+        self, position: Vector3, orientation: Quaternion = Quaternion()
+    ) -> None:
         """
         Initialize the IMU sensor.
 
-        :param rotation: The rotation of the IMU.
+        :param orientation: The rotation of the IMU.
         :param position: The position of the IMU.
         """
-        super().__init__(rotation, position)
+        super().__init__(orientation, position)
```

## revolve2/modular_robot/body/sensors/_sensor.py

```diff
@@ -1,50 +1,50 @@
 import uuid
 from abc import ABC
 
-from pyrr import Vector3
+from pyrr import Quaternion, Vector3
 
 
 class Sensor(ABC):
     """An abstract Sensor Class."""
 
     _uuid: uuid.UUID
-    _rotation: float
+    _orientation: Quaternion
     _position: Vector3
 
-    def __init__(self, rotation: float, position: Vector3 = Vector3([0, 0, 0])) -> None:
+    def __init__(self, orientation: Quaternion, position: Vector3) -> None:
         """
         Initialize the sensor.
 
-        :param rotation: The rotation of the sensor.
+        :param orientation: The rotation of the sensor.
         :param position: The position of the sensor.
         """
-        self._rotation = rotation
+        self._orientation = orientation
         self._uuid = uuid.uuid1()
         self._position = position
 
     @property
     def uuid(self) -> uuid.UUID:
         """
         Get the uuid of the sensor.
 
         :return: The uuid.
         """
         return self._uuid
 
     @property
-    def rotation(self) -> float:
+    def orientation(self) -> Quaternion:
         """
-        Return the rotation of the sensor.
+        Return the orientation of the sensor.
 
-        :return: The rotation.
+        :return: The orientation.
         """
-        return self._rotation
+        return self._orientation
 
     @property
     def position(self) -> Vector3:
         """
-        Get the position of the sensor on a module.
+        Get the relative position of the sensor on a module.
 
         :return: The position.
         """
         return self._position
```

## revolve2/modular_robot/body/v1/_body_v1.py

```diff
@@ -1,8 +1,8 @@
-from ..base._body import Body
+from ..base import Body
 from ._core_v1 import CoreV1
 
 
 class BodyV1(Body):
     """Body of a V1 modular robot."""
 
     _core: CoreV1
```

## revolve2/modular_robot/body/v1/_brick_v1.py

```diff
@@ -1,15 +1,15 @@
 from pyrr import Vector3
 
 from .._right_angles import RightAngles
 from ..base import Brick
 
 
 class BrickV1(Brick):
-    """A brick module for a modular robot."""
+    """A brick module for a v1 modular robot."""
 
     def __init__(self, rotation: float | RightAngles):
         """
         Initialize this object.
 
         :param rotation: The modules' rotation.
         """
```

## revolve2/modular_robot/body/v1/_core_v1.py

```diff
@@ -1,15 +1,15 @@
 from pyrr import Vector3
 
 from .._right_angles import RightAngles
 from ..base import Core
 
 
 class CoreV1(Core):
-    """The core module of a modular robot."""
+    """The core module of a v1 modular robot."""
 
     def __init__(self, rotation: float | RightAngles):
         """
         Initialize this object.
 
         :param rotation: The modules' rotation.
         """
```

## revolve2/modular_robot/body/v2/__init__.py

```diff
@@ -1,8 +1,8 @@
-"""Explicit modules of V2 Robot."""
+"""Explicit modules of V2 Robots."""
 
 from ._active_hinge_v2 import ActiveHingeV2
 from ._body_v2 import BodyV2
 from ._brick_v2 import BrickV2
 from ._core_v2 import CoreV2
 
 __all__ = ["ActiveHingeV2", "BodyV2", "BrickV2", "CoreV2"]
```

## revolve2/modular_robot/body/v2/_active_hinge_v2.py

```diff
@@ -3,15 +3,15 @@
 from .._right_angles import RightAngles
 from ..base import ActiveHinge
 from ..sensors import ActiveHingeSensor
 
 
 class ActiveHingeV2(ActiveHinge):
     """
-    An active hinge module for a modular robot.
+    An active hinge v2 module for a modular robot.
 
     This is a rotary joint.
     """
 
     def __init__(self, rotation: float | RightAngles):
         """
         Initialize this object.
@@ -34,9 +34,11 @@
             joint_offset=0.0119,
             static_friction=1.0,
             dynamic_friction=1.0,
             armature=0.002,
             pid_gain_p=5.0,
             pid_gain_d=0.05,
             child_offset=0.0583 / 2 + 0.002,
-            sensors=[ActiveHingeSensor()],
+            sensors=[
+                ActiveHingeSensor()
+            ],  # By default, V2 robots have ActiveHinge sensors, since the hardware also supports them natively.
         )
```

## revolve2/modular_robot/body/v2/_attachment_face_core_v2.py

```diff
@@ -2,23 +2,22 @@
 
 import numpy as np
 from numpy.typing import NDArray
 from pyrr import Quaternion, Vector3
 
 from .. import Module
 from .._attachment_point import AttachmentPoint
-from ..base._attachment_face import AttachmentFace
+from ..base import AttachmentFace
 
 
 class AttachmentFaceCoreV2(AttachmentFace):
     """An AttachmentFace for the V2 Core."""
 
     _check_matrix: NDArray[np.uint8]
     _child_offset: Vector3
-
     """
     Check matrix allows us to determine which attachment points can be filled in the face.
     
     check_matrix =  0   0   0
                       C   C  
                     0   0   0
                       C   C
```

## revolve2/modular_robot/body/v2/_body_v2.py

```diff
@@ -1,21 +1,24 @@
-from ..base._body import Body
+from ..base import Body
 from ._core_v2 import CoreV2
 
 
 class BodyV2(Body):
-    """Body of a V1 modular robot."""
+    """Body of a V2 modular robot."""
 
     _core: CoreV2
 
     def __init__(self) -> None:
         """Initialize the Body."""
         super().__init__(CoreV2(0.0))
 
     @property
     def core_v2(self) -> CoreV2:
         """
         Get the specific v2 core of the body.
 
+        This function is usd since the base core has fewer attributes than a V2 core.
+        Using this, allows us to specify the return type without overwriting functions of the base module.
+
         :return: The v2 core.
         """
         return self._core
```

## revolve2/modular_robot/body/v2/_brick_v2.py

```diff
@@ -7,15 +7,15 @@
 class BrickV2(Brick):
     """A brick module for a modular robot."""
 
     def __init__(self, rotation: float | RightAngles):
         """
         Initialize this object.
 
-        :param rotation: The modules rotation.
+        :param rotation: The modules' rotation.
         """
         super().__init__(
             rotation=rotation,
             bounding_box=Vector3([0.06288625, 0.06288625, 0.0603]),
             mass=0.06043,
             child_offset=0.06288625 / 2.0,
             sensors=[],
```

## revolve2/modular_robot/brain/_brain_instance.py

```diff
@@ -1,11 +1,11 @@
 from abc import ABC, abstractmethod
 
 from .._modular_robot_control_interface import ModularRobotControlInterface
-from ..sensor_state._modular_robot_sensor_state import ModularRobotSensorState
+from ..sensor_state import ModularRobotSensorState
 
 
 class BrainInstance(ABC):
     """
     An instance of a brain that perform the control of a robot.
 
     Instances of this class can be stateful.
```

## revolve2/modular_robot/brain/cpg/__init__.py

```diff
@@ -1,8 +1,8 @@
-"""Cpg brains for modular robots."""
+"""CPG brains for modular robots."""
 
 from ._brain_cpg_instance import BrainCpgInstance
 from ._brain_cpg_network_neighbor import BrainCpgNetworkNeighbor
 from ._brain_cpg_network_neighbor_random import BrainCpgNetworkNeighborRandom
 from ._brain_cpg_network_static import BrainCpgNetworkStatic
 from ._cpg_network_structure import CpgNetworkStructure
 from ._make_cpg_network_structure_neighbor import (
```

## revolve2/modular_robot/brain/cpg/_brain_cpg_instance.py

```diff
@@ -5,15 +5,15 @@
 from ...body.base import ActiveHinge
 from ...sensor_state import ModularRobotSensorState
 from .._brain_instance import BrainInstance
 
 
 class BrainCpgInstance(BrainInstance):
     """
-    Cpg network brain.
+    CPG network brain.
 
     A state array that is integrated over time following the differential equation `X'=WX`.
     W is a weight matrix that is multiplied by the state array.
     The outputs of the controller are defined by the `outputs`, a list of indices for the state array.
     """
 
     _initial_state: npt.NDArray[np.float_]
@@ -23,15 +23,15 @@
     def __init__(
         self,
         initial_state: npt.NDArray[np.float_],
         weight_matrix: npt.NDArray[np.float_],
         output_mapping: list[tuple[int, ActiveHinge]],
     ) -> None:
         """
-        Initialize this object.
+        Initialize this CPG Brain Instance.
 
         :param initial_state: The initial state of the neural network.
         :param weight_matrix: The weight matrix used during integration.
         :param output_mapping: Marks neurons as controller outputs and map them to the correct active hinge.
         """
         assert initial_state.ndim == 1
         assert weight_matrix.ndim == 2
```

## revolve2/modular_robot/brain/cpg/_brain_cpg_network_static.py

```diff
@@ -8,15 +8,15 @@
 from .._brain_instance import BrainInstance
 from ._brain_cpg_instance import BrainCpgInstance
 from ._cpg_network_structure import CpgNetworkStructure
 
 
 class BrainCpgNetworkStatic(Brain):
     """
-    A CPG brain with cpgs and connections defined by the user.
+    A CPG (central pattern generator) brain with CPGs and connections defined by the user.
 
     A state vector is integrated over time using a weight matrix which multiplication with the state vector sum defines the derivative of the state vector.
     I.e X' = WX
 
     The first `num_output_neurons` in the state vector are the outputs for the controller created by this brain.
     """
```

## revolve2/modular_robot/brain/cpg/_cpg_network_structure.py

```diff
@@ -9,68 +9,68 @@
     """Identifies a cpg to be used in a cpg network structure."""
 
     index: int
 
 
 @dataclass(frozen=True, init=False)
 class CpgPair:
-    """A pair of cpgs that assures that the first cpg always has the lowest index."""
+    """A pair of CPGs that assures that the first cpg always has the lowest index."""
 
     # lowest is automatically set to be the lowest state index of the two
     cpg_index_lowest: Cpg
     cpg_index_highest: Cpg
 
     def __init__(self, cpg_1: Cpg, cpg_2: Cpg) -> None:
         """
         Initialize this object.
 
-        The order of the provided cpgs is irrelevant.
+        The order of the provided CPGs is irrelevant.
 
-        :param cpg_1: One of the cpgs part of the pair.
-        :param cpg_2: The other cpg part of the pair.
+        :param cpg_1: One of the CPGs part of the pair.
+        :param cpg_2: The other CPG part of the pair.
         """
         # hacky but normal variable setting not possible with frozen enabled
         # https://stackoverflow.com/questions/57893902/how-can-i-set-an-attribute-in-a-frozen-dataclass-custom-init-method
         if cpg_1.index < cpg_2.index:
             object.__setattr__(self, "cpg_index_lowest", cpg_1)
             object.__setattr__(self, "cpg_index_highest", cpg_2)
         else:
             object.__setattr__(self, "cpg_index_lowest", cpg_2)
             object.__setattr__(self, "cpg_index_highest", cpg_1)
 
 
 class CpgNetworkStructure:
     """
-    Describes the structure of a cpg network.
+    Describes the structure of a CPG network.
 
-    Can generate parameters for a cpg network, such as the initial state.
+    Can generate parameters for a CPG network, such as the initial state.
     """
 
     cpgs: list[Cpg]
     connections: set[CpgPair]
 
     def __init__(self, cpgs: list[Cpg], connections: set[CpgPair]) -> None:
         """
         Initialize this object.
 
-        :param cpgs: The cpgs used in the structure.
-        :param connections: The connections between cpgs.
+        :param cpgs: The CPGs used in the structure.
+        :param connections: The connections between CPGs.
         """
         assert isinstance(connections, set)
 
         self.cpgs = cpgs
         self.connections = connections
 
     @staticmethod
     def make_cpgs(num_cpgs: int) -> list[Cpg]:
         """
-        Create a list of cpgs.
+        Create a list of CPGs.
 
-        :param num_cpgs: The number of cpgs to create.
-        :returns: The created list of cpgs.
+        :param num_cpgs: The number of CPGs to create.
+        :returns: The created list of CPGs.
         """
         return [Cpg(index) for index in range(num_cpgs)]
 
     def make_connection_weights_matrix(
         self,
         internal_connection_weights: dict[Cpg, float],
         external_connection_weights: dict[CpgPair, float],
@@ -137,15 +137,15 @@
         )
 
     @property
     def num_states(self) -> int:
         """
         Get the number of states in a cpg network of this structure.
 
-        This would be twice the number of cpgs.
+        This would be twice the number of CPGs.
 
         :returns: The number of states.
         """
         return len(self.cpgs) * 2
 
     def make_uniform_state(self, value: float) -> npt.NDArray[np.float_]:
         """
@@ -157,21 +157,21 @@
         :returns: The array of states.
         """
         return np.full(self.num_states, value)
 
     @property
     def num_cpgs(self) -> int:
         """
-        Get the number of cpgs in the structure.
+        Get the number of CPGs in the structure.
 
-        :returns: The number of cpgs.
+        :returns: The number of CPGs.
         """
         return len(self.cpgs)
 
     @property
     def output_indices(self) -> list[int]:
         """
-        Get the index in the state array for each cpg, matching the order the cpgs were provided in.
+        Get the index in the state array for each cpg, matching the order the CPGs were provided in.
 
         :returns: The indices.
         """
         return [i for i in range(self.num_cpgs)]
```

## revolve2/modular_robot/brain/cpg/_make_cpg_network_structure_neighbor.py

```diff
@@ -2,18 +2,18 @@
 from ._cpg_network_structure import CpgNetworkStructure, CpgPair
 
 
 def active_hinges_to_cpg_network_structure_neighbor(
     active_hinges: list[ActiveHinge],
 ) -> tuple[CpgNetworkStructure, list[tuple[int, ActiveHinge]]]:
     """
-    Create the structure of a cpg network based on a list of active hinges.
+    Create the structure of a CPG network based on a list of active hinges.
 
-    The order of the active hinges matches the order of the cpgs.
-    I.e. every active hinges has a corresponding cpg,
+    The order of the active hinges matches the order of the CPGs.
+    I.e. every active hinges has a corresponding CPG,
     and these are stored in the order the hinges are provided in.
 
     :param active_hinges: The active hinges to base the structure on.
     :returns: The created structure and a mapping between state indices and active hinges.
     """
     cpgs = CpgNetworkStructure.make_cpgs(len(active_hinges))
     connections: set[CpgPair] = set()
```

## revolve2/modular_robot/brain/dummy/_brain_dummy_instance.py

```diff
@@ -1,23 +1,23 @@
 from ..._modular_robot_control_interface import ModularRobotControlInterface
-from ...sensor_state._modular_robot_sensor_state import ModularRobotSensorState
+from ...sensor_state import ModularRobotSensorState
 from .._brain_instance import BrainInstance
 
 
 class BrainDummyInstance(BrainInstance):
     """A brain that does nothing."""
 
     def control(
         self,
         dt: float,
         sensor_state: ModularRobotSensorState,
         control_interface: ModularRobotControlInterface,
     ) -> None:
         """
-        Control the modular robot.
+        Control nothing.
 
-        Sets the active hinge targets to the values in the state array as defined by the mapping provided in the constructor.
+        This brain does not do anything for control, as it is an empty box.
 
         :param dt: Elapsed seconds since last call to this function.
         :param sensor_state: Interface for reading the current sensor state.
         :param control_interface: Interface for controlling the robot.
         """
```

## Comparing `revolve2_modular_robot-1.1.1.dist-info/METADATA` & `revolve2_modular_robot-1.2.0.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: revolve2-modular-robot
-Version: 1.1.1
+Version: 1.2.0
 Summary: Revolve2: Everything for defining modular robots.
 Home-page: https://github.com/ci-group/revolve2
 Author: Aart Stuurman
 Author-email: aartstuurman@hotmail.com
 Requires-Python: >=3.10,<3.12
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Intended Audience :: Science/Research
```

## Comparing `revolve2_modular_robot-1.1.1.dist-info/RECORD` & `revolve2_modular_robot-1.2.0.dist-info/RECORD`

 * *Files 16% similar despite different names*

```diff
@@ -1,52 +1,52 @@
 revolve2/modular_robot/__init__.py,sha256=YdWvqawK9_kbj8V8fsy0FOg4bX2NvN0dwVb89QTiasE,298
-revolve2/modular_robot/_modular_robot.py,sha256=vuUDQnOoZkW-q21709KHuIhBC6RgLAa_hBU6WETyHM8,649
-revolve2/modular_robot/_modular_robot_control_interface.py,sha256=rZ07Y0d_UupoXzkGb0Ay9U66QI6-fGiPMiS8QzvC6U8,466
-revolve2/modular_robot/body/__init__.py,sha256=eU9IwChHTGekogmD4vZJS2CfwaUAb9e5WLo1y0FGJpQ,253
-revolve2/modular_robot/body/_attachment_point.py,sha256=HGSB3SwmhGTln23yJ-CBvuPgRxFx62Xko4COslo9iyo,377
+revolve2/modular_robot/_modular_robot.py,sha256=kRh_EppKkqG5lup0Tb5m6MOeVyZ6E6uMJmAhRXi-swg,679
+revolve2/modular_robot/_modular_robot_control_interface.py,sha256=uFAi4PzyNrGs3kIH6SVc6qCZmpvreROmduyDCPJOwzc,500
+revolve2/modular_robot/body/__init__.py,sha256=VrNcc7Mk6aiAtAXGBBzec-4je7up6FF_cgVjev5QQ_s,270
+revolve2/modular_robot/body/_attachment_point.py,sha256=fHbMEFSnRA_h2sJPxipVhMAFweK89be15Fea4Mo9-80,643
 revolve2/modular_robot/body/_color.py,sha256=5ZTEfiHH8RZE6pFm5HuZMcZYO8pBRPk3huaPMRo53B8,470
-revolve2/modular_robot/body/_module.py,sha256=-e1hLdz5471m77sp_dFL2lUnmrEnE_BMpFXMOuCIEj0,8473
-revolve2/modular_robot/body/_right_angles.py,sha256=bN7n2kJItueclftoZLrwItzMXBp-sjbPyF-qzU0gjig,340
-revolve2/modular_robot/body/base/__init__.py,sha256=bee9V0DrExCgdNE5sei-TFMWDrqp8-PUK1IzQLzE5kw,283
-revolve2/modular_robot/body/base/_active_hinge.py,sha256=LbqeqLPt2uczaMs1dLxOH2FH6I-8vAz9YCOztLHY0SA,8054
-revolve2/modular_robot/body/base/_attachment_face.py,sha256=BQJGTgtRdT8FBPbrspvq5G3YUNT-aEZXgspLo7FQD14,877
-revolve2/modular_robot/body/base/_body.py,sha256=uwPZOHWKcU_s9A76824M27srbZHADhAusJAbM3LhvO4,5053
-revolve2/modular_robot/body/base/_brick.py,sha256=V6YoUxrS_wpg3MolwYtkOd_5_qj9T5dnPykKOdG03H4,3485
-revolve2/modular_robot/body/base/_core.py,sha256=7KRhfR5AO1eLPqK5kciW3trM29Oit48HYUBi8fhyG5w,4159
-revolve2/modular_robot/body/sensors/__init__.py,sha256=EDm1U1G6e_H2t7GVKWlkeEr0sV7pPou08xkg9e6AL38,268
-revolve2/modular_robot/body/sensors/_active_hinge_sensor.py,sha256=bZ_IiQqqq_UmsK3D6uEc3oPkLWduaogWVXjQ84t8bVk,337
-revolve2/modular_robot/body/sensors/_camera_sensor.py,sha256=EF1YSWs2NY6Hx2SLmnczFQa4wWbQs5yx46__XRcdxho,1194
-revolve2/modular_robot/body/sensors/_imu_sensor.py,sha256=mysTWVqco_WPIecpdSp3wFkR4Mpo-xaDzRC-octCIEA,541
-revolve2/modular_robot/body/sensors/_sensor.py,sha256=_jzdXuUa38bnDEg0-i1iRv7fndutIBd3TRqRWfJY62c,1062
+revolve2/modular_robot/body/_module.py,sha256=WZalDshCc13bI59zoBQFSUB1fGwwyS_c64f_Ahbl1xg,9105
+revolve2/modular_robot/body/_right_angles.py,sha256=RmaBGnE4KL09F11A0OBNRPxUDtpAAkTHaRbU-2r3e3g,344
+revolve2/modular_robot/body/base/__init__.py,sha256=K0xMwZ-j9_l55avOy2xS3TQTq1m2RGAPBy6ni8Q4bvA,292
+revolve2/modular_robot/body/base/_active_hinge.py,sha256=Kv_jgv_YMT62Z8Owx_nuFUIzUav_XlEBM19B7r1cqHU,8405
+revolve2/modular_robot/body/base/_attachment_face.py,sha256=rW2bPtyt1LSxrBJX24zExAMu9YVTNGwqNxCQtBfJBB4,1245
+revolve2/modular_robot/body/base/_body.py,sha256=gXgP7-txAixdw6DPZoxeeW7OUcMsCGAyJuMc4LPhWi4,5277
+revolve2/modular_robot/body/base/_brick.py,sha256=mbVj-mMKLtkvSr1qBJYMGKjHosrhpRgIGnyCVESVMWY,3851
+revolve2/modular_robot/body/base/_core.py,sha256=bSSeNMoLcfvsT5qSTerOE8d75MmJoeDkCmhAbK52JwQ,4449
+revolve2/modular_robot/body/sensors/__init__.py,sha256=cR1wAnLuTq4zxA9FOBdmICVUdOnFcc_Y1L-IKc71uzQ,263
+revolve2/modular_robot/body/sensors/_active_hinge_sensor.py,sha256=gd7H28z-9fo4LhpZfvrczNXk99AtPPwSGsva4mo_paI,298
+revolve2/modular_robot/body/sensors/_camera_sensor.py,sha256=efEPIaicB86tH32LO2hslYvapFtg-wivC9K0vv8mCCc,1001
+revolve2/modular_robot/body/sensors/_imu_sensor.py,sha256=E7T1m7CnvHqxweqpqHIe8tLucKQK5yvJ4mtjHG_FjI0,596
+revolve2/modular_robot/body/sensors/_sensor.py,sha256=BQMzPzbju5PNX9HSsMn5layYOqlgu3BYVI7n_BGlruw,1104
 revolve2/modular_robot/body/v1/__init__.py,sha256=Ww4apYgCMVL2a7lRfYNK3-ybmaokXzIEwKMBXd-gY0A,230
 revolve2/modular_robot/body/v1/_active_hinge_v1.py,sha256=oxmCk2Gm5Ow9orLZomSlXiDh0Q4FXsKB-BNeVQ2dXsk,1354
-revolve2/modular_robot/body/v1/_body_v1.py,sha256=tSPrM0CJW8Je5r18klHTHU8DRuBLjpT5SQt6pFPD-MU,422
-revolve2/modular_robot/body/v1/_brick_v1.py,sha256=95-eFYkpTYtI1u_CllNK0uYuyHcPvWK_zrmxr__8l7E,548
-revolve2/modular_robot/body/v1/_core_v1.py,sha256=BdAr1URKmvR7E-ecLNTEAxAXfGGMEItG-ifhNXZEPmQ,530
-revolve2/modular_robot/body/v2/__init__.py,sha256=XJ7l6WtiQdCVo_MabZeLZvZNPV8XHfyYOhiaNJ-5y_M,230
-revolve2/modular_robot/body/v2/_active_hinge_v2.py,sha256=Wu0CWF44jWCnAr5WTVWhAbteD7Otz2UTwOqkSKjcg0w,1221
-revolve2/modular_robot/body/v2/_attachment_face_core_v2.py,sha256=K891QT5BgRi6YJ8HXj2DjKZeju_m0tWfVdn0HvFKgyw,8538
-revolve2/modular_robot/body/v2/_body_v2.py,sha256=zVY9u8biH1KQoogMIDtw6RsafyuSS1jjybBiUi4x5sE,419
-revolve2/modular_robot/body/v2/_brick_v2.py,sha256=848AtQzdYjyhMuqPI_b8r8FOrZ9cGU3lIv7OeyxuBVQ,549
+revolve2/modular_robot/body/v1/_body_v1.py,sha256=qR_0fBrN6B8pgyW-CHhEyoT5b2_ffPDaZIm9faQ3KG8,416
+revolve2/modular_robot/body/v1/_brick_v1.py,sha256=oRWkDU3KDe8Vj8eHas5u7WxkTBdvwZaaNk29s8IqKpM,551
+revolve2/modular_robot/body/v1/_core_v1.py,sha256=qfgwzwgh5YE7wnqqleIv_qkJnpMeVI42IKNiM02W8l0,533
+revolve2/modular_robot/body/v2/__init__.py,sha256=JQSm9iYEUjAGm1nM_Xu7NKJK9tDWNcdSWnWkrGELGqg,231
+revolve2/modular_robot/body/v2/_active_hinge_v2.py,sha256=JRihQ1zV2DnivcVrr49jfHiYud2QqJo92BvDcK0QVys,1353
+revolve2/modular_robot/body/v2/_attachment_face_core_v2.py,sha256=gj5JJevXnmnv_3QBWsnik4k_FFq-3q8OpmpUiJZecgA,8520
+revolve2/modular_robot/body/v2/_body_v2.py,sha256=BOQx88Iy43sEwxN5rYWP8gwCxaGCpqmzzj_0BQU_j78,607
+revolve2/modular_robot/body/v2/_brick_v2.py,sha256=SRgOwPPolwWHiT_aHzJaGtaksKz_z-hVYqk_NDNMqiU,550
 revolve2/modular_robot/body/v2/_core_v2.py,sha256=Kb9-qj9oClUeZrlWdvfy5u8Gad8E3Z2xkF7qoS1GxvQ,4052
 revolve2/modular_robot/brain/__init__.py,sha256=rGF5y21JMwtNK_xPCbdp6-YZBGLEfAxTqR16pMi5z-0,165
 revolve2/modular_robot/brain/_brain.py,sha256=brjkQgoIXYhy8PtUEoImnFQ3oPWRW16q23m3edPlUoQ,611
-revolve2/modular_robot/brain/_brain_instance.py,sha256=3yXbOStOvTCyPeInA1WrnVuAisdPITCmA1ulu50xJSs,813
-revolve2/modular_robot/brain/cpg/__init__.py,sha256=hd_TySjqcmcmXRX5Fd20HBQP7zc_DQfl9CKQPFH3iFs,673
-revolve2/modular_robot/brain/cpg/_brain_cpg_instance.py,sha256=Vew_BI1EgXAzzvP28UP2NQ4z-dnYTIkzH7Uz0Xtpy4A,3940
+revolve2/modular_robot/brain/_brain_instance.py,sha256=Pnk82lfocoWQidNOoKlZ_FegjtlV1-vTiygDIbHwmzk,785
+revolve2/modular_robot/brain/cpg/__init__.py,sha256=w1lHMmc-MNUR0IqVj0pX3M1JeTbI36yXPivnD770lwU,673
+revolve2/modular_robot/brain/cpg/_brain_cpg_instance.py,sha256=i9vs78xtR9QJWzCQk8ofjiZ9NIcz7RRMMHdBwayQZKY,3952
 revolve2/modular_robot/brain/cpg/_brain_cpg_network_neighbor.py,sha256=7CrULwVBSWsI_B2Q3FRVQjr1pgHRz5ORbNzxdzoWi8k,3397
 revolve2/modular_robot/brain/cpg/_brain_cpg_network_neighbor_random.py,sha256=nNeULp0IfyUqZE1X_-SLdJczZ_1esW2VA9z-WkEWgTw,1131
-revolve2/modular_robot/brain/cpg/_brain_cpg_network_static.py,sha256=cFtfhWhF1JFNvA7BuJPXDXLNBYnwPl0OT4xI37Rr85U,3016
-revolve2/modular_robot/brain/cpg/_cpg_network_structure.py,sha256=ImLuZeXXiCK95BEuFLafb77nRGfRHD_1C19RTwSgofo,5501
-revolve2/modular_robot/brain/cpg/_make_cpg_network_structure_neighbor.py,sha256=l12CgW_2eH2-ajbYKtViFg9fpfz-03l-bMBx1slKA4E,1453
+revolve2/modular_robot/brain/cpg/_brain_cpg_network_static.py,sha256=lNZVjtsR8pNePYUtvdV320lj9_qKoURlt84jCl2UxMY,3044
+revolve2/modular_robot/brain/cpg/_cpg_network_structure.py,sha256=n5f4-ZQ1euvB3Ofe1GxIElYztlnJvtWp_zFQkW9I4Iw,5501
+revolve2/modular_robot/brain/cpg/_make_cpg_network_structure_neighbor.py,sha256=T1amQOUV3pC2W0f0SnidxNaHXFBkPxKgzFaOZGC7HQ4,1453
 revolve2/modular_robot/brain/dummy/__init__.py,sha256=aucaWGW6-a3-1R4AfPSEsFEXbwXp_uJzyWhjqT_VPIg,173
 revolve2/modular_robot/brain/dummy/_brain_dummy.py,sha256=WvOAnpFeYVXZAo2o0F3Qvy4e21MD49EaUQbK3mqfB-o,379
-revolve2/modular_robot/brain/dummy/_brain_dummy_instance.py,sha256=aYa9dLWgWSRd3GifkpDnGWzrVwuy2-McwUmrUQFRB4M,855
+revolve2/modular_robot/brain/dummy/_brain_dummy_instance.py,sha256=MomugyD9Wly5KHUyOr-Vq1wjr_YdhQVBR-Acsm8yKMI,767
 revolve2/modular_robot/py.typed,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 revolve2/modular_robot/sensor_state/__init__.py,sha256=ZlbY7RJhakpftWEcwckfcxbBfVMTBpk_Ee6v-jSuFLI,391
 revolve2/modular_robot/sensor_state/_active_hinge_sensor_state.py,sha256=uVJvjXwUtpkK0QszXMuc3BHvCcESLN02P_dU_5OCB1A,309
 revolve2/modular_robot/sensor_state/_camera_sensor_state.py,sha256=DIQhfGS3NjYIdqglkDgweHfKaf_ZoxO7senpb-gqCO4,336
 revolve2/modular_robot/sensor_state/_imu_sensor_state.py,sha256=xamKl9TwnStbaO-CbYZgBnh1Powv6jaVhP67w763gwQ,681
 revolve2/modular_robot/sensor_state/_modular_robot_sensor_state.py,sha256=ey0MOsZGk8Gm-AmcIxgVOVq12Xg87vHLxbyut83olow,1113
-revolve2_modular_robot-1.1.1.dist-info/METADATA,sha256=vQUU-8ZPq6a-Do2xRBfo4z66gOcoznHSsD-vijqXBUA,3144
-revolve2_modular_robot-1.1.1.dist-info/WHEEL,sha256=sP946D7jFCHeNz5Iq4fL4Lu-PrWrFsgfLXbbkciIZwg,88
-revolve2_modular_robot-1.1.1.dist-info/RECORD,,
+revolve2_modular_robot-1.2.0.dist-info/METADATA,sha256=Mh_2Mvfs2_an5XwD79jbChpD0HI8g2froDdvVI7Y-J8,3144
+revolve2_modular_robot-1.2.0.dist-info/WHEEL,sha256=sP946D7jFCHeNz5Iq4fL4Lu-PrWrFsgfLXbbkciIZwg,88
+revolve2_modular_robot-1.2.0.dist-info/RECORD,,
```

