# Comparing `tmp/ragfmk-0.1.2.1-py3-none-any.whl.zip` & `tmp/ragfmk-0.1.3-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,40 +1,38 @@
-Zip file size: 34943 bytes, number of entries: 38
--rw-rw-rw-  2.0 fat     3201 b- defN 24-Apr-29 07:11 RagAdhocQueryDoc.py
--rw-rw-rw-  2.0 fat     3746 b- defN 24-Apr-29 06:57 RagChromaDB.py
--rw-rw-rw-  2.0 fat     2696 b- defN 24-Apr-29 06:55 RagChunkText.py
--rw-rw-rw-  2.0 fat     2296 b- defN 24-Apr-29 06:58 RagEmbeddings.py
--rw-rw-rw-  2.0 fat     3987 b- defN 24-Apr-29 07:11 RagFaiss.py
--rw-rw-rw-  2.0 fat     1443 b- defN 24-Apr-29 06:55 RagLLM.py
--rw-rw-rw-  2.0 fat     1646 b- defN 24-Apr-29 06:55 RagPdf2Text.py
--rw-rw-rw-  2.0 fat     1558 b- defN 24-Apr-29 06:56 RagPrompt.py
+Zip file size: 29922 bytes, number of entries: 36
+-rw-rw-rw-  2.0 fat     3622 b- defN 24-Apr-30 09:43 RagAdhocQueryDoc.py
+-rw-rw-rw-  2.0 fat     1694 b- defN 24-Apr-30 09:42 RagPrompt.py
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Dec-21 09:21 __init__.py
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Dec-21 09:21 ragfmk/__init__.py
--rw-rw-rw-  2.0 fat    10510 b- defN 24-Apr-29 06:55 ragfmk/rag.py
--rw-rw-rw-  2.0 fat     2275 b- defN 24-Apr-29 06:56 ragfmk/ragChromaDB.py
--rw-rw-rw-  2.0 fat     3274 b- defN 24-Apr-29 06:57 ragfmk/ragFAISS.py
+-rw-rw-rw-  2.0 fat     9013 b- defN 24-Apr-30 09:43 ragfmk/rag.py
+-rw-rw-rw-  2.0 fat     2645 b- defN 24-Apr-30 09:35 ragfmk/ragChromaDB.py
+-rw-rw-rw-  2.0 fat     3720 b- defN 24-Apr-30 07:36 ragfmk/ragFAISS.py
 -rw-rw-rw-  2.0 fat        0 b- defN 24-Mar-25 16:16 ragfmk/elements/__init__.py
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Dec-21 09:21 ragfmk/elements/embeddings/__init__.py
--rw-rw-rw-  2.0 fat     3925 b- defN 24-Apr-29 06:34 ragfmk/elements/embeddings/embeddings.py
--rw-rw-rw-  2.0 fat     1225 b- defN 24-Apr-29 06:35 ragfmk/elements/embeddings/stEmbeddings.py
+-rw-rw-rw-  2.0 fat     3623 b- defN 24-Apr-30 07:34 ragfmk/elements/embeddings/embeddings.py
+-rw-rw-rw-  2.0 fat     1226 b- defN 24-Apr-29 15:51 ragfmk/elements/embeddings/stEmbeddings.py
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Dec-21 09:21 ragfmk/elements/llms/__init__.py
 -rw-rw-rw-  2.0 fat     1245 b- defN 24-Apr-27 09:28 ragfmk/elements/llms/ollama.py
--rw-rw-rw-  2.0 fat     4544 b- defN 24-Apr-29 06:35 ragfmk/elements/simsearchengines/FAISSWrapper.py
+-rw-rw-rw-  2.0 fat     3400 b- defN 24-Apr-29 15:26 ragfmk/elements/simsearchengines/ChromaDBWrapper.py
+-rw-rw-rw-  2.0 fat     4595 b- defN 24-Apr-29 15:26 ragfmk/elements/simsearchengines/FAISSWrapper.py
 -rw-rw-rw-  2.0 fat        0 b- defN 24-Mar-25 16:16 ragfmk/elements/simsearchengines/__init__.py
--rw-rw-rw-  2.0 fat     3440 b- defN 24-Apr-29 06:35 ragfmk/elements/simsearchengines/chromaDBWrapper.py
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Dec-21 09:21 ragfmk/elements/wrappers/__init__.py
--rw-rw-rw-  2.0 fat     2916 b- defN 24-Apr-29 08:34 ragfmk/elements/wrappers/chunks.py
--rw-rw-rw-  2.0 fat     7558 b- defN 24-Apr-29 06:35 ragfmk/elements/wrappers/document.py
--rw-rw-rw-  2.0 fat     2218 b- defN 24-Apr-29 06:35 ragfmk/elements/wrappers/nearest.py
--rw-rw-rw-  2.0 fat     1198 b- defN 24-Apr-29 06:35 ragfmk/elements/wrappers/prompt.py
--rw-rw-rw-  2.0 fat     4002 b- defN 24-Apr-27 14:04 ragfmk/utils/CONST.py
--rw-rw-rw-  2.0 fat      143 b- defN 24-Apr-29 06:35 ragfmk/utils/FUNCTIONS.py
+-rw-rw-rw-  2.0 fat     3237 b- defN 24-Apr-30 06:37 ragfmk/elements/wrappers/chunks.py
+-rw-rw-rw-  2.0 fat     7605 b- defN 24-Apr-30 06:46 ragfmk/elements/wrappers/document.py
+-rw-rw-rw-  2.0 fat     2816 b- defN 24-Apr-30 06:52 ragfmk/elements/wrappers/nearest.py
+-rw-rw-rw-  2.0 fat     1199 b- defN 24-Apr-29 15:50 ragfmk/elements/wrappers/prompt.py
+-rw-rw-rw-  2.0 fat      759 b- defN 24-Apr-30 06:50 ragfmk/interfaces/IChunks.py
+-rw-rw-rw-  2.0 fat      432 b- defN 24-Apr-30 06:50 ragfmk/interfaces/IDocument.py
+-rw-rw-rw-  2.0 fat      775 b- defN 24-Apr-30 07:33 ragfmk/interfaces/IEmbeddings.py
+-rw-rw-rw-  2.0 fat      847 b- defN 24-Apr-30 06:52 ragfmk/interfaces/INearest.py
+-rw-rw-rw-  2.0 fat     1244 b- defN 24-Apr-30 09:40 ragfmk/interfaces/IRag.py
+-rw-rw-rw-  2.0 fat     1697 b- defN 24-Apr-30 09:30 ragfmk/utils/CONST.py
 -rw-rw-rw-  2.0 fat        0 b- defN 24-Mar-25 16:16 ragfmk/utils/__init__.py
 -rw-rw-rw-  2.0 fat     1864 b- defN 24-Apr-29 06:35 ragfmk/utils/log.py
 -rw-rw-rw-  2.0 fat     1907 b- defN 24-Apr-22 13:53 ragfmk/utils/milestone.py
--rw-rw-rw-  2.0 fat     1091 b- defN 24-Apr-29 08:38 ragfmk-0.1.2.1.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     8549 b- defN 24-Apr-29 08:38 ragfmk-0.1.2.1.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 24-Apr-29 08:38 ragfmk-0.1.2.1.dist-info/WHEEL
--rw-rw-rw-  2.0 fat      262 b- defN 24-Apr-29 08:38 ragfmk-0.1.2.1.dist-info/entry_points.txt
--rw-rw-rw-  2.0 fat      110 b- defN 24-Apr-29 08:38 ragfmk-0.1.2.1.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     3121 b- defN 24-Apr-29 08:38 ragfmk-0.1.2.1.dist-info/RECORD
-38 files, 86042 bytes uncompressed, 29959 bytes compressed:  65.2%
+-rw-rw-rw-  2.0 fat     1091 b- defN 24-Apr-30 13:16 ragfmk-0.1.3.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     8547 b- defN 24-Apr-30 13:16 ragfmk-0.1.3.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 24-Apr-30 13:16 ragfmk-0.1.3.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       86 b- defN 24-Apr-30 13:16 ragfmk-0.1.3.dist-info/entry_points.txt
+-rw-rw-rw-  2.0 fat       43 b- defN 24-Apr-30 13:16 ragfmk-0.1.3.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     3029 b- defN 24-Apr-30 13:16 ragfmk-0.1.3.dist-info/RECORD
+36 files, 72053 bytes uncompressed, 25034 bytes compressed:  65.3%
```

## zipnote {}

```diff
@@ -1,28 +1,10 @@
 Filename: RagAdhocQueryDoc.py
 Comment: 
 
-Filename: RagChromaDB.py
-Comment: 
-
-Filename: RagChunkText.py
-Comment: 
-
-Filename: RagEmbeddings.py
-Comment: 
-
-Filename: RagFaiss.py
-Comment: 
-
-Filename: RagLLM.py
-Comment: 
-
-Filename: RagPdf2Text.py
-Comment: 
-
 Filename: RagPrompt.py
 Comment: 
 
 Filename: __init__.py
 Comment: 
 
 Filename: ragfmk/__init__.py
@@ -51,21 +33,21 @@
 
 Filename: ragfmk/elements/llms/__init__.py
 Comment: 
 
 Filename: ragfmk/elements/llms/ollama.py
 Comment: 
 
-Filename: ragfmk/elements/simsearchengines/FAISSWrapper.py
+Filename: ragfmk/elements/simsearchengines/ChromaDBWrapper.py
 Comment: 
 
-Filename: ragfmk/elements/simsearchengines/__init__.py
+Filename: ragfmk/elements/simsearchengines/FAISSWrapper.py
 Comment: 
 
-Filename: ragfmk/elements/simsearchengines/chromaDBWrapper.py
+Filename: ragfmk/elements/simsearchengines/__init__.py
 Comment: 
 
 Filename: ragfmk/elements/wrappers/__init__.py
 Comment: 
 
 Filename: ragfmk/elements/wrappers/chunks.py
 Comment: 
@@ -75,41 +57,53 @@
 
 Filename: ragfmk/elements/wrappers/nearest.py
 Comment: 
 
 Filename: ragfmk/elements/wrappers/prompt.py
 Comment: 
 
-Filename: ragfmk/utils/CONST.py
+Filename: ragfmk/interfaces/IChunks.py
 Comment: 
 
-Filename: ragfmk/utils/FUNCTIONS.py
+Filename: ragfmk/interfaces/IDocument.py
+Comment: 
+
+Filename: ragfmk/interfaces/IEmbeddings.py
+Comment: 
+
+Filename: ragfmk/interfaces/INearest.py
+Comment: 
+
+Filename: ragfmk/interfaces/IRag.py
+Comment: 
+
+Filename: ragfmk/utils/CONST.py
 Comment: 
 
 Filename: ragfmk/utils/__init__.py
 Comment: 
 
 Filename: ragfmk/utils/log.py
 Comment: 
 
 Filename: ragfmk/utils/milestone.py
 Comment: 
 
-Filename: ragfmk-0.1.2.1.dist-info/LICENSE
+Filename: ragfmk-0.1.3.dist-info/LICENSE
 Comment: 
 
-Filename: ragfmk-0.1.2.1.dist-info/METADATA
+Filename: ragfmk-0.1.3.dist-info/METADATA
 Comment: 
 
-Filename: ragfmk-0.1.2.1.dist-info/WHEEL
+Filename: ragfmk-0.1.3.dist-info/WHEEL
 Comment: 
 
-Filename: ragfmk-0.1.2.1.dist-info/entry_points.txt
+Filename: ragfmk-0.1.3.dist-info/entry_points.txt
 Comment: 
 
-Filename: ragfmk-0.1.2.1.dist-info/top_level.txt
+Filename: ragfmk-0.1.3.dist-info/top_level.txt
 Comment: 
 
-Filename: ragfmk-0.1.2.1.dist-info/RECORD
+Filename: ragfmk-0.1.3.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## RagAdhocQueryDoc.py

```diff
@@ -15,51 +15,60 @@
                             [-chunk_size {Chunk size for char chunking, def 500}]
                             [-chunk_overlap {Chunk overlap for char chunking, def 50}] 
                             [-sep {Chunk separator}] 
                             [-nearest {Number of nearest chunks}] 
                             [-model {Ollama LLM Model}]
                             [-urlbase {Ollama URL}]
 """
+ARG_PROMPT = ["prompt", "Prompt to send to the LLM"]
+ARG_PDFFILE = ["pdf", "PDF file path"]
+ARG_TEMP = ["temperature", "LLM Temperature parameter, by defaul 0.9"]
+ARG_CHUNKSIZE = ["chunk_size", "Chunk Size"]
+ARG_CHUNKOVAP = ["chunk_overlap", "Chunk Overlap"]
+ARG_SEP = ["sep", "Separator for chunking"]
+ARG_NEAREST = ["nearest", "Faiss Number of nearest chunks to gather for prompting"]
+ARG_MODEL = ["model", "Ollama Model installed"]
+ARG_URL = ["urlbase", "URL for Ollama API (default localhost)"]
 
 def main():
     parser = argparse.ArgumentParser()
     myRag = ragFAISS()
     try:
-        parser.add_argument("-" + C.ARG_PROMPT[0], help=C.ARG_PROMPT[1], required=True)
-        parser.add_argument("-" + C.ARG_PDFFILE[0], help=C.ARG_PDFFILE[1], required=True)
-        parser.add_argument("-" + C.ARG_TEMP[0], help=C.ARG_TEMP[1], required=False, type=float, default=C.LLM_DEFAULT_TEMPERATURE) # float(self.temperature.replace(",", "."))
-        parser.add_argument("-" + C.ARG_CHUNKSIZE[0], help=C.ARG_CHUNKSIZE[1], required=False, type=int, default=C.CHKS_DEFAULT_SIZE)
-        parser.add_argument("-" + C.ARG_CHUNKOVAP[0], help=C.ARG_CHUNKOVAP[1], required=False, type=int, default=C.CHKS_DEFAULT_OVERLAP)
-        parser.add_argument("-" + C.ARG_SEP[0], help=C.ARG_SEP[1], required=False, default=C.CHKS_DEFAULT_SEP)
-        parser.add_argument("-" + C.ARG_NEAREST[0], help=C.ARG_NEAREST[1], required=False, type=int, default=C.SM_DEFAULT_NEAREST)
-        parser.add_argument("-" + C.ARG_MODEL[0], help=C.ARG_MODEL[1], required=False, default=C.OLLAMA_DEFAULT_LLM)
-        parser.add_argument("-" + C.ARG_URL[0], help=C.ARG_URL[1], required=False, default=C.OLLAMA_LOCAL_URL)
+        parser.add_argument("-" + ARG_PROMPT[0], help=ARG_PROMPT[1], required=True)
+        parser.add_argument("-" + ARG_PDFFILE[0], help=ARG_PDFFILE[1], required=True)
+        parser.add_argument("-" + ARG_TEMP[0], help=ARG_TEMP[1], required=False, type=float, default=C.LLM_DEFAULT_TEMPERATURE) # float(self.temperature.replace(",", "."))
+        parser.add_argument("-" + ARG_CHUNKSIZE[0], help=ARG_CHUNKSIZE[1], required=False, type=int, default=C.CHKS_DEFAULT_SIZE)
+        parser.add_argument("-" + ARG_CHUNKOVAP[0], help=ARG_CHUNKOVAP[1], required=False, type=int, default=C.CHKS_DEFAULT_OVERLAP)
+        parser.add_argument("-" + ARG_SEP[0], help=ARG_SEP[1], required=False, default=C.CHKS_DEFAULT_SEP)
+        parser.add_argument("-" + ARG_NEAREST[0], help=ARG_NEAREST[1], required=False, type=int, default=C.SM_DEFAULT_NEAREST)
+        parser.add_argument("-" + ARG_MODEL[0], help=ARG_MODEL[1], required=False, default=C.OLLAMA_DEFAULT_LLM)
+        parser.add_argument("-" + ARG_URL[0], help=ARG_URL[1], required=False, default=C.OLLAMA_LOCAL_URL)
         args = vars(parser.parse_args())
-        myRag.setCLIArgs(args)
 
         # 1 - Read the pdf content
-        pdf = myRag.readPDF(args[C.ARG_PDFFILE[0]], C.ARG_READER_VALPYPDF)
+        pdf = myRag.readPDF(args[ARG_PDFFILE[0]], C.READER_VALPYPDF)
         # 2 - Chunk document
-        cks = myRag.charChunk(pdf, args[C.ARG_SEP[0]], args[C.ARG_CHUNKSIZE[0]], args[C.ARG_CHUNKOVAP[0]])
+        cks = myRag.charChunk(pdf, args[ARG_SEP[0]], args[ARG_CHUNKSIZE[0]], args[ARG_CHUNKOVAP[0]])
         # 3 - Text embeddings
         cksP = chunks()
-        cksP.add(args[C.ARG_SEP[0]])
+        cksP.add(args[ARG_SEP[0]])
         vPrompt = myRag.createEmbeddings(cksP)
         # 4 - Chunks embeddings
         vChunks = myRag.createEmbeddings(cks)
         # 5 - Index the chunks
-        myRag.add(vChunks)
+        myRag.addEmbeddings(vChunks)
         # 6 - Similarity Search
-        similars = myRag.search(args[C.ARG_NEAREST[0]], vPrompt)
+        myRag.initSearchEngine()
+        similars = myRag.processSearch(args[ARG_NEAREST[0]], vPrompt)
         # 7 - Build prompt
-        customPrompt = myRag.buildPrompt(args[C.ARG_PROMPT[0]], similars)
+        customPrompt = myRag.buildPrompt(args[ARG_PROMPT[0]], similars)
         # 8 - Ask to the LLM ...
-        resp = myRag.promptLLM(customPrompt, args[C.ARG_URL[0]], args[C.ARG_MODEL[0]], args[C.ARG_TEMP[0]])
+        resp = myRag.promptLLM(customPrompt, args[ARG_URL[0]], args[ARG_MODEL[0]], args[ARG_TEMP[0]])
     
-        myRag.CLI_output(resp)
+        print(resp)
 
     except Exception as e:
         parser.print_help()
-        myRag.CLI_output(C.OUT_ERROR, True, str(e))
+        print(e)
         
 if __name__ == "__main__":
     main()
```

## RagPrompt.py

```diff
@@ -1,42 +1,44 @@
 __author__ = "Benoit CAYLA"
 __email__ = "benoit@datacorner.fr"
 __license__ = "MIT"
 
 import argparse
 from ragfmk.rag import rag
 import ragfmk.utils.CONST as C
-import ragfmk.utils.FUNCTIONS as F 
 from ragfmk.elements.wrappers.nearest import nearest
 
+ARG_PROMPT = ["prompt", "Prompt to send to the LLM"]
+ARG_PROMPT_TEMPLATE = ["template", "Prompt template to use when building the prompt (must contain {prompt} and {context}"]
+ARG_NEARESTFILE = ["nfile", "JSON file path which contains the nearest chunks/texts"]
+
 """
     Build a prompt based on a template. The template must contain the {context} and {prompt} tags inside.
     By default: "Question: {prompt}\n Please answer the question based on the informations listed below: {context}"
 
     usage: RagPrompt [-h] 
                      -prompt {question to ask to the LLM} 
                      -nfile {list of the nearest chunks / json}
                      [-template {template string}] 
 """
 def main():
     parser = argparse.ArgumentParser()
     myRag = rag()
     try:
-        parser.add_argument("-" + C.ARG_PROMPT[0], help=C.ARG_PROMPT[1], required=True)
-        parser.add_argument("-" + C.ARG_PROMPT_TEMPLATE[0], help=C.ARG_PROMPT_TEMPLATE[1], required=False, 
+        parser.add_argument("-" + ARG_PROMPT[0], help=ARG_PROMPT[1], required=True)
+        parser.add_argument("-" + ARG_PROMPT_TEMPLATE[0], help=ARG_PROMPT_TEMPLATE[1], required=False, 
                             default = C.PROMPT_RAG_TEMPLATE)
-        parser.add_argument("-" + C.ARG_NEARESTFILE[0], help=C.ARG_NEARESTFILE[1], required=True)
+        parser.add_argument("-" + ARG_NEARESTFILE[0], help=ARG_NEARESTFILE[1], required=True)
         args = vars(parser.parse_args())
         
-        myRag.setCLIArgs(args)
         nr = nearest()
-        nr.load(filename=args[C.ARG_NEARESTFILE[0]])
-        resp = myRag.buildPrompt(args[C.ARG_PROMPT[0]], nr)
+        nr.load(filename=args[ARG_NEARESTFILE[0]])
+        resp = myRag.buildPrompt(args[ARG_PROMPT[0]], nr)
 
-        myRag.CLI_output(resp)
+        print(resp)
 
     except Exception as e:
         parser.print_help()
-        myRag.CLI_output(C.OUT_ERROR, True, str(e))
+        print(e)
         
 if __name__ == "__main__":
     main()
```

## ragfmk/rag.py

```diff
@@ -6,100 +6,72 @@
 from ragfmk.elements.llms.ollama import ollama
 from ragfmk.elements.wrappers.prompt import prompt
 from ragfmk.utils.milestone import milestone
 from ragfmk.elements.embeddings.stEmbeddings import stEmbeddings
 from ragfmk.elements.wrappers.chunks import chunks
 import ragfmk.utils.CONST as C
 from ragfmk.utils.log import log
+from ragfmk.interfaces.IRag import IRag
 import os
 
-class rag():
+class rag(IRag):
     def __init__(self):
         self.__milestones = milestone()
         try:
-            ragLogFileName = os.environ[C.RAGCLI_LOGFILE_ENV]
+            self.__ragLogFileName = os.environ[C.RAGCLI_LOGFILE_ENV]
         except:
-            ragLogFileName = C.TRACE_FILENAME
-        self.__myLog = log(C.TRACE_LOGGER, ragLogFileName)
+            self.__ragLogFileName = C.TRACE_FILENAME
+        self.__logLevel = C.TRACE_DEFAULT_LEVEL
+        self.__myLog = None
         self.__milestones.start()
-        self.log.info("** START **")
-        
-    def setCLIArgs(self, args):
-        self.__milestones.initialize(args)
-
-    @property
-    def milestones(self):
-        return self.__milestones
-    @property
-    def log(self):
-        return self.__myLog
 
-    def addMilestone(self, name, description, *others):
-        self.__milestones.add(name, description, others)
-        self.log.info("Step {} -> {}".format(name, self.__CLI_fmtMsgForLog(description)))
+    def setLogInfo(self, logFilename, level):
+        self.__ragLogFileName = logFilename
+        self.__logLevel = level
+        self.__myLog == None
+        
+    def initSearchEngine(self):
+        # No search engine for the high level class
+        pass
+    def processSearch(self, k, vPrompt):
+        # No search engine for the high level class
+        pass
+    def addEmbeddings(self, vChunks):
+        # No search engine for the high level class
+        pass
 
-    def __CLI_fmtMsgForLog(self, message, limit = C.TRACE_MSG_LENGTH):
+    def __fmtMsgForLog(self, message, limit = C.TRACE_MSG_LENGTH):
         """ Format a message for logging
         Args:
             message (str): log message
             limit (int, optional): message max length. Defaults to C.TRACE_MSG_LENGTH.
         Returns:
             formatted message: _description_
         """
         logMsg = message.replace("\n", " ")
         dots = ""
         if (len(message) > limit):
             dots = " ..."
         logMsg = logMsg[:limit] + dots
         return logMsg
-    
-    def __CLI_buildOutput(self, response, error = False, errorMsg = C.NULLSTRING):
-        """ Build the final output display of the process
-        Args:
-            response (str): final response
-            error (bool, optional): has error ? Defaults to False.
-            errorMsg (str, optional): error message. Defaults to C.NULLSTRING.
-        Returns:
-            str: JSON output with main milestones
-            str: status
-            str: final LLM response
-        """
-        try:
-            outJson, outStatus, outResponse = "", "", ""
-            self.__milestones.stop()
-            outJson = self.milestones.getFullJSON()
-            if (error):
-                self.log.error("Output: Response> {} | Error> {}".format(self.__CLI_fmtMsgForLog(response), errorMsg))
-                outStatus = C.OUT_ERROR
-                outResponse = errorMsg
-            else:
-                self.log.info("Output: Response> {}".format(self.__CLI_fmtMsgForLog(response)))
-                outStatus = C.OUT_SUCCESS
-                outResponse = response
-            self.log.info("** STOP **")
-            return outJson, outStatus, outResponse
-        except Exception as e:
-            self.log.error(str(e))
-            return outJson, outStatus, outResponse
-            
-    def CLI_output(self, response, error = False, errorMsg = C.NULLSTRING):
-        """ Build the final output of the process for the CLI (Standard Output (CLI) printing via XML tags)
-        Args:
-            response (str): final response
-            error (bool, optional): has error ? Defaults to False.
-            errorMsg (str, optional): error message. Defaults to C.NULLSTRING.
-        Returns:
-            str: JSON output with main milestones
-            str: status
-            str: final LLM response
-        """
-        outJson, outStatus, outResponse = self.__CLI_buildOutput(response, error, errorMsg)
-        print(C.TAG_O_LOG + outJson + C.TAG_C_LOG)
-        print(C.TAG_O_STATUS + outStatus + C.TAG_C_STATUS)
-        print(C.TAG_O_RESPONSE + outResponse + C.TAG_C_RESPONSE)
+
+    @property
+    def milestones(self):
+        return self.__milestones
+    @property
+    def log(self):
+        if (self.__myLog == None):
+            self.__myLog = log(loggerName=C.TRACE_LOGGER, 
+                            logfilename=self.__ragLogFileName,
+                            level=self.__logLevel)
+        return self.__myLog
+
+    def addMilestone(self, name, description, *others):
+        self.__milestones.add(name, description, others)
+        self.log.info("Step {} -> {}".format(name, self.__fmtMsgForLog(description)))
 
     def readTXT(self, txtfile) -> str:
         """ Reads a txt file
         Args:
             txtfile (str): text file path
         Returns:
             str: text read
@@ -114,27 +86,27 @@
             self.addMilestone("PDF2TXT", "TXT file successfully loaded. Text length : {}".format(len(doc.content)))
             self.log.info("TXT file loaded successfully")
             return doc
         except Exception as e:
             self.log.error("Error while reading the TXT file: {}".format(str(e)))
             return ""
 
-    def readPDF(self, pdffile, method = C.ARG_READER_VALPYPDF) -> str:
+    def readPDF(self, pdffile, method = C.READER_VALPYPDF) -> str:
         """ Reads a pdf file and converts it to Text
         Args:
             pdffile (str): pdf file path
-            method (str, optional): Type of conversion. Defaults to C.ARG_READER_VALPYPDF.
+            method (str, optional): Type of conversion. Defaults to C.READER_VALPYPDF.
         Returns:
             str: text converted
         """
         try:
             # Read and parse a pdf file
             self.log.info("Read PDF file {} by using mode {}...".format(pdffile, method))
             pdf = document()
-            if (method == C.ARG_READER_VALPYPDF):
+            if (method == C.READER_VALPYPDF):
                 pdf.pyMuPDFParseDocument(pdffile)
             else:
                 pdf.llamaParseDocument(pdffile)
             if (len(pdf.content) <= 0):
                 raise Exception("Error while converting the PDF document to text")
             self.addMilestone("PDF2TXT", "PDF converted to TEXT successfully. Text length : {}".format(len(pdf.content)))
             self.log.info("PDF file opened successfully")
```

## ragfmk/ragChromaDB.py

```diff
@@ -1,34 +1,48 @@
 __author__ = "Benoit CAYLA"
 __email__ = "benoit@datacorner.fr"
 __license__ = "MIT"
 
 from ragfmk.rag import rag
-from ragfmk.elements.simsearchengines.chromaDBWrapper import chromaDBWrapper
+from ragfmk.elements.simsearchengines.ChromaDBWrapper import ChromaDBWrapper
+import src.ragfmk.utils.CONST as C
 
 class ragChromaDB(rag):
     def __init__(self):
-        self.__mycdb = chromaDBWrapper()
+        self.__mycdb = ChromaDBWrapper()
         self.__collectionName = "default"
+        self.__hostname = C.CDB_DEFAULT_HOST
+        self.__port = C.CDB_DEFAULT_PORT
         super().__init__()
-    
-    def setCLIArgs(self, args):
-        super().setCLIArgs(args)
         
     @property
     def collectionName(self):
         return self.__collectionName
     @collectionName.setter
     def collectionName(self, value):
         self.__collectionName = value
     
-    def initServer(self, hostname, port):
-        self.__mycdb.initServer(hostname, port)
+    @property
+    def hostname(self):
+        return self.__hostname
+    @hostname.setter
+    def hostname(self, value):
+        self.__hostname = value
+
+    @property
+    def port(self):
+        return self.__port
+    @port.setter
+    def port(self, value):
+        self.__port = value
+
+    def initSearchEngine(self):
+        self.__mycdb.initServer(self.hostname, self.port)
 
-    def add(self, vChunks) -> int:
+    def addEmbeddings(self, vChunks) -> int:
         """ Add text chunks (embeddings) in the Chroma DB
             Format:
             {0: {'text': 'How many jobs Joe Biden wants to create ?', 
                 'embedding': array([-6.65125623e-02,  4.26685601e-01, -1.22626998e-01, -1.14275487e-02,
                                     -1.76032424e-01, -2.55425069e-02,  3.19633447e-02,  1.10126780e-02,
                                     -1.75059751e-01,  2.00320985e-02,  3.28031659e-01,  1.18581623e-01,
                                     -9.89666581e-02,  1.68430805e-01,  1.19766712e-01, -7.14423656e-02, ...] 
@@ -41,15 +55,15 @@
         Args:
             vChunks (embeddings): embeddings object
         """
         ret = self.__mycdb.add(vChunks, self.__collectionName)
         self.addMilestone("ADDTOINDEX", "Add chunks to the Chroma DB Index")
         return ret
     
-    def search(self, k, vPrompt):
+    def processSearch(self, k, vPrompt):
         """ Makes a search in the FAISS index and returns the k mearest datasets from the prompt
         Args:
             k (int): most k nearest chunks
             vPrompt (embeddings): prompt embeddings
         Returns:
             nearest: Object with List of the most nearest neighbors
         """
```

## ragfmk/ragFAISS.py

```diff
@@ -1,33 +1,43 @@
 __author__ = "Benoit CAYLA"
 __email__ = "benoit@datacorner.fr"
 __license__ = "MIT"
 
 from ragfmk.elements.simsearchengines.FAISSWrapper import FAISSWrapper
 from ragfmk.rag import rag
 from ragfmk.elements.wrappers.nearest import nearest
+import ragfmk.utils.CONST as C
 
 """
     This FAISS implementation uses by default the sentence_transformer model (cf. C.EMBEDDING_MODEL) to create and manage embeddings
 """
+FAISS_INDEX_MEMORY = "memory"
 
 class ragFAISS(rag):
     def __init__(self):
         self.__myfaiss = FAISSWrapper()
-        self.__indexName = "memory"
+        self.__indexName = FAISS_INDEX_MEMORY
+        self.__storagePath = C.FAISS_DEFAULT_STORE
         super().__init__()
 
     @property
     def indexName(self):
         return self.__indexName
     @indexName.setter
     def indexName(self, value):
         self.__indexName = value
-        
-    def add(self, vChunks):
+
+    @property
+    def storagePath(self):
+        return self.__storagePath
+    @storagePath.setter
+    def storagePath(self, value):
+        self.__storagePath = value
+
+    def addEmbeddings(self, vChunks):
         """ Add text chunks (embeddings) in the FAISS index
             Format:
             {0: {'text': 'How many jobs Joe Biden wants to create ?', 
                 'embedding': array([-6.65125623e-02,  4.26685601e-01, -1.22626998e-01, -1.14275487e-02,
                                     -1.76032424e-01, -2.55425069e-02,  3.19633447e-02,  1.10126780e-02,
                                     -1.75059751e-01,  2.00320985e-02,  3.28031659e-01,  1.18581623e-01,
                                     -9.89666581e-02,  1.68430805e-01,  1.19766712e-01, -7.14423656e-02, ...] 
@@ -39,50 +49,52 @@
             }
         Args:
             vChunks (stEmbeddings): embeddings object to add into the index
         """
         self.__myfaiss.add(vChunks)
         self.addMilestone("ADDTOINDEX", "Add chunks to the FAISS Index")
 
-    def search(self, k, vPrompt) -> nearest:
+    def processSearch(self, k, vPrompt) -> nearest:
         """ Makes a search in the FAISS index and returns the k mearest datasets from the prompt
 
         Args:
             k (int): most k nearest chunks
             vPrompt (stEmbeddings): Object embeddings for the prompt
         Returns:
             DataFrame: List of the most nearest neighbors
         """
         similars = self.__myfaiss.getNearest(vPrompt, k)
         self.addMilestone("SIMILARSEARCH", "Similarity Search executed successfully")
         return similars
 
-    def save(self, path):
+    def saveIndex(self):
         """ Store the FAISS index on the disk
         Args:
             path (str): index path
         Returns:
             _type_: False if error
         """
         try:
             self.addMilestone("FAISSSTORE", "Chunks embeddings indexed and stored successfully")
-            self.__myfaiss.save(path, self.__indexName)
+            if (self.indexName != FAISS_INDEX_MEMORY):
+                self.__myfaiss.save(self.storagePath, self.indexName)
             return True
         except Exception as e:
             self.log.error("Error while storing FAISS index: {}".format(e))
             return False
-            
-    def load(self, path):
+
+    def initSearchEngine(self):
         """ Load the FAISS index on the disk
         Args:
             path (str): index path
         Returns:
             _type_: False if error
         """
         try:
-            self.addMilestone("FAISSLOAD", "Chunks embeddings loaded successfully")
-            self.__myfaiss.load(path, self.__indexName)
+            self.addMilestone("FAISSLOAD", "Loading Similarity Search Engine (FAISS)")
+            if (self.indexName != FAISS_INDEX_MEMORY):
+                self.__myfaiss.load(self.storagePath, self.indexName)
             return True
         except Exception as e:
             self.log.error("Error while loading FAISS index: {}".format(e))
             return False
```

## ragfmk/elements/embeddings/embeddings.py

```diff
@@ -1,31 +1,27 @@
 __author__ = "Benoit CAYLA"
 __email__ = "benoit@datacorner.fr"
 __license__ = "MIT"
 
 import ragfmk.utils.CONST as C
 import json
 from numpyencoder import NumpyEncoder
+from ragfmk.interfaces.IEmbeddings import IEmbeddings
 
 """
-        Embeddings and data are stored in JSON and used with the following format :
-        {0: {'text': 'How many jobs Joe Biden wants to create ?', 
-             'embedding': array([-6.65125623e-02,  4.26685601e-01, -1.22626998e-01, -1.14275487e-02,
-                                -1.76032424e-01, -2.55425069e-02,  3.19633447e-02,  1.10126780e-02,
-                                -1.75059751e-01,  2.00320985e-02,  3.28031659e-01,  1.18581623e-01,
-                                -9.89666581e-02,  1.68430805e-01,  1.19766712e-01, -7.14423656e-02, ...] 
-            },
-        1: {'text': '...', 
-            'embedding': array([...]
+        Embeddings and data are stored in Python list/JSON and used with the following format :
+        {0: {'text': 'The prompt or text', 
+             'embedding': array([-6.65125623e-02,  ..., -1.22626998e-01]) 
             },
+        1: {'text': '...',  'embedding': array([...]) },
         ...
         }
 """
 
-class embeddings:
+class embeddings(IEmbeddings):
     def __init__(self):
         self.__content = {}
 
     @property
     def content(self):
         return self.__content
     @content.setter
@@ -71,15 +67,15 @@
         Args:
             cks (chunks):  chunks object
         Returns:
             str: json with data and embeddings for all chunks
         """
         try: 
             vect = self.encode(cks)
-            vectAndData = zip(cks.list, vect)
+            vectAndData = zip(cks.items, vect)
             self.__wrap(vectAndData)
             return True
         except Exception as e:
             return False
         
     def save(self, filename) -> bool:
         """ Save the chunks in a file.
```

## ragfmk/elements/embeddings/stEmbeddings.py

```diff
@@ -24,10 +24,10 @@
 class stEmbeddings(embeddings):
     def __init__(self):
         super().__init__()
         
     def encode(self, cks):
         try:
             encoder = SentenceTransformer(C.EMBEDDING_MODEL)
-            return encoder.encode(cks.list)
+            return encoder.encode(cks.items)
         except:
             return None
```

## ragfmk/elements/simsearchengines/FAISSWrapper.py

```diff
@@ -105,11 +105,12 @@
             ktotal = self.index.ntotal
             distances, ann = self.index.search(vector, k=ktotal)
             # Sort search results and return a DataFrame
             results = pd.DataFrame({'distances': distances[0], 'ann': ann[0]})
             self.dfContent.index = self.dfContent.index.astype(int)
             merge = pd.merge(results, self.dfContent, left_on='ann', right_index=True)
             nr = nearest()
-            nr.list = merge[:k]["text"].to_list()
-            return nr #merge[:k]
+            nr.items = merge[:k]["text"].to_list()
+            nr.distances = merge[:k]["distances"].to_list()
+            return nr
         except:
             return None
```

## ragfmk/elements/wrappers/chunks.py

```diff
@@ -1,82 +1,93 @@
 __author__ = "Benoit CAYLA"
 __email__ = "benoit@datacorner.fr"
 __license__ = "MIT"
 
-import ragfmk.utils.CONST as C
 import json
 from numpyencoder import NumpyEncoder
+import ragfmk.utils.CONST as C
+from ragfmk.interfaces.IChunks import IChunks
 
 """ Manages the Chunks file structure (JSON)
     Content = {"chunks": [..., ...] }
 """
 
-class chunks:
+class chunks(IChunks):
     def __init__(self):
         self.__chunks = [] # simple Array which contains all the chunks
     
     @property
-    def list(self): 
+    def items(self): 
         return self.__chunks 
-    @list.setter
-    def list(self, q):
+    @items.setter
+    def items(self, q):
         self.__chunks = q
 
+    def __getitem__(self, item):
+        """ Makes the Data column accessible via [] array
+            example: df['colName']
+        Args:
+            item (str): attribute/column name
+        Returns:
+            object: data
+        """
+        return self.__chunks.__getitem__(item)
+    
     @property
-    def jsonContent(self) -> str: 
+    def jsonContent(self): 
         return json.dumps(self.__createEnveloppe(), cls=NumpyEncoder)
     @jsonContent.setter
     def jsonContent(self, content):
         try:
             jsonEnv = json.loads(content)
-            self.list = jsonEnv[C.JST_CHUNKS]
+            self.items = jsonEnv[C.JST_CHUNKS]
         except Exception as e:
-            self.list = []
-        
+            self.items = []
+
     @property
-    def size(self) -> list: 
-        return len(self.list)
+    def size(self): 
+        return len(self.items)
     
-    def __createEnveloppe(self) -> str:
+    def __createEnveloppe(self):
         jsonEnv = {}
-        jsonEnv[C.JST_CHUNKS] = self.list
+        jsonEnv[C.JST_CHUNKS] = self.items
         return jsonEnv
     
     def add(self, chunk):
         self.__chunks.append(chunk)
     
     def setLangchainDocument(self, lcDoc):
         """ Wrap and store the document langchain
         Args:
             docs (document): langchain document
         Returns:
             int: Number of chunks
             str: json chunks -> {'chunks': ['Transcript of ...', ...] }
         """
         try:
-            self.list = [ x.page_content for x in lcDoc ]
+            self.items = [ x.page_content for x in lcDoc ]
             return True
         except Exception as e:
             return False
 
-    def save(self, filename) -> bool:
+    def save(self, filename):
         """ Save the chunks in a file.
         Args:
             filename (_type_): JSON chunks file
         Returns:
             bool: True if ok
         """
         try:
             with open(filename, "w", encoding=C.ENCODING) as f:
                 f.write(self.jsonContent)
             return True
         except Exception as e:
             return False
 
-    def load(self, filename = "", content = "") -> bool:
+    def load(self, filename = "", content = ""):
         """ Load and build a chunk file (can be loaded from a json file or a json content). 
             Format required : Content = {"chunks": [..., ...] }
         Args:
             filename (str, optional): JSON chunks file. Defaults to "".
             content (str, optional): JSON chunks content. Defaults to "".
         Returns:
             bool: True if ok
@@ -86,11 +97,11 @@
             if (len(filename) >0):
                 with open(filename, "r", encoding=C.ENCODING) as f:
                     jsonEnv = json.load(f)
             elif (len(content) >0):
                 jsonEnv = content
             else:
                 return False
-            self.list = jsonEnv[C.JST_CHUNKS]
+            self.items = jsonEnv[C.JST_CHUNKS]
             return True
         except Exception as e:
             return False
```

## ragfmk/elements/wrappers/document.py

```diff
@@ -3,32 +3,33 @@
 __license__ = "MIT"
 
 import fitz # pip install PyMuPDF
 from langchain.text_splitter import CharacterTextSplitter
 from langchain_experimental.text_splitter import SemanticChunker
 from langchain_community.embeddings import HuggingFaceEmbeddings
 from ragfmk.elements.wrappers.chunks import chunks
+from ragfmk.interfaces.IDocument import IDocument
 import ragfmk.utils.CONST as C
 import os
 import mimetypes
 import requests
 import time
 
-class document:
+class document(IDocument):
     def __init__(self):
         self.__content = ""
     
     @property
-    def content(self) -> str: 
+    def content(self): 
         return self.__content
     @content.setter
     def content(self, q):
         self.__content = q
 
-    def load(self, filename) -> bool:
+    def load(self, filename):
         """ read a file (text) and get the content from
         Args:
             filename (str): file name and path
         Returns:
             bool: True if ok
         """
         try:
```

## ragfmk/elements/wrappers/nearest.py

```diff
@@ -1,41 +1,59 @@
 __author__ = "Benoit CAYLA"
 __email__ = "benoit@datacorner.fr"
 __license__ = "MIT"
 
 import ragfmk.utils.CONST as C
 import json
 from numpyencoder import NumpyEncoder
+from ragfmk.interfaces.INearest import INearest
 
 """ Manages the Chunks file structure (JSON)
     Content = {"chunks": [..., ...] }
 """
 
-class nearest:
+class nearest(INearest):
     def __init__(self):
         self.__items = [] # simple Array which contains all the items
-    
+        self.__distances = [] # list of distances per items
+        
     @property
-    def list(self): 
+    def items(self): 
         return self.__items 
-    @list.setter
-    def list(self, q):
+    @items.setter
+    def items(self, q):
         self.__items = q
-
+    def __getitem__(self, item):
+        """ Makes the Data column accessible via [] array
+            example: df['colName']
+        Args:
+            item (str): attribute/column name
+        Returns:
+            object: data
+        """
+        return self.__items.__getitem__(item)
+    
+    @property
+    def distances(self): 
+        return self.__distances 
+    @distances.setter
+    def distances(self, q):
+        self.__distances = q
+        
     @property
     def jsonContent(self) -> str: 
         return json.dumps(self.__createEnveloppe(), cls=NumpyEncoder)
 
     @property
-    def size(self) -> list: 
-        return len(self.list)
+    def size(self) -> items: 
+        return len(self.items)
     
     def __createEnveloppe(self) -> str:
         jsonEnv = {}
-        jsonEnv[C.JST_NEAREST] = self.list
+        jsonEnv[C.JST_NEAREST] = self.items
         return jsonEnv
     
     def add(self, item):
         self.__items.append(item)
 
     def save(self, filename) -> bool:
         """ Save the chunks in a file.
@@ -65,11 +83,11 @@
             if (len(filename) >0):
                 with open(filename, "r", encoding=C.ENCODING) as f:
                     jsonEnv = json.load(f)
             elif (len(content) >0):
                 jsonEnv = content
             else:
                 return False
-            self.list = jsonEnv[C.JST_NEAREST]
+            self.items = jsonEnv[C.JST_NEAREST]
             return True
         except Exception as e:
             return False
```

## ragfmk/elements/wrappers/prompt.py

```diff
@@ -30,13 +30,13 @@
     @context.setter
     def context(self, q):
         self.__context = q
     
     def build(self):
         try: 
             itemContext = ""
-            for i, item in enumerate(self.context.list):
+            for i, item in enumerate(self.context.items):
                 itemContext = itemContext + C.ITEM_CONTEXT_TEMPLATE_LINE.format(i=i, contextItem=item) + "\n"
             return self.template.format(prompt=self.question, 
                                         context=itemContext)
         except:
             return ""
```

## ragfmk/utils/CONST.py

```diff
@@ -8,19 +8,19 @@
 # Diverse Consts
 NULLSTRING = ""
 ENCODING = "utf-8"
 
 # Logger configuration
 TRACE_DEFAULT_LEVEL = logging.DEBUG
 TRACE_DEFAULT_FORMAT = "%(asctime)s|%(name)s|%(levelname)s|%(message)s"
-TRACE_FILENAME = "ragcli.log"
+TRACE_FILENAME = "rag-framework.log"
 TRACE_MAXBYTES = 10000
-TRACE_LOGGER = "RAGCLI"
+TRACE_LOGGER = "RAGFMK"
 TRACE_MSG_LENGTH = 200
-RAGCLI_LOGFILE_ENV = "RAGCLI_LOGFILE"
+RAGCLI_LOGFILE_ENV = "RAGFMK_LOGFILE"
 FAISS_DEFAULT_NAME = "faiss"
 FAISS_DEFAULT_STORE = "./vstore"
 
 # LLM stuff
 SEMCHUNK_EMBEDDING_MODEL = "sentence-transformers/all-mpnet-base-v2"
 EMBEDDING_MODEL = "paraphrase-mpnet-base-v2"
 OLLAMA_LOCAL_URL = "http://localhost:11434/api"
@@ -41,65 +41,20 @@
 PROMPT_RAG_TEMPLATE = "Question: {prompt}\n Please answer the question based on the informations listed below: {context}"
 ITEM_CONTEXT_TEMPLATE_LINE = "Context {i}: {contextItem}"
 
 # Output status
 OUT_ERROR = "ERROR"
 OUT_SUCCESS = "SUCCESS"
 
-# Output TAGs
-TAG_O_RESPONSE = "<response>"
-TAG_C_RESPONSE = "</response>"
-TAG_O_LOG = "<log>"
-TAG_C_LOG = "</log>"
-TAG_O_ERROR = "<error>"
-TAG_C_ERROR = "</error>"
-TAG_O_STATUS = "<status>"
-TAG_C_STATUS = "</status>"
-
-# Command line arguments
-ARG_READER = ["reader", "Document Reader type"]
-ARG_READER_VALPYPDF = "pymupdf"
-ARG_READER_VALLLAMAPARSE = "llamaparse"
-ARG_KEY = ["key", "API's key"]
-ARG_PROMPT = ["prompt", "Prompt to send to the LLM"]
-ARG_PROMPT_TEMPLATE = ["template", "Prompt template to use when building the prompt (must contain {prompt} and {context}"]
-ARG_TEMP = ["temperature", "LLM Temperature parameter, by defaul 0.9"]
-ARG_PDFFILE = ["pdf", "PDF file path"]
-ARG_TXTFILE = ["txt", "Text file path"]
-ARG_CHUNKS = ["chunks", "JSON file path which contains the chunks"]
-ARG_CHUNKTYPE = ["chunktype", "Type of chunking method"]
-ARG_CHUNKTYPE_VALCHAR = "character"
-ARG_CHUNKTYPE_VALSEM = "semantic"
-ARG_FAISSNAME = ["faissname", "FAISS Index reference name"]
-ARG_FAISSPATH = ["faisspath", "FAISS Index reference path (FAISS index and data storage)"]
-ARG_CHUNKSIZE = ["chunk_size", "Chunk Size"]
-ARG_CHUNKOVAP = ["chunk_overlap", "Chunk Overlap"]
-ARG_SEP = ["sep", "Separator for chunking"]
-ARG_NEAREST = ["nearest", "Faiss Number of nearest chunks to gather for prompting"]
-ARG_MODEL = ["model", "Ollama Model installed"]
-ARG_URL = ["urlbase", "URL for Ollama API (default localhost)"]
-ARG_EMBEDDINGS = ["embeddings", "JSON file path which contains the data and embeddings"]
-ARG_EMBEDDINGS_PT = ["embprompt", "JSON file path which contains the data and embeddings for the prompt"]
-ARG_EMBEDDINGS_CK = ["embchunks", "JSON file path which contains the data and embeddings for the chunks"]
-ARG_FAISSACTION = ["action", "Action to execute on the FAISS Engine (store/indexsearch/memsearch)"]
-ARG_FAISSACTION_VALMSEARCH = "memsearch"
-ARG_FAISSACTION_VALISEARCH = "indexsearch"
-ARG_FAISSACTION_VALSTORE = "store"
-ARG_NEARESTFILE = ["nfile", "JSON file path which contains the nearest chunks/texts"]
-ARG_CDB_COLLECTION = ["collection", "Chroma DB collection name"]
-ARG_CDB_VALSEARCH = "search"
-ARG_CDB_VALSTORE = "store"
-ARG_CDB_ACTION = ["action", "Action to execute on the Chroma DB Engine (store/search)"]
-ARG_CDB_HOST = ["host", "Chroma DB host name (or IP address)"]
-ARG_CDB_PORT = ["port", "Chroma DB port number"]
-
 # Llamaparse
 LLAMAPARSE_API_URL = "https://api.cloud.llamaindex.ai/api/parsing"
 LLAMAPARSE_API_WAITSEC = 2
 LLAMAPARSE_ITERATION_MAX = 20
 LLAMAINDEX_API_KEY = "LLAMAINDEX_API_KEY"
+READER_VALPYPDF = "pymupdf"
+READER_VALLLAMAPARSE = "llamaparse"
 
 # Chroma DB
 CDB_DEFAULT_HOST = "localhost"
 CDB_DEFAULT_PORT = 8000
 CDB_DEFAULT_COLLECTION = "default"
 CDB_DEFAULT_EMBEDDINGSMODEL_ST = "all-MiniLM-L6-v2"
```

## Comparing `ragfmk/elements/simsearchengines/chromaDBWrapper.py` & `ragfmk/elements/simsearchengines/ChromaDBWrapper.py`

 * *Files 4% similar despite different names*

```diff
@@ -11,15 +11,15 @@
 """ 
     Leverage Chroma DB
     Starts server locally bveforehand: 
         $ chroma run --path D:/chromadb
 """
 embFunction = embedding_functions.SentenceTransformerEmbeddingFunction(model_name=C.CDB_DEFAULT_EMBEDDINGSMODEL_ST)
 
-class chromaDBWrapper:
+class ChromaDBWrapper:
     def __init__(self):
        self.__chroma_client = None
     
     def initServer(self, host, port):
         self.__chroma_client = chromadb.HttpClient(host=host, port=port)
         
     def initLocal(self):
@@ -74,13 +74,13 @@
             DataFrame: List of the most nearest neighbors
         """
         try:
             collection = self.getCollection(collectionName) 
             if (collection == None):
                 raise Exception ("Impossible to get the collection from Chroma DB")
             result = collection.query(query_embeddings=vText.content["0"]["embedding"], n_results=k)
-            dfSimilar = pd.DataFrame(result["documents"][0], columns= [ C.JST_TEXT ])
             nr = nearest()
-            nr.list = dfSimilar["text"].to_list()
+            nr.items = result["documents"][0]
+            nr.distances = result["distances"][0]
             return nr
         except Exception as e:
             return None
```

## Comparing `ragfmk-0.1.2.1.dist-info/LICENSE` & `ragfmk-0.1.3.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `ragfmk-0.1.2.1.dist-info/METADATA` & `ragfmk-0.1.3.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: ragfmk
-Version: 0.1.2.1
+Version: 0.1.3
 Summary: This solution manages a full RAG by using FAISS or ChromaDB, Ollama and sentence_transformers for embeddings.
 Author-email: Benoit Cayla <benoit@datacorner.fr>
 License: MIT License
         
         Copyright (c) 2023 Benoît Cayla
         
         Permission is hereby granted, free of charge, to any person obtaining a copy
```

## Comparing `ragfmk-0.1.2.1.dist-info/RECORD` & `ragfmk-0.1.3.dist-info/RECORD`

 * *Files 12% similar despite different names*

```diff
@@ -1,38 +1,36 @@
-RagAdhocQueryDoc.py,sha256=hV2-fwwm7IqNMw1M-q_l2L0s8zwCnjcOHWIar23G2Yo,3201
-RagChromaDB.py,sha256=dDLEU64uHDuMbIqI9VZVJGuz4dMReoJQxf6vhVSV2Ow,3746
-RagChunkText.py,sha256=XpyKxcjWBQuXbU3mU666-MRsLpgBvSxErJ0mI4DwzEs,2696
-RagEmbeddings.py,sha256=hIuny3JTfa4U5JP7qzE-X7c9vopiXv-rp3KhOlzuVN8,2296
-RagFaiss.py,sha256=9syQBsWw8vi9Xlo-AfrujcRiJ1n5qabx32CwzrONlsg,3987
-RagLLM.py,sha256=C1On3brNWe_FpWjtTic2-zYBZTZKpoyNRSLjp_zeEOk,1443
-RagPdf2Text.py,sha256=9H5YinTVaNSuSL8H_cxTIdSlSy1TUctVhjRqQhW3sSI,1646
-RagPrompt.py,sha256=eB4BOlNCTlRVIpqbSfGJmNFZzsLGDSWgKaFU4N8H_io,1558
+RagAdhocQueryDoc.py,sha256=wkfGzr5lz1MFEyBjK1-ZT7hkGhuMrz0swHV2kWvyADk,3622
+RagPrompt.py,sha256=Rk2dMZq3lQ8RCnbm7sXeKwEjFH8ABX7YmUh6tgNkQ-A,1694
 __init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 ragfmk/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-ragfmk/rag.py,sha256=K8qA26FVf7diAkAo39x_xfq3T56z8bqCHHuHfX_9iPY,10510
-ragfmk/ragChromaDB.py,sha256=uHU1O7JKjV_IE8OvtDHwnATsaZGnTuQ1BX4d6ryZqz8,2275
-ragfmk/ragFAISS.py,sha256=wiRy8qdsgsC7ObNXsfp1UDwnbTFj9DhPdGRGkLPEjNs,3274
+ragfmk/rag.py,sha256=JElXSEIa6NsETnzSkxTuILFGxH2KHTjfLZaO-56f6_Q,9013
+ragfmk/ragChromaDB.py,sha256=3wZ0nIPWKfLuyiA4AvgREvv3RPRvgyWngmcr5_CIauk,2645
+ragfmk/ragFAISS.py,sha256=sM9I0b7uhCn4AOwlmPwVwURgCSJTntVBLi3WVe_OkcQ,3720
 ragfmk/elements/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 ragfmk/elements/embeddings/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-ragfmk/elements/embeddings/embeddings.py,sha256=Jy79SYeLX9M-g6llPQ0K1c2-8i-rycxVT4IA2UsNxfE,3925
-ragfmk/elements/embeddings/stEmbeddings.py,sha256=mxvuBgqfuR2HXmcur3FbUK81k2K4iZl2vkO2tjEnvzM,1225
+ragfmk/elements/embeddings/embeddings.py,sha256=DGqoSdYGkxAJYNjzfMq23Z0jFrhrGSim35e_nd-GA0Q,3623
+ragfmk/elements/embeddings/stEmbeddings.py,sha256=H-mRWBh3CNxQ3HqAylPLqsZHtVz7jq_rFKfwFmBZPUY,1226
 ragfmk/elements/llms/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 ragfmk/elements/llms/ollama.py,sha256=q78U-2bh4qk-JuO1lM8reMsrA1SG12k6KRyWkrsf8dg,1245
-ragfmk/elements/simsearchengines/FAISSWrapper.py,sha256=be0AkLJfkqb99KAq2ecmDdg_4ytQVcLlpDP3Zx9NAEk,4544
+ragfmk/elements/simsearchengines/ChromaDBWrapper.py,sha256=p18Qo_mz21qGqGnJlLlWfVfHaa336YpuFWQ4F_jwd-0,3400
+ragfmk/elements/simsearchengines/FAISSWrapper.py,sha256=0r_lVtK7Wgi6EF0XxHnoMlJiHkamiqMg_5CDiTc2Q6I,4595
 ragfmk/elements/simsearchengines/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-ragfmk/elements/simsearchengines/chromaDBWrapper.py,sha256=xKGFrhe6FXNRsxK4pkmNdWI0gYekr3qRiQUZumqFMK0,3440
 ragfmk/elements/wrappers/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-ragfmk/elements/wrappers/chunks.py,sha256=WjTvW_t45todSmPKEspdQUfxIqY6InUsI4w_8bUQ1Pw,2916
-ragfmk/elements/wrappers/document.py,sha256=Ctm-uN-d-SUAiJgQXbc7VGnOjotaHa46iLvbKeQVdHA,7558
-ragfmk/elements/wrappers/nearest.py,sha256=L2mQ9MDOvI067946mrow7Xn5cnHqvyvOi9XBPJ-ktbE,2218
-ragfmk/elements/wrappers/prompt.py,sha256=l7xBXbJXeUQcJZIPZgDTDhzQOEVfr0Zb-5A9nL5tKvc,1198
-ragfmk/utils/CONST.py,sha256=z64ad53IRHNnEQuCgHPNToP4qo-ozsFp_6GdzADomQA,4002
-ragfmk/utils/FUNCTIONS.py,sha256=wQ1XupmNELUlL8hZk3WHlAT0Il1JWC69VCSLP5OQNUk,143
+ragfmk/elements/wrappers/chunks.py,sha256=EEnRFzm2xNx-pEO0Jkam5UAM2r0dVPrTBjfVwkgfdaY,3237
+ragfmk/elements/wrappers/document.py,sha256=L-kbKr56X_XQSqhP-yFm-ANoYb_BAYcKPQwqdAug86Q,7605
+ragfmk/elements/wrappers/nearest.py,sha256=LMi96FEiBRGRgarlTrXHCsP8blR3YOiMhxSIzCRcuCY,2816
+ragfmk/elements/wrappers/prompt.py,sha256=sEKZ_hy0VPrIKlFAa5yAzq1bqPrS4bJOfPEURGx_ou4,1199
+ragfmk/interfaces/IChunks.py,sha256=md_sJ39Mg9iW4Bnn553WcYHqvUe-jf7GZ0RutIxtTjk,759
+ragfmk/interfaces/IDocument.py,sha256=UgivIp4Bc-qxPXtVO5u542wZUWDBaoX5Wmd4ncf1UOg,432
+ragfmk/interfaces/IEmbeddings.py,sha256=1zsQopimtSNdvvXO5g6BRNX8ahM0t8_9qEnOYnMR8IA,775
+ragfmk/interfaces/INearest.py,sha256=zZmcOp6t217sZU1O2TK6Jtip-JKB6_wxxFiATRGlFSE,847
+ragfmk/interfaces/IRag.py,sha256=X8_NYXJiD6-0z3ZMGMsXLnOWyjsS-wpYbiYdG55phqM,1244
+ragfmk/utils/CONST.py,sha256=bg_dOUfcDlmKBkvVLuODvC-ohfG7j10gKz42IpfkBsU,1697
 ragfmk/utils/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 ragfmk/utils/log.py,sha256=39zWFAuL5vZ1RGFhEFPZ5rCmUg32AdlYuUae5lRGHEU,1864
 ragfmk/utils/milestone.py,sha256=dA5T_0QVWtHv3HaAFVZkKCEdRDS2SQSJsi7g0e_glGw,1907
-ragfmk-0.1.2.1.dist-info/LICENSE,sha256=BvMmeujpLDerNqzsA1gOET7mphtef9ebt_u8-bp4bNA,1091
-ragfmk-0.1.2.1.dist-info/METADATA,sha256=i9cr07OU4VActRNhJqr7-MyQWfzsTmN3EyxAa87bQUo,8549
-ragfmk-0.1.2.1.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
-ragfmk-0.1.2.1.dist-info/entry_points.txt,sha256=wxkL6gKZ9HCQ4K3BzxYurJdD0OQebf3rylGUKjYIofI,262
-ragfmk-0.1.2.1.dist-info/top_level.txt,sha256=t4ox8u6Yr2e1x1zvOEgTEw3X6_3UiZYMnjCa4ZenM5E,110
-ragfmk-0.1.2.1.dist-info/RECORD,,
+ragfmk-0.1.3.dist-info/LICENSE,sha256=BvMmeujpLDerNqzsA1gOET7mphtef9ebt_u8-bp4bNA,1091
+ragfmk-0.1.3.dist-info/METADATA,sha256=PenWU2Cz3-0ej45SZeIHpoULPSQtNVHFNKKxzDp34G4,8547
+ragfmk-0.1.3.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+ragfmk-0.1.3.dist-info/entry_points.txt,sha256=EDEdK3AmGTz0ZLfXx10aBUy50jxn6Uy3isBcmPkE3jg,86
+ragfmk-0.1.3.dist-info/top_level.txt,sha256=6NrWPkR5zCFIJnz9grec4DG39Znl2xhbQklrnns9kZ4,43
+ragfmk-0.1.3.dist-info/RECORD,,
```

