# Comparing `tmp/lazylinop-1.8.0-py3-none-any.whl.zip` & `tmp/lazylinop-1.9.0a0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,49 +1,71 @@
-Zip file size: 108873 bytes, number of entries: 47
--rw-r--r--  2.0 unx      152 b- defN 24-Apr-14 06:54 lazylinop/__init__.py
--rw-r--r--  2.0 unx     8275 b- defN 24-Apr-14 06:54 lazylinop/check_op.py
--rw-r--r--  2.0 unx    52187 b- defN 24-Apr-14 06:54 lazylinop/lazylinop.py
--rw-r--r--  2.0 unx      370 b- defN 24-Apr-14 06:54 lazylinop/basicops/__init__.py
--rw-r--r--  2.0 unx     1508 b- defN 24-Apr-14 06:54 lazylinop/basicops/add.py
--rw-r--r--  2.0 unx     2255 b- defN 24-Apr-14 06:54 lazylinop/basicops/blockdiag.py
--rw-r--r--  2.0 unx     1852 b- defN 24-Apr-14 06:54 lazylinop/basicops/cat.py
--rw-r--r--  2.0 unx    11699 b- defN 24-Apr-14 06:54 lazylinop/basicops/diag.py
--rw-r--r--  2.0 unx     3406 b- defN 24-Apr-14 06:54 lazylinop/basicops/eye.py
--rw-r--r--  2.0 unx     3792 b- defN 24-Apr-14 06:54 lazylinop/basicops/kron.py
--rw-r--r--  2.0 unx     2309 b- defN 24-Apr-14 06:54 lazylinop/basicops/ones.py
--rw-r--r--  2.0 unx    31288 b- defN 24-Apr-14 06:54 lazylinop/basicops/pad.py
--rw-r--r--  2.0 unx     1573 b- defN 24-Apr-14 06:54 lazylinop/basicops/zeros.py
--rw-r--r--  2.0 unx      264 b- defN 24-Apr-14 06:54 lazylinop/polynomial/__init__.py
--rw-r--r--  2.0 unx    53006 b- defN 24-Apr-14 06:54 lazylinop/polynomial/polynomial.py
--rw-r--r--  2.0 unx       78 b- defN 24-Apr-14 06:54 lazylinop/wip/__init__.py
--rw-r--r--  2.0 unx     1443 b- defN 24-Apr-14 06:54 lazylinop/wip/code_optimization.py
--rw-r--r--  2.0 unx     1447 b- defN 24-Apr-14 06:54 lazylinop/wip/linear_algebra.py
--rw-r--r--  2.0 unx   133585 b- defN 24-Apr-14 06:54 lazylinop/wip/signal.py
--rw-r--r--  2.0 unx    57938 b- defN 24-Apr-14 06:54 lazylinop/wip/special_matrices.py
--rw-r--r--  2.0 unx       52 b- defN 24-Apr-14 06:54 lazylinop/wip/basicops/__init__.py
--rw-r--r--  2.0 unx     1607 b- defN 24-Apr-14 06:54 lazylinop/wip/basicops/average.py
--rw-r--r--  2.0 unx      573 b- defN 24-Apr-14 06:54 lazylinop/wip/basicops/mean.py
--rw-r--r--  2.0 unx      298 b- defN 24-Apr-14 06:54 lazylinop/wip/linalg/__init__.py
--rw-r--r--  2.0 unx     4792 b- defN 24-Apr-14 06:54 lazylinop/wip/linalg/coshm.py
--rw-r--r--  2.0 unx     2816 b- defN 24-Apr-14 06:54 lazylinop/wip/linalg/cosm.py
--rw-r--r--  2.0 unx     4233 b- defN 24-Apr-14 06:54 lazylinop/wip/linalg/expm.py
--rw-r--r--  2.0 unx     5587 b- defN 24-Apr-14 06:54 lazylinop/wip/linalg/khatri_rao.py
--rw-r--r--  2.0 unx     4667 b- defN 24-Apr-14 06:54 lazylinop/wip/linalg/logm.py
--rw-r--r--  2.0 unx     4694 b- defN 24-Apr-14 06:54 lazylinop/wip/linalg/sinhm.py
--rw-r--r--  2.0 unx     2823 b- defN 24-Apr-14 06:54 lazylinop/wip/linalg/sinm.py
--rw-r--r--  2.0 unx     1582 b- defN 24-Apr-14 06:54 lazylinop/wip/linalg/spectral_norm.py
--rw-r--r--  2.0 unx     3754 b- defN 24-Apr-14 06:54 lazylinop/wip/linalg/sqrtm.py
--rw-r--r--  2.0 unx      253 b- defN 24-Apr-14 06:54 lazylinop/wip/parallel/__init__.py
--rw-r--r--  2.0 unx     8328 b- defN 24-Apr-14 06:54 lazylinop/wip/parallel/mpilop.py
--rw-r--r--  2.0 unx     4897 b- defN 24-Apr-14 06:54 lazylinop/wip/parallel/pmatmat.py
--rw-r--r--  2.0 unx     4250 b- defN 24-Apr-14 06:54 lazylinop/wip/parallel/pmatmat_mpi.py
--rw-r--r--  2.0 unx     5902 b- defN 24-Apr-14 06:54 lazylinop/wip/parallel/pmatmat_process.py
--rw-r--r--  2.0 unx     3306 b- defN 24-Apr-14 06:54 lazylinop/wip/parallel/pmatmat_thread.py
--rw-r--r--  2.0 unx       23 b- defN 24-Apr-14 06:54 lazylinop/wip/random/__init__.py
--rw-r--r--  2.0 unx     6721 b- defN 24-Apr-14 06:54 lazylinop/wip/random/rand.py
--rw-r--r--  2.0 unx     9453 b- defN 24-Apr-14 06:54 lazylinop/wip/signal/slices.py
--rw-r--r--  2.0 unx     1434 b- defN 24-Apr-14 06:54 lazylinop-1.8.0.dist-info/LICENSE.txt
--rw-r--r--  2.0 unx     8177 b- defN 24-Apr-14 06:54 lazylinop-1.8.0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-Apr-14 06:54 lazylinop-1.8.0.dist-info/WHEEL
--rw-r--r--  2.0 unx       10 b- defN 24-Apr-14 06:54 lazylinop-1.8.0.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     4037 b- defN 24-Apr-14 06:54 lazylinop-1.8.0.dist-info/RECORD
-47 files, 462788 bytes uncompressed, 102437 bytes compressed:  77.9%
+Zip file size: 138601 bytes, number of entries: 69
+-rw-r--r--  2.0 unx      178 b- defN 24-Apr-30 12:04 lazylinop/__init__.py
+-rw-r--r--  2.0 unx     8275 b- defN 24-Apr-30 12:04 lazylinop/check_op.py
+-rw-r--r--  2.0 unx    52918 b- defN 24-Apr-30 12:04 lazylinop/lazylinop.py
+-rw-r--r--  2.0 unx      370 b- defN 24-Apr-30 12:04 lazylinop/basicops/__init__.py
+-rw-r--r--  2.0 unx     1508 b- defN 24-Apr-30 12:04 lazylinop/basicops/add.py
+-rw-r--r--  2.0 unx     2255 b- defN 24-Apr-30 12:04 lazylinop/basicops/blockdiag.py
+-rw-r--r--  2.0 unx     1852 b- defN 24-Apr-30 12:04 lazylinop/basicops/cat.py
+-rw-r--r--  2.0 unx    11699 b- defN 24-Apr-30 12:04 lazylinop/basicops/diag.py
+-rw-r--r--  2.0 unx     3449 b- defN 24-Apr-30 12:04 lazylinop/basicops/eye.py
+-rw-r--r--  2.0 unx     3792 b- defN 24-Apr-30 12:04 lazylinop/basicops/kron.py
+-rw-r--r--  2.0 unx     2309 b- defN 24-Apr-30 12:04 lazylinop/basicops/ones.py
+-rw-r--r--  2.0 unx    42464 b- defN 24-Apr-30 12:04 lazylinop/basicops/pad.py
+-rw-r--r--  2.0 unx     1573 b- defN 24-Apr-30 12:04 lazylinop/basicops/zeros.py
+-rw-r--r--  2.0 unx      264 b- defN 24-Apr-30 12:04 lazylinop/polynomial/__init__.py
+-rw-r--r--  2.0 unx    53006 b- defN 24-Apr-30 12:04 lazylinop/polynomial/polynomial.py
+-rw-r--r--  2.0 unx      100 b- defN 24-Apr-30 12:04 lazylinop/wip/__init__.py
+-rw-r--r--  2.0 unx     1443 b- defN 24-Apr-30 12:04 lazylinop/wip/code_optimization.py
+-rw-r--r--  2.0 unx     1447 b- defN 24-Apr-30 12:04 lazylinop/wip/linear_algebra.py
+-rw-r--r--  2.0 unx    57938 b- defN 24-Apr-30 12:04 lazylinop/wip/special_matrices.py
+-rw-r--r--  2.0 unx       85 b- defN 24-Apr-30 12:04 lazylinop/wip/basicops/__init__.py
+-rw-r--r--  2.0 unx    12658 b- defN 24-Apr-30 12:04 lazylinop/wip/basicops/anti_diag.py
+-rw-r--r--  2.0 unx     4066 b- defN 24-Apr-30 12:04 lazylinop/wip/basicops/average.py
+-rw-r--r--  2.0 unx     2206 b- defN 24-Apr-30 12:04 lazylinop/wip/basicops/mean.py
+-rw-r--r--  2.0 unx      298 b- defN 24-Apr-30 12:04 lazylinop/wip/linalg/__init__.py
+-rw-r--r--  2.0 unx     4792 b- defN 24-Apr-30 12:04 lazylinop/wip/linalg/coshm.py
+-rw-r--r--  2.0 unx     2816 b- defN 24-Apr-30 12:04 lazylinop/wip/linalg/cosm.py
+-rw-r--r--  2.0 unx     4233 b- defN 24-Apr-30 12:04 lazylinop/wip/linalg/expm.py
+-rw-r--r--  2.0 unx     5587 b- defN 24-Apr-30 12:04 lazylinop/wip/linalg/khatri_rao.py
+-rw-r--r--  2.0 unx     4667 b- defN 24-Apr-30 12:04 lazylinop/wip/linalg/logm.py
+-rw-r--r--  2.0 unx     4694 b- defN 24-Apr-30 12:04 lazylinop/wip/linalg/sinhm.py
+-rw-r--r--  2.0 unx     2823 b- defN 24-Apr-30 12:04 lazylinop/wip/linalg/sinm.py
+-rw-r--r--  2.0 unx     1582 b- defN 24-Apr-30 12:04 lazylinop/wip/linalg/spectral_norm.py
+-rw-r--r--  2.0 unx     3754 b- defN 24-Apr-30 12:04 lazylinop/wip/linalg/sqrtm.py
+-rw-r--r--  2.0 unx      253 b- defN 24-Apr-30 12:04 lazylinop/wip/parallel/__init__.py
+-rw-r--r--  2.0 unx     8328 b- defN 24-Apr-30 12:04 lazylinop/wip/parallel/mpilop.py
+-rw-r--r--  2.0 unx     4897 b- defN 24-Apr-30 12:04 lazylinop/wip/parallel/pmatmat.py
+-rw-r--r--  2.0 unx     4250 b- defN 24-Apr-30 12:04 lazylinop/wip/parallel/pmatmat_mpi.py
+-rw-r--r--  2.0 unx     5902 b- defN 24-Apr-30 12:04 lazylinop/wip/parallel/pmatmat_process.py
+-rw-r--r--  2.0 unx     3306 b- defN 24-Apr-30 12:04 lazylinop/wip/parallel/pmatmat_thread.py
+-rw-r--r--  2.0 unx       23 b- defN 24-Apr-30 12:04 lazylinop/wip/random/__init__.py
+-rw-r--r--  2.0 unx     6721 b- defN 24-Apr-30 12:04 lazylinop/wip/random/rand.py
+-rw-r--r--  2.0 unx      501 b- defN 24-Apr-30 12:04 lazylinop/wip/signal/__init__.py
+-rw-r--r--  2.0 unx     3796 b- defN 24-Apr-30 12:04 lazylinop/wip/signal/anti_eye.py
+-rw-r--r--  2.0 unx     4084 b- defN 24-Apr-30 12:04 lazylinop/wip/signal/bc.py
+-rw-r--r--  2.0 unx     4117 b- defN 24-Apr-30 12:04 lazylinop/wip/signal/bc2d.py
+-rw-r--r--  2.0 unx    34045 b- defN 24-Apr-30 12:04 lazylinop/wip/signal/convolve.py
+-rw-r--r--  2.0 unx    12692 b- defN 24-Apr-30 12:04 lazylinop/wip/signal/convolve2d.py
+-rw-r--r--  2.0 unx    11141 b- defN 24-Apr-30 12:04 lazylinop/wip/signal/dct.py
+-rw-r--r--  2.0 unx     3272 b- defN 24-Apr-30 12:04 lazylinop/wip/signal/decimate.py
+-rw-r--r--  2.0 unx    10179 b- defN 24-Apr-30 12:04 lazylinop/wip/signal/ds_mconv.py
+-rw-r--r--  2.0 unx     9636 b- defN 24-Apr-30 12:04 lazylinop/wip/signal/dsconvolve.py
+-rw-r--r--  2.0 unx    12181 b- defN 24-Apr-30 12:04 lazylinop/wip/signal/dst.py
+-rw-r--r--  2.0 unx    12014 b- defN 24-Apr-30 12:04 lazylinop/wip/signal/dwt1d.py
+-rw-r--r--  2.0 unx    18663 b- defN 24-Apr-30 12:04 lazylinop/wip/signal/dwt2d.py
+-rw-r--r--  2.0 unx    11167 b- defN 24-Apr-30 12:04 lazylinop/wip/signal/fft.py
+-rw-r--r--  2.0 unx     2714 b- defN 24-Apr-30 12:04 lazylinop/wip/signal/fft2.py
+-rw-r--r--  2.0 unx     2854 b- defN 24-Apr-30 12:04 lazylinop/wip/signal/flip.py
+-rw-r--r--  2.0 unx     7186 b- defN 24-Apr-30 12:04 lazylinop/wip/signal/fwht.py
+-rw-r--r--  2.0 unx      269 b- defN 24-Apr-30 12:04 lazylinop/wip/signal/is_power_of_two.py
+-rw-r--r--  2.0 unx     3315 b- defN 24-Apr-30 12:04 lazylinop/wip/signal/mslices.py
+-rw-r--r--  2.0 unx     2438 b- defN 24-Apr-30 12:04 lazylinop/wip/signal/oa.py
+-rw-r--r--  2.0 unx     3230 b- defN 24-Apr-30 12:04 lazylinop/wip/signal/scatter_and_gather_windows.py
+-rw-r--r--  2.0 unx     9463 b- defN 24-Apr-30 12:04 lazylinop/wip/signal/slices.py
+-rw-r--r--  2.0 unx     4291 b- defN 24-Apr-30 12:04 lazylinop/wip/signal/stft.py
+-rw-r--r--  2.0 unx     1434 b- defN 24-Apr-30 12:04 lazylinop-1.9.0a0.dist-info/LICENSE.txt
+-rw-r--r--  2.0 unx     8485 b- defN 24-Apr-30 12:04 lazylinop-1.9.0a0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-Apr-30 12:04 lazylinop-1.9.0a0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       10 b- defN 24-Apr-30 12:04 lazylinop-1.9.0a0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     5999 b- defN 24-Apr-30 12:04 lazylinop-1.9.0a0.dist-info/RECORD
+69 files, 534049 bytes uncompressed, 129091 bytes compressed:  75.8%
```

## zipnote {}

```diff
@@ -48,23 +48,23 @@
 
 Filename: lazylinop/wip/code_optimization.py
 Comment: 
 
 Filename: lazylinop/wip/linear_algebra.py
 Comment: 
 
-Filename: lazylinop/wip/signal.py
-Comment: 
-
 Filename: lazylinop/wip/special_matrices.py
 Comment: 
 
 Filename: lazylinop/wip/basicops/__init__.py
 Comment: 
 
+Filename: lazylinop/wip/basicops/anti_diag.py
+Comment: 
+
 Filename: lazylinop/wip/basicops/average.py
 Comment: 
 
 Filename: lazylinop/wip/basicops/mean.py
 Comment: 
 
 Filename: lazylinop/wip/linalg/__init__.py
@@ -117,26 +117,92 @@
 
 Filename: lazylinop/wip/random/__init__.py
 Comment: 
 
 Filename: lazylinop/wip/random/rand.py
 Comment: 
 
+Filename: lazylinop/wip/signal/__init__.py
+Comment: 
+
+Filename: lazylinop/wip/signal/anti_eye.py
+Comment: 
+
+Filename: lazylinop/wip/signal/bc.py
+Comment: 
+
+Filename: lazylinop/wip/signal/bc2d.py
+Comment: 
+
+Filename: lazylinop/wip/signal/convolve.py
+Comment: 
+
+Filename: lazylinop/wip/signal/convolve2d.py
+Comment: 
+
+Filename: lazylinop/wip/signal/dct.py
+Comment: 
+
+Filename: lazylinop/wip/signal/decimate.py
+Comment: 
+
+Filename: lazylinop/wip/signal/ds_mconv.py
+Comment: 
+
+Filename: lazylinop/wip/signal/dsconvolve.py
+Comment: 
+
+Filename: lazylinop/wip/signal/dst.py
+Comment: 
+
+Filename: lazylinop/wip/signal/dwt1d.py
+Comment: 
+
+Filename: lazylinop/wip/signal/dwt2d.py
+Comment: 
+
+Filename: lazylinop/wip/signal/fft.py
+Comment: 
+
+Filename: lazylinop/wip/signal/fft2.py
+Comment: 
+
+Filename: lazylinop/wip/signal/flip.py
+Comment: 
+
+Filename: lazylinop/wip/signal/fwht.py
+Comment: 
+
+Filename: lazylinop/wip/signal/is_power_of_two.py
+Comment: 
+
+Filename: lazylinop/wip/signal/mslices.py
+Comment: 
+
+Filename: lazylinop/wip/signal/oa.py
+Comment: 
+
+Filename: lazylinop/wip/signal/scatter_and_gather_windows.py
+Comment: 
+
 Filename: lazylinop/wip/signal/slices.py
 Comment: 
 
-Filename: lazylinop-1.8.0.dist-info/LICENSE.txt
+Filename: lazylinop/wip/signal/stft.py
+Comment: 
+
+Filename: lazylinop-1.9.0a0.dist-info/LICENSE.txt
 Comment: 
 
-Filename: lazylinop-1.8.0.dist-info/METADATA
+Filename: lazylinop-1.9.0a0.dist-info/METADATA
 Comment: 
 
-Filename: lazylinop-1.8.0.dist-info/WHEEL
+Filename: lazylinop-1.9.0a0.dist-info/WHEEL
 Comment: 
 
-Filename: lazylinop-1.8.0.dist-info/top_level.txt
+Filename: lazylinop-1.9.0a0.dist-info/top_level.txt
 Comment: 
 
-Filename: lazylinop-1.8.0.dist-info/RECORD
+Filename: lazylinop-1.9.0a0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## lazylinop/__init__.py

```diff
@@ -1,6 +1,7 @@
 from .check_op import check_op
 from . import lazylinop
 from .lazylinop import *
 from .basicops import *
 from .polynomial import *
-__version__ = '1.8.0'
+from .wip import signal
+__version__ = '1.9.0a0'
```

## lazylinop/lazylinop.py

```diff
@@ -353,27 +353,50 @@
 
     def _checkattr(self, attr):
         if self._root_obj is not None and not hasattr(self._root_obj, attr):
             raise TypeError(attr+' is not supported by the root object of this'
                             ' LazyLinOp')
 
     def _slice_to_indices(self, s, axis):
-        start = s.start if s.start is not None else 0
-        stop = s.stop if s.stop is not None else self.shape[axis]
-        if (s.step is not None and s.step < 0
-                and s.start is None and s.stop is None):
-            # the slice is [::-1]
-            # reverse start/stop
-            tmp = start
-            start = stop - 1
-            stop = tmp - 1
-        step = s.step if s.step is not None else 1
-        if start < 0 and stop < 0:
+        step = s.step
+        if step is None:
+            step = 1
+        if step == 0:
+            raise ValueError('slice step cannot be zero')
+        start = s.start
+        stop = s.stop
+        if start is None:
+            if step > 0:
+                start = 0
+            else:
+                if stop is not None:
+                    if stop >= 0:
+                        start = self.shape[axis] - 1
+                    else:
+                        start = - self.shape[axis]
+                else:
+                    start = self.shape[axis] - 1
+        # start is not None
+        if stop is None:
+            if step > 0:
+                if start >= 0:
+                    stop = self.shape[axis]
+                else:
+                    # start < 0
+                    start = self.shape[axis] + start
+                    stop = self.shape[axis]
+            else:
+                # step < 0
+                if start >= 0:
+                    stop = -1
+                else:
+                    stop = - self.shape[axis] - 1
+        if start < 0 and stop < 0 and step > 0:
             start = self.shape[axis] + start
-            stop = self.shape[axis] + stop
+            stop = self.shape[axis] + stop - 1
         return np.arange(start, stop, step)
 
     def _index_lambda(self, indices):
         #        from scipy.sparse import eye as seye
         from scipy.sparse import csr_matrix
         # TODO: csc_matrix might be more efficient than csr_matrix in certain
         # cases
@@ -392,20 +415,22 @@
                         _indices[i] = np.arange(s, s+1)
                     else:
                         _indices[i] = indices[i]
             n0, n1 = len(_indices[0]), len(_indices[1])
             return (
                 LazyLinOp._create_from_op(
                     # seye(self.shape[0], format='csr')[indices[0]])
-                    csr_matrix((np.ones(n0), (np.arange(n0), _indices[0])),
+                    csr_matrix((np.ones(n0, dtype=self.dtype),
+                                (np.arange(n0), _indices[0])),
                                shape=(n0, self.shape[0])))
                 @ self
                 @ LazyLinOp._create_from_op(
                     # seye(self.shape[1], format='csr')[:, _indices[1]])
-                    csr_matrix((np.ones(n1), (_indices[1], np.arange(n1))),
+                    csr_matrix((np.ones(n1, dtype=self.dtype),
+                                (_indices[1], np.arange(n1))),
                                shape=(self.shape[1], n1)))
             )
         return s
 
     @property
     def _shape(self):
         """
@@ -891,16 +916,16 @@
             return lambda: op._slice((slice(rslice.start - self.shape[0],
                                             rslice.stop - self.shape[0]),
                                       indices[1]))
         else:
             # the slice is overlapping self and op
             self_slice = self._slice((slice(rslice.start, self.shape[0]),
                                       indices[1]))
-            op_slice = self._slice((slice(0, rslice.stop - self.shape[0]),
-                                    indices[1]))
+            op_slice = op._slice((slice(0, rslice.stop - self.shape[0]),
+                                  indices[1]))
             return lambda: self_slice.vstack(op_slice)
 
     def _vstack_mul_lambda(self, op, o):
         from scipy.sparse import issparse
 
         def mul_mat(o):
             return np.vstack((self @ o, op @ o))
@@ -960,16 +985,16 @@
             return lambda: op._slice((indices[0],
                                       slice(cslice.start - self.shape[1],
                                             cslice.stop - self.shape[1])))
         else:
             # the slice is overlapping self and op
             self_slice = self._slice((indices[0], slice(cslice.start,
                                                         self.shape[1])))
-            op_slice = self._slice((indices[0], slice(0, cslice.stop -
-                                                      self.shape[1])))
+            op_slice = op._slice((indices[0], slice(0, cslice.stop -
+                                                    self.shape[1])))
             return lambda: self_slice.hstack(op_slice)
 
     def _hstack_mul_lambda(self, op, o):
         from scipy.sparse import issparse
 
         def mul_mat(o):
             s_ncols = self.shape[1]
```

## lazylinop/basicops/eye.py

```diff
@@ -4,27 +4,27 @@
 
 
 def eye(m, n=None, k=0, dtype='float'):
     """
     Returns the :class:`LazyLinOp` for eye (identity matrix and variants).
 
     Args:
-        m: (``int``)
+        m: ``int``
             Number of rows.
-        n: (``int``)
+        n: ``int``, optional
              Number of columns. Default is ``m``.
-        k: (``int``)
+        k: ``int``, optional
              Diagonal to place ones on.
 
-             - zero for main diagonal (default),
-             - negative integer for a diagonal below the main diagonal,
-             - strictly positive integer for a diagonal above.
+             - zero for the main diagonal (default),
+             - positive integer for an upper diagonal,
+             - negative integer for a lower diagonal.
 
-        dtype: (``str``)
-            Data type of the :class:`LazyLinOp`.
+        dtype: ``str`` or ``numpy.dtype``, optional
+            Data type of the :class:`LazyLinOp` (Defaultly ``'float'``).
 
     Example:
         >>> import lazylinop as lz
         >>> le1 = lz.eye(5)
         >>> le1
         <5x5 LazyLinOp with dtype=float64>
         >>> le1.toarray()
```

## lazylinop/basicops/pad.py

```diff
@@ -1,29 +1,46 @@
 import numpy as np
 from lazylinop import LazyLinOp, aslazylinop
 from lazylinop.basicops import hstack, vstack, eye, kron
 from warnings import warn
 
 
-def pad(op, pad_width, constant_values=0):
+def pad(op, pad_width, mode='constant', constant_values=0):
     """
     Returns a :py:class:`LazyLinOp` of the padded ``op``.
 
     Args:
         op: (``scipy LinearOperator``, ``LazyLinOperator``, ``numpy array``)
             The operator/array to pad.
 
         pad_width: (``tuple``, ``list``)
             Number of values padded to the edges of each axis.
 
             - ``((B0, A0), (B1, A1))`` (See Figure `Padding format`).
             - ``(B0, A0)`` is equivalent to ``((B0, A0), (0, 0))``.
 
+        mode: (``str``)
+            - ``'constant'``:
+                Pads with a constant value.
+            - ``'symmetric'``:
+                Pads with the reflection of the vector mirrored along the edge
+                of the array.
+            - ``'reflect'``:
+                Pads with the reflection of the vector mirrored on the first
+                and last values of the vector along each axis.
+            - ``'mean'``:
+                Pads with the mean value of all the vector along each axis.
+            - ``'edge'``:
+                Pads with the edge values of :class:`.LazyLinOp`.
+            - ``'wrap'``:
+                Pads with the wrap of the vector along the axis.
+                The first values are used to pad the end and the end values
+                are used to pad the beginning.
         constant_values: (``tuple``, ``list``, ``scalar``)
-            The values to set the padded values for each axis.
+            The padded values for each axis (in ``mode='constant'``).
 
             - ``((VB0, VA0)``, ``(VB1, VA1))``: padding values before (``VBi``)
               and values after (``VAi``) on each dimension.
               In Figure `Padding format` value ``VBi`` (resp. ``VAi``) goes
               where padding width ``Bi`` (resp.  ``Ai``) is.
             - ``((VB0, VA0))`` is equivalent to ``((VB0, VA0), (VB0, VA0))``.
             - ``(V,)`` or ``V`` is equivalent to ``((V, V), (V, V))``.
@@ -33,15 +50,15 @@
     .. _padding_format
     Padding format (for an operator ``op``)
     --------------
         .. image:: _static/pad_width.svg
             :width: 400px
             :height: 400px
 
-    Example:
+    Example ``mode='constant'``:
         >>> import lazylinop as lz
         >>> from numpy import arange
         >>> A = arange(18*2).reshape((18, 2))
         >>> A
         array([[ 0,  1],
                [ 2,  3],
                [ 4,  5],
@@ -150,14 +167,145 @@
         zero-padded DFT example:
             >>> import lazylinop as lz
             >>> from lazylinop.wip.signal import fft
             >>> e = lz.eye(5)
             >>> pe = lz.pad(e, (0, 3))
             >>> pfft = fft(8) @ pe
 
+        Example ``mode='symmetric'``, ``mode='reflect'``:
+            >>> import lazylinop as lz
+            >>> a = np.arange(25).reshape(5, 5)
+            >>> sp_a = lz.pad(a, (2, 1), mode='symmetric')
+            >>> print(sp_a)
+            <8x5 LazyLinOp with dtype=int64>
+            >>> sp_a.toarray()
+            array([[ 5,  6,  7,  8,  9],
+                   [ 0,  1,  2,  3,  4],
+                   [ 0,  1,  2,  3,  4],
+                   [ 5,  6,  7,  8,  9],
+                   [10, 11, 12, 13, 14],
+                   [15, 16, 17, 18, 19],
+                   [20, 21, 22, 23, 24],
+                   [20, 21, 22, 23, 24]])
+            >>> sp_a2 = lz.pad(a, ((1, 1), (2, 1)), mode='symmetric')
+            >>> print(sp_a2)
+            <7x8 LazyLinOp with dtype=int64>
+            >>> sp_a2.toarray()
+            array([[ 1,  0,  0,  1,  2,  3,  4,  4],
+                   [ 1,  0,  0,  1,  2,  3,  4,  4],
+                   [ 6,  5,  5,  6,  7,  8,  9,  9],
+                   [11, 10, 10, 11, 12, 13, 14, 14],
+                   [16, 15, 15, 16, 17, 18, 19, 19],
+                   [21, 20, 20, 21, 22, 23, 24, 24],
+                   [21, 20, 20, 21, 22, 23, 24, 24]])
+            >>> rp_a = lz.pad(a, (2, 1), mode='reflect')
+            >>> print(rp_a)
+            <8x5 LazyLinOp with dtype=int64>
+            >>> rp_a.toarray()
+            array([[10, 11, 12, 13, 14],
+                   [ 5,  6,  7,  8,  9],
+                   [ 0,  1,  2,  3,  4],
+                   [ 5,  6,  7,  8,  9],
+                   [10, 11, 12, 13, 14],
+                   [15, 16, 17, 18, 19],
+                   [20, 21, 22, 23, 24],
+                   [15, 16, 17, 18, 19]])
+            >>> rp_a2 = lz.pad(a, ((1, 1), (2, 1)), mode='reflect')
+            >>> print(rp_a2)
+            <7x8 LazyLinOp with dtype=int64>
+            >>> rp_a2.toarray()
+            array([[ 7,  6,  5,  6,  7,  8,  9,  8],
+                   [ 2,  1,  0,  1,  2,  3,  4,  3],
+                   [ 7,  6,  5,  6,  7,  8,  9,  8],
+                   [12, 11, 10, 11, 12, 13, 14, 13],
+                   [17, 16, 15, 16, 17, 18, 19, 18],
+                   [22, 21, 20, 21, 22, 23, 24, 23],
+                   [17, 16, 15, 16, 17, 18, 19, 18]])
+
+
+        Example ``mode='mean'``:
+            >>> import lazylinop as lz
+            >>> a = np.arange(25).reshape(5, 5)
+            >>> mp_a = lz.pad(a, (2, 1), mode='mean')
+            >>> print(mp_a)
+            <8x5 LazyLinOp with dtype=float64>
+            >>> mp_a.toarray()
+            array([[10., 11., 12., 13., 14.],
+                   [10., 11., 12., 13., 14.],
+                   [ 0.,  1.,  2.,  3.,  4.],
+                   [ 5.,  6.,  7.,  8.,  9.],
+                   [10., 11., 12., 13., 14.],
+                   [15., 16., 17., 18., 19.],
+                   [20., 21., 22., 23., 24.],
+                   [10., 11., 12., 13., 14.]])
+            >>> mp_a2 = lz.pad(a, ((1, 1), (2, 1)), mode='mean')
+            >>> print(mp_a2)
+            <7x8 LazyLinOp with dtype=float64>
+            >>> mp_a2.toarray()
+            array([[12., 12., 10., 11., 12., 13., 14., 12.],
+                   [ 2.,  2.,  0.,  1.,  2.,  3.,  4.,  2.],
+                   [ 7.,  7.,  5.,  6.,  7.,  8.,  9.,  7.],
+                   [12., 12., 10., 11., 12., 13., 14., 12.],
+                   [17., 17., 15., 16., 17., 18., 19., 17.],
+                   [22., 22., 20., 21., 22., 23., 24., 22.],
+                   [12., 12., 10., 11., 12., 13., 14., 12.]])
+
+        Example ``mode='edge'``:
+            >>> import lazylinop as lz
+            >>> a = np.arange(25).reshape(5, 5)
+            >>> ep_a = lz.pad(a, (2, 1), mode='edge')
+            >>> print(ep_a)
+            <8x5 LazyLinOp with dtype=int64>
+            >>> ep_a.toarray()
+            array([[ 0,  1,  2,  3,  4],
+                   [ 0,  1,  2,  3,  4],
+                   [ 0,  1,  2,  3,  4],
+                   [ 5,  6,  7,  8,  9],
+                   [10, 11, 12, 13, 14],
+                   [15, 16, 17, 18, 19],
+                   [20, 21, 22, 23, 24],
+                   [20, 21, 22, 23, 24]])
+            >>> ep_a2 = lz.pad(a, ((1, 1), (2, 1)), mode='edge')
+            >>> print(ep_a2)
+            <7x8 LazyLinOp with dtype=int64>
+            >>> ep_a2.toarray()
+            array([[ 0,  0,  0,  1,  2,  3,  4,  4],
+                   [ 0,  0,  0,  1,  2,  3,  4,  4],
+                   [ 5,  5,  5,  6,  7,  8,  9,  9],
+                   [10, 10, 10, 11, 12, 13, 14, 14],
+                   [15, 15, 15, 16, 17, 18, 19, 19],
+                   [20, 20, 20, 21, 22, 23, 24, 24],
+                   [20, 20, 20, 21, 22, 23, 24, 24]])
+
+        Example ``mode='wrap'``:
+            >>> import lazylinop as lz
+            >>> a = np.arange(25).reshape(5, 5)
+            >>> wp_a = lz.pad(a, (2, 1), mode='wrap')
+            >>> print(wp_a)
+            <8x5 LazyLinOp with dtype=int64>
+            >>> wp_a.toarray()
+            array([[15, 16, 17, 18, 19],
+                   [20, 21, 22, 23, 24],
+                   [ 0,  1,  2,  3,  4],
+                   [ 5,  6,  7,  8,  9],
+                   [10, 11, 12, 13, 14],
+                   [15, 16, 17, 18, 19],
+                   [20, 21, 22, 23, 24],
+                   [ 0,  1,  2,  3,  4]])
+            >>> wp_a2 = lz.pad(a, ((1, 1), (2, 1)), mode='wrap')
+            >>> print(wp_a2)
+            <7x8 LazyLinOp with dtype=int64>
+            >>> wp_a2.toarray()
+            array([[23, 24, 20, 21, 22, 23, 24, 20],
+                   [ 3,  4,  0,  1,  2,  3,  4,  0],
+                   [ 8,  9,  5,  6,  7,  8,  9,  5],
+                   [13, 14, 10, 11, 12, 13, 14, 10],
+                   [18, 19, 15, 16, 17, 18, 19, 15],
+                   [23, 24, 20, 21, 22, 23, 24, 20],
+                   [ 3,  4,  0,  1,  2,  3,  4,  0]])
 
         .. seealso::
             `numpy.pad <https://numpy.org/doc/stable/reference/generated/
             numpy.pad.html>`_,
             :func:`.aslazylinop`
         """
     if (len(pad_width) == 2 and
@@ -173,19 +321,27 @@
             pad_width = (pad_width, (0, 0))
         else:
             raise ValueError("op must be 1d or 2d dimensional only")
         op = aslazylinop(op)
     else:
         raise ValueError('pad_width is not valid; (before, after) or'
                          ' ((before1, after1), (before2, after2))')
+    constant_values = _sanitize_contant_values(constant_values)
+    pad_width = np.array(pad_width).astype('int')
+    if mode in ['mean', 'reflect', 'symmetric', 'wrap', 'edge']:
+        cp = _cat_pad(op, pad_width, mode, constant_values)
+        return LazyLinOp(op_shape,
+                         matmat=lambda M:
+                         cp @ M,
+                         rmatmat=lambda M: op @ M, dtype=cp.dtype)
     return LazyLinOp(op_shape,
                      matmat=lambda M: (ppadder(
                          op.shape,
                          pad_width,
-                         mode='constant',
+                         mode=mode,
                          constant_values=constant_values) @ op) @ M,
                      rmatmat=lambda M: op @ M, dtype=op.dtype)
 
 
 def padder(X_shape, pad_width):
     """
     Returns a :py:class:`LazyLinOp` for row dimension zero padding of any X.
@@ -460,16 +616,17 @@
         if op.ndim == 1:
             if pad_width_ndim_was_1:
                 return np.pad(op, pad_width[0], mode=mode,
                               constant_values=constant_values[0])
             else:
                 op = op.reshape(x_shape)
                 op_reshaped = True
-        elif x_shape == op.shape and isinstance(op, np.ndarray):
-            if (mode == 'constant' and constant_values == ((0, 0), (0, 0)) and
+        elif (mode == 'constant' and x_shape == op.shape and
+              isinstance(op, np.ndarray)):
+            if (constant_values == ((0, 0), (0, 0)) and
                     all(pad_width[0] == (0, 0))):
                 # particular case opt. (zero padding of columns)
                 out = np.zeros((x_shape[0], x_shape[1] + np.sum(pad_width[1])))
                 out[:, pad_width[1][0]:pad_width[1][0]+op.shape[1]] = op
                 return out
             else:
                 return np.pad(op, pad_width, mode=mode,
@@ -478,38 +635,15 @@
             out = aslazylinop(np.empty((lop_shape[0], 0)))
             for j in range(op.shape[1]):
                 out_v = mul(op[:, j])
                 if out_v.ndim == 1:
                     out_v = out_v.reshape((out_v.size, 1))
                 out = hstack((out, out_v))
             return out.toarray()
-        out = aslazylinop(op)
-        for i in range(pad_width.shape[0]):
-            bw = pad_width[i][0]
-            aw = pad_width[i][1]
-            bv = constant_values[i][0]
-            av = constant_values[i][0]
-            if bw > 0:
-                if i == 0:
-                    out = vstack((_pad_block((bw, out.shape[1]), bv,
-                                             mode=mode, op=op,
-                                             dtype=op.dtype), out))
-                else:  # i == 1:
-                    out = hstack((_pad_block((out.shape[0], bw), bv,
-                                             mode=mode, op=op,
-                                             dtype=op.dtype), out))
-            if aw > 0:
-                if i == 0:
-                    out = vstack((out, _pad_block((aw, out.shape[1]), av,
-                                                  mode=mode, op=op,
-                                                  dtype=op.dtype)))
-                else:  # i == 1:
-                    out = hstack((out, _pad_block((out.shape[0], aw), av,
-                                                  mode=mode, op=op,
-                                                  dtype=op.dtype)))
+        out = _cat_pad(op, pad_width, mode, constant_values)
         if op_reshaped:
             return out.toarray().ravel()
         else:
             return out.toarray()
 
     def rmul(op):
         # op can only be a np.ndarray or a scipy matrix (see LazyLinOp)
@@ -537,14 +671,47 @@
     ret = LazyLinOp(lop_shape, matmat=lambda op: mul(op), rmatmat=lambda
                     op: rmul(op))
     ret.ravel_op = True  # a 2d array can be flatten to be compatible
     # to zpad.shape[1]
     return ret
 
 
+def _cat_pad(op, pad_width, mode, constant_values):
+    out = aslazylinop(op)
+    for i in range(pad_width.shape[0]):
+        bw = pad_width[i][0]
+        aw = pad_width[i][1]
+        bv = constant_values[i][0]
+        av = constant_values[i][0]
+        if bw > 0:
+            if i == 0:
+                out = vstack((_pad_block((bw, out.shape[1]), bv,
+                                         mode=mode, op=op,
+                                         dtype=op.dtype, axis=i,
+                                         side='before'), out))
+            else:  # i == 1:
+                out = hstack((_pad_block((out.shape[0], bw), bv,
+                                         mode=mode, op=op,
+                                         dtype=op.dtype, axis=i,
+                                         side='before'), out))
+        if aw > 0:
+            if i == 0:
+                out = vstack((out, _pad_block((aw, out.shape[1]), av,
+                                              mode=mode, op=op,
+                                              dtype=op.dtype, axis=i,
+                                              side='after')))
+            else:  # i == 1:
+                out = hstack((out, _pad_block((out.shape[0], aw), av,
+                                              mode=mode, op=op,
+                                              dtype=op.dtype, axis=i,
+                                              side='after')))
+        op = out
+    return out
+
+
 def zpad(x_shape, pad_width):
     """
     Deprecated alias for :py:func:`pad` with zero as constant value to pad.
     This function might be removed in a next version.
     """
     warn("Don't use [DEPRECATED] zpad, use pad with default constant_values"
          " (zeros)")
@@ -583,21 +750,122 @@
 
 
 sanitize_const_values = _sanitize_contant_values
 
 # TODO: _sanitize_pad_width
 
 
-def _pad_block(shape, v=0, op=None, mode='constant', dtype=None):
+def _pad_block(shape, v=0, op=None, mode='constant', dtype=None, axis=0,
+               side='before'):
     from lazylinop.basicops import zeros, ones
+    assert side in ['before', 'after']
     if mode == 'constant':
         if v == 0:
             return zeros(shape, dtype=dtype)
         else:
             return ones(shape, dtype=dtype) * v
+    elif mode in ['symmetric', 'reflect']:
+        return _pad_reflect_symmetric(op, shape, axis, side, mode)
+    elif mode == 'mean':
+        return _pad_block_mean(op, shape, axis, side)
+    elif mode == 'edge':
+        return _pad_block_edge(op, shape, axis, side)
+    elif mode == 'wrap':
+        return _pad_block_wrap(op, shape, axis, side)
+
+
+def _pad_reflect_symmetric(op, shape, axis, side, mode):
+    ids = {
+        'symmetric':
+        {
+            0:  # axis
+                {
+                    'before': slice(0, shape[0]),
+                    'after': slice(op.shape[0] - shape[0], op.shape[0])
+                },
+            1:  # axis
+                {
+                    'before': slice(0, shape[1]),
+                    'after': slice(op.shape[1] - shape[1], op.shape[1])
+                }
+        },
+        'reflect':
+        {
+            0:  # axis
+                {
+                    'before': slice(1, shape[0] + 1),
+                    'after': slice(op.shape[0] - shape[0] - 1,
+                                   op.shape[0]-1)
+                },
+            1:  # axis
+                {
+                    'before': slice(1, shape[1] + 1),
+                    'after': slice(op.shape[1] - shape[1] - 1,
+                                   op.shape[1] - 1)
+                }
+        }
+    }
+    if axis == 0:
+        return op[ids[mode][axis][side]][::-1]
+    elif axis == 1:
+        return op[:, ids[mode][axis][side]][:, ::-1]
+
+
+def _pad_block_mean(op, shape, axis, side):
+    from lazylinop.wip.basicops import mean
+    m = mean(op, axis)
+    if axis == 0:
+        sf = vstack
+    else:
+        assert axis == 1
+        sf = hstack
+    m_stack = sf([m for _ in range(shape[axis])])
+    return m_stack
+
+
+def _pad_block_edge(op, shape, axis, side):
+    if axis == 0:
+        sf = vstack
+        if side == 'before':
+            e = op[0:1, :]
+        else:
+            assert side == 'after'
+            e = op[-1:, :]
+    else:
+        assert axis == 1
+        sf = hstack
+        if side == 'before':
+            e = op[:, 0:1]
+        else:
+            assert side == 'after'
+            e = op[:, -1:]
+    e_stack = sf([e for _ in range(shape[axis])])
+    return e_stack
+
+
+def _pad_block_wrap(op, shape, axis, side):
+    n = shape[axis]  # num of rows/cols yet to pad
+    w = None  # wrap padded block
+    while n > 0:
+        pn = min(n, op.shape[axis])  # num of padded rows/cols for ite
+        if axis == 0:
+            if side == 'before':
+                w = op[-pn:] if w is None else vstack((op[-pn:], w))
+            else:
+                assert side == 'after'
+                w = op[:pn] if w is None else vstack((w, op[:pn]))
+        else:
+            assert axis == 1
+            if side == 'before':
+                w = op[:, -pn:] if w is None else hstack((op[:, -pn:], w))
+            else:
+                assert side == 'after'
+                w = op[:, :pn] if w is None else hstack((w, op[:, :pn]))
+        n -= pn
+    return w
 
 
 def kron_pad(shape: tuple, pad_width: tuple):
     """Constructs a lazy linear operator Op for padding.
 
     If shape is a tuple (X, Y), Op is applied to a 1d array of shape (X * Y, ).
     The output of the padding of the 2d input array is given by
@@ -722,21 +990,20 @@
         LazyLinOp
 
     Raises:
         ValueError
             Invalid block size and/or number of blocks.
 
     Examples:
-        >>> from lazylinop.wip.signal import mpad
+        >>> import lazylinop as lz
         >>> import numpy as np
-        >>> signal = np.full(5, 1.0)
-        >>> signal
+        >>> x = np.full(5, 1.0)
+        >>> x
         array([1., 1., 1., 1., 1.])
-        >>> y = mpad(1, 5, 1) @ signal
-        >>> y
+        >>> lz.mpad(1, 5, 1) @ x
         array([1., 0., 1., 0., 1., 0., 1., 0., 1., 0.])
     """
     from lazylinop import eye
     if n <= 0:
         # reproducing mpad behaviour
         # (but is that really necessary? why a negative padding size?)
         return eye(X * L, n=X * L, k=0)
@@ -776,74 +1043,94 @@
         #        matvec=lambda x: (P @ x.reshape((X, L))).ravel(),
         #        rmatvec=lambda x: (P.H @ x.ravel())
         matmat=matmat,
         rmatmat=rmatmat
     )
 
 
-def mpad(L: int, X: int, n: int = 1):
+def mpad(L: int, X: int, n: int = 1, add: tuple = ('after')):
     """Returns a :py:class:`LazyLinOp` to zero-pad each signal block.
 
     If you apply this operator to a vector of length L * X the output will have
     a length (L + n) * X.
 
     Args:
         L: int
             Block size
         X: int
             Number of blocks.
         n: int, optional
             Add n zeros to each block.
+        add: str or tuple, optional
+            If add is ('before') add n zeros at the begining.
+            If add is ('after') add n zeros at the end.
+            If add is ('before', 'after') add n zeros at
+            the begining and at the end.
+            Default is ('after').
 
     Returns:
         LazyLinOp
 
     Raises:
         ValueError
             Invalid block size and/or number of blocks.
 
     Examples:
-        >>> from lazylinop.wip.signal import mpad
+        >>> import lazylinop as lz
         >>> import numpy as np
-        >>> signal = np.full(5, 1.0)
-        >>> signal
-        array([1., 1., 1., 1., 1.])
-        >>> y = mpad(1, 5, 1) @ signal
-        >>> y
-        array([1., 0., 1., 0., 1., 0., 1., 0., 1., 0.])
+        >>> x = np.full(3, 1.0)
+        >>> x
+        array([1., 1., 1.])
+        >>> lz.mpad(1, 3, 1) @ x
+        array([1., 0., 1., 0., 1., 0.])
+        >>> lz.mpad(1, 3, 1, add=('before')) @ x
+        array([0., 1., 0., 1., 0., 1.])
+        >>> lz.mpad(1, 3, 1, add=('after')) @ x
+        array([1., 0., 1., 0., 1., 0.])
+        >>> lz.mpad(1, 3, 1, add=('before', 'after')) @ x
+        array([0., 1., 0., 1., 0., 1., 0.])
     """
     from warnings import warn
     warn("This function is deprecated and should not be used anymore, use"
          " mpad2 -- see issue #57. It will be deleted in a next version.")
     if n <= 0:
         return eye(X * L, n=X * L, k=0)
 
+    offset0 = int('before' in add) * n
+    offset1 = 1 - int('after' in add)
+
     def _matmat(x):
         # x shape compatibility (number of rows) is tested beforehand by
         # LazyLinOp class
-        if x.ndim == 1:
+        if len(x.shape) == 1:
             is_1d = True
             x = x.reshape(x.shape[0], 1)
         else:
             is_1d = False
         # add n zeros to each block
-        y = np.zeros((X * (L + n), x.shape[1]), dtype=x.dtype)
+        y = np.zeros((offset0 + X * L + (X - offset1) * n, x.shape[1]),
+                     dtype=x.dtype)
         for i in range(X):
-            y[(i * (L + n)):(i * (L + n) + L), :] = x[(i * L):((i + 1) * L), :]
+            y[(offset0 + i * (L + n)):(offset0 + i * (L + n) + L), :] = (
+                x[(i * L):((i + 1) * L), :]
+            )
         return y.ravel() if is_1d else y
 
     def _rmatmat(x):
-        if x.ndim == 1:
+        if len(x.shape) == 1:
             is_1d = True
             x = x.reshape(x.shape[0], 1)
         else:
             is_1d = False
         # keep L elements every n + 1 elements
         y = np.zeros((X * L, x.shape[1]), dtype=x.dtype)
         for i in range(X):
-            y[(i * L):((i + 1) * L), :] = x[(i * (L + n)):(i * (L + n) + L), :]
+            y[(i * L):((i + 1) * L), :] = (
+                x[(offset0 + i * (L + n)):(offset0 + i * (L + n) + L), :]
+            )
         return y.ravel() if is_1d else y
+
     return LazyLinOp(
-        shape=(X * (L + n), X * L),
+        shape=(offset0 + X * L + (X - offset1) * n, X * L),
         matmat=lambda x: _matmat(x),
         rmatmat=lambda x: _rmatmat(x)
     )
```

## lazylinop/wip/__init__.py

```diff
@@ -1 +1,2 @@
 from .parallel.mpilop import MPILop # temporary alias (will be deleted later)
+from .signal import *
```

## lazylinop/wip/basicops/__init__.py

```diff
@@ -1,2 +1,3 @@
 from .average import average
 from .mean import mean
+from .anti_diag import anti_diag
```

## lazylinop/wip/basicops/average.py

```diff
@@ -1,37 +1,104 @@
 from lazylinop import LazyLinOp, aslazylinop
 import numpy as np
 
 
 def average(op, axis=0, weights=None):
-    """
-    TODO
+    """Computes the weighted average :class:`.LazyLinOp` of ``op`` along
+    the specified axis.
+
+
+    Args:
+        op: :py:class:`.LazyLinOp` or compatible linear operator
+           The operator whose average is computed.
+        axis: ``int``, optional
+            Axis along which the average is computed (``0`` or ``1``).
+        weights: ``None`` or ``numpy.ndarray`` (vector of scalars), optional
+            - ``weights[i]`` is the weight of the row ``i`` (resp. column
+              ``i``) if ``axis=0`` (resp. if ``axis=1``).
+            - If ``None`` (default) all columns/rows have the same weight.
+
+
+    Returns:
+        :py:class:`.LazyLinOp` for mean of ``op``.
+
+    Examples:
+        >>> import lazylinop as lz
+        >>> import lazylinop.wip.basicops as lzb
+        >>> lzo1 = lz.ones((2, 3), dtype='float') * 2
+        >>> lzo2 = lz.ones((2, 3), dtype='float') * 3
+        >>> lzo = lz.vstack((lzo1, lzo2))
+        >>> w0 = [1, .5, 1.5, 2]
+        >>> a1 = lzb.average(lzo, axis=0, weights=w0)
+        >>> print(a1)
+        <1x3 LazyLinOp with dtype=float64>
+        >>> print(a1.toarray())
+        [[2.7 2.7 2.7]]
+        >>> np_a1 = np.average(lzo.toarray(), axis=0, weights=w0)
+        >>> print(np.allclose(a1.toarray(), np_a1))
+        True
+        >>> w1 = [1, 2.2, 3]
+        >>> a2 = lzb.average(lzo, axis=1, weights=w1)
+        >>> print(a2.toarray())
+        [[2.]
+         [2.]
+         [3.]
+         [3.]]
+        >>> np_a2 = np.average(lzo.toarray(), axis=1, weights=w1)
+        >>> print(np.allclose(a2.toarray().ravel(), np_a2))
+        True
+
+
+    .. seealso::
+        `numpy.average
+        <https://numpy.org/doc/stable/reference/generated/numpy.average.html>`_,
+        :py:func:`.mean`,
+        :py:func:`.aslazylinop`.
     """
 #    from lazylinop.wip.basicops import mean
     lz_op = aslazylinop(op)
 #    if weights is None:
 #        return mean(lz_op, axis=axis, meth='ones')
-    # TODO: ensure weights is a vector of proper shape
+    if isinstance(weights, list):
+        weights = np.array(weights)
+
+    # ensure weights is a vector of proper shape
+    if axis == 0 and weights is not None and len(weights) != lz_op.shape[0]:
+        raise ValueError('axis == 0 but len(weights) != op.shape[0]')
+    elif axis == 1 and weights is not None and len(weights) != lz_op.shape[1]:
+        raise ValueError('axis == 1 but len(weights) != op.shape[1]')
 
     def _matmat(lz_op, x, adj=False):
         nonlocal weights
+        nonlocal axis
+
+        if adj:
+            s = (1, lz_op.shape[0]) if axis == 1 else (lz_op.shape[1], 1)
+        else:
+            s = (lz_op.shape[1], 1) if axis == 1 else (1, lz_op.shape[0])
 
-        s = (lz_op.shape[1], 1) if axis == 1 else (1, lz_op.shape[0])
         if weights is None:
             weights = np.ones(s)
         else:
             weights = weights.reshape(s)
 
+        if adj:
+            axis = (axis + 1) % 2
+
         sum_w = np.sum(weights)
+
+        if sum_w == 0:
+            raise ZeroDivisionError("Weights sum to zero,"
+                                    " can't be normalized")
         m, n = lz_op.shape
         if axis == 0:
             # whatever is lz_op
             # we can compare the costs
             # of going l2r or r2l
-            p = x.shape[1] if x.ndim == 2 else x.shape[0]
+            p = x.shape[1] if x.ndim == 2 else 1
             l2r_c = n * (m + p)
             r2l_c = m * p * (n + 1)
             if l2r_c < r2l_c:
                 return 1 / sum_w * ((weights @ lz_op) @ x)
             else:  # r2l
                 return 1 / sum_w * (weights @ (lz_op @ x))
         elif axis == 1:
@@ -44,8 +111,9 @@
     if axis == 1:
         out_shape = (lz_op.shape[0], 1)
     elif axis == 0:
         out_shape = (1, lz_op.shape[1])
     else:
         raise ValueError("axis must be 0 or 1")
     return LazyLinOp(out_shape, matmat=lambda x: _matmat(lz_op, x),
-                     rmatmat=lambda x: _matmat(lz_op.H, x, adj=True))
+                     rmatmat=lambda x: _matmat(lz_op.H, x, adj=True),
+                     dtype=lz_op.dtype)
```

## lazylinop/wip/basicops/mean.py

```diff
@@ -1,22 +1,67 @@
 from lazylinop import ones, aslazylinop
+import numpy as np
 
 
 def mean(op, axis=0, meth='ones'):
-    """
-    TODO
+    """Computes the arithmetic mean :py:class:`.LazyLinOp` of ``op``
+    along the specified axis.
+
+    Args:
+        op: :py:class:`.LazyLinOp` or compatible linear operator
+           The operator whose mean is computed.
+        axis: ``int``, optional
+            Axis along which the mean is computed (``0`` or ``1``).
+        meth: ``str``
+            The method used to compute the mean.
+
+            - ``'ones'``: ``op`` is multiplied by appropriate :py:func:`.ones`.
+            - ``'avg'``: :py:func:`.average` is called with same weights for
+              every columns/rows.
+
+    Returns:
+        :py:class:`.LazyLinOp` for mean of ``op``.
+
+        .. note::
+            The returned :class:`.LazyLinOp` cannot be of integer dtype because
+            the mean is never made with integer division (``//`` is not
+            supported by :class:`.LazyLinOp` class).
+
+    Example:
+        >>> import lazylinop
+        >>> import lazylinop.wip.basicops as lz
+        >>> lzo = lazylinop.ones((2, 3))
+        >>> lzo_m = lz.mean(lzo, axis=0)
+        >>> print(lzo_m)
+        <1x3 LazyLinOp with dtype=float64>
+        >>> print(lzo_m.toarray())
+        [[1. 1. 1.]]
+        >>> lzo2 = lzo * 2
+        >>> lzo_m2 = lz.mean(lzo2, axis=1)
+        >>> print(lzo_m2.toarray())
+        [[2.]
+         [2.]]
+
+    .. seealso::
+        `numpy.mean
+        <https://numpy.org/doc/stable/reference/generated/numpy.mean.html>`_,
+        :py:func:`.average`,
+        :py:func:`.aslazylinop`.
     """
     from lazylinop.wip.basicops import average
     lz_op = aslazylinop(op)
+    if 'int' in str(lz_op.dtype):
+        # cf. note in doc above
+        lz_op.dtype = np.dtype('float64')
     m, n = lz_op.shape
     ve_axis = ValueError("axis must be 0 or 1")
     if meth == 'ones':
         if axis == 0:
-            return 1 / m * (ones((1, m)) @ lz_op)
+            return 1 / m * (ones((1, m), dtype=lz_op.dtype) @ lz_op)
         elif axis == 1:
-            return 1 / n * (lz_op @ ones((n, 1)))
+            return 1 / n * (lz_op @ ones((n, 1), dtype=lz_op.dtype))
         else:
             raise ve_axis
     elif meth == 'avg':
         return average(lz_op, axis=axis)
     else:
         raise ValueError('Unknown meth')
```

## lazylinop/wip/signal/slices.py

```diff
@@ -6,16 +6,16 @@
 
 
 def slices(N: int, start: np.ndarray,
            end: np.ndarray, window: int = None,
            nhop: int = None, offset: tuple = (0, None)):
     """Constructs a multiple slices lazy linear operator.
 
-    - If window and hop are :code:`None` extract slices given by
-      the intervals [start[i], end[i]] for all i < len(start).
+    - If window and hop are :code:`None` (default) extract slices
+      given by the intervals [start[i], end[i]] for all i < len(start).
       Element start[i] must be lesser than element end[i].
       Element end[i] must be greater or equal than element start[i - 1].
       If start[i] = end[i], extract only one element.
 
     - If window and nhop are not :code:`None` extract slices given by
       window and nhop arguments.
       For a given signal, window size (window) and number of
@@ -63,65 +63,65 @@
         ValueError
             window argument expects a value > 0 and <= signal length.
         ValueError
             nhop argument expects a value > 0.
         ValueError
             offset[0] is < 0.
         ValueError
-            offset[0] is >= number of elements along axis.
+            offset[0] >= number of elements.
         ValueError
-            offset[1] is > number of elements along axis.
+            offset[1] > number of elements.
         Exception
             offset[1] is <= offset[0].
 
     Examples:
         >>> import numpy as np
-        >>> from lazylinop.wip.signal import slices
+        >>> import lazylinop as lz
         >>> # use list to extract multiple slices
         >>> x = np.arange(10)
         >>> x
         array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
-        >>> slices(x.shape, [0, 5], [2, 8]) @ x
+        >>> lz.wip.signal.slices(x.shape[0], [0, 5], [2, 8]) @ x
         array([0, 1, 2, 5, 6, 7, 8])
         >>> # use window = 1 and nhop
         >>> x = np.arange(10)
         >>> x
         array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
-        >>> slices(x.shape[0], [], [], 1, 2, (0, 10)) @ x
+        >>> lz.wip.signal.slices(x.shape[0], [], [], 1, 2, (0, 10)) @ x
         array([0, 2, 4, 6, 8])
         >>> X = np.arange(30).reshape((10, 3))
         >>> X
         array([[ 0,  1,  2],
                [ 3,  4,  5],
                [ 6,  7,  8],
                [ 9, 10, 11],
                [12, 13, 14],
                [15, 16, 17],
                [18, 19, 20],
                [21, 22, 23],
                [24, 25, 26],
                [27, 28, 29]])
-        >>> slices(x.shape[0], [], [], 1, 2, (0, 10)) @ X
+        >>> lz.wip.signal.slices(x.shape[0], [], [], 1, 2, (0, 10)) @ X
         array([[ 0,  1,  2],
                [ 6,  7,  8],
                [12, 13, 14],
                [18, 19, 20],
                [24, 25, 26]])
         >>> # use window > 1 and nhop
         >>> x = np.array([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.])
-        >>> slices(x.shape[0], [], [], 5, 2) @ x
+        >>> lz.wip.signal.slices(x.shape[0], [], [], 5, 2) @ x
         array([0., 1., 2., 3., 4., 2., 3., 4., 5., 6., 4., 5., 6., 7., 8.])
         >>> X = x.reshape(5, 2)
         >>> X
         array([[0., 1.],
                [2., 3.],
                [4., 5.],
                [6., 7.],
                [8., 9.]])
-        >>> slices(X.shape[0], [], [], 3, 2) @ X
+        >>> lz.wip.signal.slices(X.shape[0], [], [], 3, 2) @ X
         array([[0., 1.],
                [2., 3.],
                [4., 5.],
                [4., 5.],
                [6., 7.],
                [8., 9.]])
     """
@@ -134,18 +134,18 @@
             raise ValueError("nhop argument expects a value > 0.")
 
         if window == 1:
             # Decimation every nhop elements
             if offset[0] < 0:
                 raise ValueError("offset[0] is < 0.")
             if offset[0] >= N:
-                raise ValueError("offset[0] is >= number of elements along axis.")
+                raise ValueError("offset[0] >= number of elements.")
             if offset[1] is not None:
                 if offset[1] > N:
-                    raise ValueError("offset[1] is > number of elements along axis.")
+                    raise ValueError("offset[1] > number of elements.")
                 if offset[1] <= offset[0]:
                     raise Exception("offset[1] is <= offset[0].")
 
             def _matmat(x, a, b, every):
                 L = int(np.ceil((b - a) / every))
                 if x.ndim == 1:
                     return x[a + np.arange(L) * every]
```

## Comparing `lazylinop-1.8.0.dist-info/LICENSE.txt` & `lazylinop-1.9.0a0.dist-info/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `lazylinop-1.8.0.dist-info/METADATA` & `lazylinop-1.9.0a0.dist-info/METADATA`

 * *Files 3% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: lazylinop
-Version: 1.8.0
+Version: 1.9.0a0
 Summary: A package dedicated to lazy linear operators based on diverse backends/libraries.
 Author-email: Inria <remi.gribonval@inria.fr>, Pascal Carrivain <pascal.carrivain@inria.fr>, Simon Delamare <simon.delamare@ens-lyon.fr>, Hakim Hadj-Djilani <hakim.hadj-djilani@inria.fr>, Rémi Gribonval <remi.gribonval@inria.fr>
 License: Copyright 2023, Inria
         
         BSD License 2.0
         
         Redistribution and use in source and binary forms, with or without
@@ -19,17 +19,16 @@
 Project-URL: Homepage, https://faustgrp.gitlabpages.inria.fr/lazylinop/
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: OSI Approved :: BSD License
 Classifier: Operating System :: OS Independent
 Requires-Python: >=3.8
 Description-Content-Type: text/x-rst
 License-File: LICENSE.txt
-Requires-Dist: pyfaust
-Requires-Dist: scipy
-Requires-Dist: numpy >=1.23
+Requires-Dist: scipy >=1.13
+Requires-Dist: numpy >=1.25
 
 .. Lazylinop documentation master file, created by
    sphinx-quickstart on Sun Apr  2 17:21:28 2023.
    You can adapt this file completely to your liking, but it should at least
    contain the root `toctree` directive.
 
 .. note Please be warned that this introduction file is shared between the
@@ -121,14 +120,23 @@
 **Quick install using PIP**
 ::
 
         pip install lazylinop
 
 Python beginners willing to safely install Lazylinop with a virtual environment can consult this guide_.
 
+**Installing all extra/optional dependencies**
+::
+
+        pip install -r lz_requirements.txt
+
+Download the dependency file `lz_requirements.txt <https://faustgrp.gitlabpages.inria.fr/lazylinop/_static/lz_requirements.txt>`_
+
+.. we use online link because this page is shared pypi frontpage (see note in the file header)
+
 **Quick introduction**
 
 For a quick introduction to the use of Lazylinop go to this notebook_. The raw notebook is
 available here_.
 
 .. full links (not relative) because this file is used also in pypi full
    description
```

## Comparing `lazylinop-1.8.0.dist-info/RECORD` & `lazylinop-1.9.0a0.dist-info/RECORD`

 * *Files 21% similar despite different names*

```diff
@@ -1,30 +1,30 @@
-lazylinop/__init__.py,sha256=ClaZUz2Uu4FPDlj62KGZnhzvwkrD-1LvJxevFQmucso,152
+lazylinop/__init__.py,sha256=GhBzCu1T3HKXvjVOrNCAKz0vATBLZm9WF19BYay7MlQ,178
 lazylinop/check_op.py,sha256=F9Fruv6a-_izX9E-RqgY369FsSUPJBzNexfa1eCc310,8275
-lazylinop/lazylinop.py,sha256=eSU6DDPTItVR8WyqrVt3OKgyB2qk-JzMKXQ69VEJQH4,52187
+lazylinop/lazylinop.py,sha256=m0Cqn98_RXoo7Qpxa5RirtZ1kwU64GCcBsc4W0HnQec,52918
 lazylinop/basicops/__init__.py,sha256=_LNJ-J7w_qkGvBs0OgSWJl5mYwcgBIVc6E5qf4fp2YU,370
 lazylinop/basicops/add.py,sha256=PVftHIYd4l5Ddhr_kSoZCzcpPza14ylL0u4-62gYW3M,1508
 lazylinop/basicops/blockdiag.py,sha256=Ka2zsHzFNSoyDQC3VVMVsL_xHriY4QWg53Bf6zZeSKw,2255
 lazylinop/basicops/cat.py,sha256=8anT601uU8owwDD1LrxNN4mEVyBzSRqLdY_5IgBns_I,1852
 lazylinop/basicops/diag.py,sha256=I3Ai0tT5SFfM9mg33oirV4P5LeNgBN3eAawn6kH6rNE,11699
-lazylinop/basicops/eye.py,sha256=lWppYxMOhXUxKHUL3oS086GTXW2Zqn87GRESzwEy7ec,3406
+lazylinop/basicops/eye.py,sha256=0IT1OWR8laofAnHpbGijbYKzC4ZCeGdg4AdwqPZ0KdU,3449
 lazylinop/basicops/kron.py,sha256=Tz9tFkXqZ95F4IWdMIlVrN-vVuIi3mkf4A2TjfBuunQ,3792
 lazylinop/basicops/ones.py,sha256=W3cH6TY4uyc0ZORGut9xfWJY924WSFkZJX-TIKb5mTg,2309
-lazylinop/basicops/pad.py,sha256=ryon701dqmAntpa8nyHT8DsYqhsnv6NV3vzj2U1oDbo,31288
+lazylinop/basicops/pad.py,sha256=0n6skeJqIDZeV7rWRTDGPlF5PZS-mWe9QF1rzmIZ-Ac,42464
 lazylinop/basicops/zeros.py,sha256=tLcN6ohWz51r5iwVtWYFDWCambR0txymC_18og9-B9s,1573
 lazylinop/polynomial/__init__.py,sha256=dGdRlm9i4HmqWcFIHAYV4MueUfQ1KNIsuuKadGa4-q0,264
 lazylinop/polynomial/polynomial.py,sha256=iCf5AmHZJ4PNwFYKjQdaqQlwcfpZDkYhJhbFpXdlpdY,53006
-lazylinop/wip/__init__.py,sha256=ww8T00bJlNfAZtvPfJOCIqfNmsg9PomHmWyhu2kB3QM,78
+lazylinop/wip/__init__.py,sha256=xZ_vPqFoP84vFy9mKWqTGWrapzv_NBUaBM5KN8yWe3M,100
 lazylinop/wip/code_optimization.py,sha256=ieJcsn0RFt8E3FBwv6zH2bddRkEDiupp0nsnYDLr__U,1443
 lazylinop/wip/linear_algebra.py,sha256=KuUz7eyOxNn3PlymsQ_h5l1qCmLUfbSoCI5ZbwIFYfw,1447
-lazylinop/wip/signal.py,sha256=0hIj2rb5xJ85ehZ-y4xcr3MumYJBsaEum-QV38SG6Fo,133585
 lazylinop/wip/special_matrices.py,sha256=bU0UPHN4VbvpKEes7FQSJi5FnBPpzMlyQxKmt6nNWi0,57938
-lazylinop/wip/basicops/__init__.py,sha256=fS9lwF0O9tkBlk7OXo6VBohfMO6nWjMHGDwVhMHulVs,52
-lazylinop/wip/basicops/average.py,sha256=LD02eUm-mN3mdfrgBtxlK1RjkBZuAMnapuilK30p6VE,1607
-lazylinop/wip/basicops/mean.py,sha256=rFu4lng_7P8duw2oSnoNZDKmEHEfrLPtnbmcUKs7SDQ,573
+lazylinop/wip/basicops/__init__.py,sha256=VwLjxYoj0msANRJ9SHHLTcsFR7v9TmcJT_QErMf9pBg,85
+lazylinop/wip/basicops/anti_diag.py,sha256=Ew1P2b9YFI5m_gl-Ljahe7apCzYrtJHcZO8Dc3IvNG4,12658
+lazylinop/wip/basicops/average.py,sha256=hVq1VL9k-2micYUpkGdpnDdrbOk4wbn32Sp8GgefN8k,4066
+lazylinop/wip/basicops/mean.py,sha256=AASwMFwm1sHpFIad11XK5FlzzYhINvX5ZDTZPUCUGpc,2206
 lazylinop/wip/linalg/__init__.py,sha256=tT37IW-J-jlBQzHhIWeCZLyqypFOra8B7t3Tlz3fCTA,298
 lazylinop/wip/linalg/coshm.py,sha256=81UlRLwlaeYT6vjIQjsG41MRHp56P8GuDaHWrdgYtAY,4792
 lazylinop/wip/linalg/cosm.py,sha256=LGLKc1VGIX2J7BuL4AFJVoKpcglcAl3Aqvdmgy4wSJ0,2816
 lazylinop/wip/linalg/expm.py,sha256=ivEsbaAkqBHH6qulGwrbEZBB7ONJLDCLWIRHH7O9gWc,4233
 lazylinop/wip/linalg/khatri_rao.py,sha256=ob4rPDzX2WU4DTZz-02mdcJaaQTBwpS3Koldaxofozw,5587
 lazylinop/wip/linalg/logm.py,sha256=JJDAiqOeWN7fBY_6Ju04Qn1tIN0hLqKVpG4luWKP3bM,4667
 lazylinop/wip/linalg/sinhm.py,sha256=qdr8snq2n5AzbOpHhThHFbjivdZXCp34oBrR1p9dxFc,4694
@@ -35,13 +35,35 @@
 lazylinop/wip/parallel/mpilop.py,sha256=zJQXwVoQIOiL1bHbg_wNgqMKq4DH45LVayRxq-wp-rA,8328
 lazylinop/wip/parallel/pmatmat.py,sha256=2stXEbqFsj984Eg47EPbMtAutQFb9shSTtJHVQPefKw,4897
 lazylinop/wip/parallel/pmatmat_mpi.py,sha256=9s6o8dfWQitLlZSa5MVdkzke6JM7606d_i88a7aVMGo,4250
 lazylinop/wip/parallel/pmatmat_process.py,sha256=pTUXpSB0vq4KGNepKH3uQkmN8fkF6KFEuTWcLUwt-p0,5902
 lazylinop/wip/parallel/pmatmat_thread.py,sha256=gzjIoNV-ePz30K0l_TipJi--VyVfO3vl0E8oOn9OH5o,3306
 lazylinop/wip/random/__init__.py,sha256=Sqc6D6d_4UI8LQTlBzRz5IDpSLVK5ejcL5FJmC_A2FI,23
 lazylinop/wip/random/rand.py,sha256=8ZEtNxJtInOsJxcYDj8JdTobNzLXlaEmCDAlqbMq_mo,6721
-lazylinop/wip/signal/slices.py,sha256=nAeDcXj0HlYHt5U220uyjDl8b6vXUVHs8tRv-NTMgjw,9453
-lazylinop-1.8.0.dist-info/LICENSE.txt,sha256=jHt8qQXwxwsxIgSCZbFwPqQw3R1QWQK0JzZZ3PAwlU0,1434
-lazylinop-1.8.0.dist-info/METADATA,sha256=46B6Yf-avGsWVXIlLKq4QShZppPGGoGFkOSsVlmCHko,8177
-lazylinop-1.8.0.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
-lazylinop-1.8.0.dist-info/top_level.txt,sha256=zq6N2WH1Vl_0zSzqC12W0Oil87_uMjD3sYhWGjRioIc,10
-lazylinop-1.8.0.dist-info/RECORD,,
+lazylinop/wip/signal/__init__.py,sha256=K2vTKn5YiH6_OTfxXpbSLWkBvglieumLhQ4Cad6D7U4,501
+lazylinop/wip/signal/anti_eye.py,sha256=TgvScGKTtKh52LZVIWKLuviQXLz98ow2O5MqG_vX0m8,3796
+lazylinop/wip/signal/bc.py,sha256=GDx-V7o-BNiEgxTLz0aNrBBAZuEPVQLzmXjWYgrp7Tc,4084
+lazylinop/wip/signal/bc2d.py,sha256=qePWqhrJ2l2NvCz3K42x-p2nI_CIar82oSTbNR9lTd0,4117
+lazylinop/wip/signal/convolve.py,sha256=ybGZQ7IWOT2QPpnmNSZqmnll7fX3B3NJ_AaIMU07gbE,34045
+lazylinop/wip/signal/convolve2d.py,sha256=qP-tSpOxzAfUO2-6RPjljF34xlNrO4nSroNqCEYPMi0,12692
+lazylinop/wip/signal/dct.py,sha256=Ic4JmY6iIZvG4h2VUqGxu61V1b5jEu1xr4x5RfMe-eo,11141
+lazylinop/wip/signal/decimate.py,sha256=bBJ9Kqw9PqTcybT-L6THf8YraW8BDWo1pvlXqKW73M0,3272
+lazylinop/wip/signal/ds_mconv.py,sha256=NHL_OgNq0IzFwBBIE5GmeQoPmOGlIYRvZZd6oz7qm-g,10179
+lazylinop/wip/signal/dsconvolve.py,sha256=iqxbql8U-02mDbnA-zzW_ALPZIs7Eljj2liHLRolbME,9636
+lazylinop/wip/signal/dst.py,sha256=Z4BCrVoQOQdqRap7KTv5FwcqlBUk3Cunlfa8aJrcfX4,12181
+lazylinop/wip/signal/dwt1d.py,sha256=kWTFj3xqMxSLSNIZ0tb47euThPBuwmaTBumvqxiy4Do,12014
+lazylinop/wip/signal/dwt2d.py,sha256=nBUuyu1PL8Ul8Z4mVDkm54p6iRjzG3uCAfo9WCHhkhM,18663
+lazylinop/wip/signal/fft.py,sha256=kWXxSKhVgsSR6GHOIxWMR5OWz6wgpu_F-nTJ5cW5iDo,11167
+lazylinop/wip/signal/fft2.py,sha256=H8cTZpj8MDJHCq70Gi82PxhLtfjK3zDM1ZOTsZywRDI,2714
+lazylinop/wip/signal/flip.py,sha256=d_hmvb-YqMNNE1fVkFLrZzJE2lOAOfDFh7ZtQaNUR0M,2854
+lazylinop/wip/signal/fwht.py,sha256=RMSH_EUpzHy7gaUXiYrSkmOUwx_m_HQLoNpgc8PouCc,7186
+lazylinop/wip/signal/is_power_of_two.py,sha256=ZrPcCTQXAXqLbgA1hcUOFDtIf3cRVDubYBC8PzoB1kg,269
+lazylinop/wip/signal/mslices.py,sha256=7URvTFWv7VA_YHfF5GhNDyLv3GZgd9UCvzTA_nAXCjg,3315
+lazylinop/wip/signal/oa.py,sha256=b8iDO6DsOBFw23FhytK6VQPBpWLA42NcETIpyI1eOLE,2438
+lazylinop/wip/signal/scatter_and_gather_windows.py,sha256=C8AcKiKatby7qyNChUDEPpmxwJdXslcbpKmR9_SJ4lw,3230
+lazylinop/wip/signal/slices.py,sha256=lZ6eCalHexhflgbNuWnj4dP1akmfkgZhIwR6iE9WEKg,9463
+lazylinop/wip/signal/stft.py,sha256=FQmNAXVBkPWud0rQwPfbubnhgn9J15iAa8mqZ9P2FG4,4291
+lazylinop-1.9.0a0.dist-info/LICENSE.txt,sha256=jHt8qQXwxwsxIgSCZbFwPqQw3R1QWQK0JzZZ3PAwlU0,1434
+lazylinop-1.9.0a0.dist-info/METADATA,sha256=lcftsO661OZtj6HnO_2Q-ZHtmGlMluU7vF_FwERTm_s,8485
+lazylinop-1.9.0a0.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+lazylinop-1.9.0a0.dist-info/top_level.txt,sha256=zq6N2WH1Vl_0zSzqC12W0Oil87_uMjD3sYhWGjRioIc,10
+lazylinop-1.9.0a0.dist-info/RECORD,,
```

