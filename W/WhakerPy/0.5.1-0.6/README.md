# Comparing `tmp/WhakerPy-0.5.1-py3-none-any.whl.zip` & `tmp/WhakerPy-0.6-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,33 +1,36 @@
-Zip file size: 76194 bytes, number of entries: 31
--rw-r--r--  2.0 unx      349 b- defN 24-Mar-26 10:05 whakerpy/__init__.py
+Zip file size: 83937 bytes, number of entries: 34
+-rw-r--r--  2.0 unx      347 b- defN 24-Apr-21 16:29 whakerpy/__init__.py
 -rw-r--r--  2.0 unx     2595 b- defN 24-Jan-09 13:38 whakerpy/messages.py
--rw-r--r--  2.0 unx     4554 b- defN 24-Jan-09 13:38 whakerpy/htmlmaker/__init__.py
+-rw-r--r--  2.0 unx     4612 b- defN 24-Apr-29 08:09 whakerpy/htmlmaker/__init__.py
 -rw-r--r--  2.0 unx    10576 b- defN 24-Jan-09 13:38 whakerpy/htmlmaker/hconsts.py
--rw-r--r--  2.0 unx     5837 b- defN 24-Jan-09 13:38 whakerpy/htmlmaker/hexc.py
--rw-r--r--  2.0 unx     6951 b- defN 24-Jan-09 13:38 whakerpy/htmlmaker/treeelts.py
--rw-r--r--  2.0 unx    21740 b- defN 24-Mar-26 10:05 whakerpy/htmlmaker/treenode.py
+-rw-r--r--  2.0 unx     5835 b- defN 24-Apr-20 07:34 whakerpy/htmlmaker/hexc.py
+-rw-r--r--  2.0 unx     7435 b- defN 24-Apr-30 10:40 whakerpy/htmlmaker/treeelts.py
+-rw-r--r--  2.0 unx     2319 b- defN 24-Apr-29 08:09 whakerpy/htmlmaker/treeerror.py
+-rw-r--r--  2.0 unx    22554 b- defN 24-Apr-29 12:22 whakerpy/htmlmaker/treenode.py
 -rw-r--r--  2.0 unx      160 b- defN 23-Oct-09 09:11 whakerpy/htmlmaker/basenodes/__init__.py
 -rw-r--r--  2.0 unx     3920 b- defN 24-Jan-09 13:38 whakerpy/htmlmaker/basenodes/baseelts.py
 -rw-r--r--  2.0 unx     6313 b- defN 24-Jan-09 13:38 whakerpy/htmlmaker/basenodes/basenode.py
 -rw-r--r--  2.0 unx      314 b- defN 24-Jan-09 13:38 whakerpy/htmlmaker/emptynodes/__init__.py
--rw-r--r--  2.0 unx     4885 b- defN 24-Jan-09 13:38 whakerpy/htmlmaker/emptynodes/emptyelts.py
--rw-r--r--  2.0 unx     9696 b- defN 24-Jan-09 13:38 whakerpy/htmlmaker/emptynodes/emptynode.py
+-rw-r--r--  2.0 unx     4922 b- defN 24-Apr-30 14:16 whakerpy/htmlmaker/emptynodes/emptyelts.py
+-rw-r--r--  2.0 unx     9793 b- defN 24-Apr-30 14:13 whakerpy/htmlmaker/emptynodes/emptynode.py
 -rw-r--r--  2.0 unx      172 b- defN 24-Jan-09 13:38 whakerpy/htmlmaker/htmnodes/__init__.py
 -rw-r--r--  2.0 unx     5460 b- defN 24-Jan-09 13:38 whakerpy/htmlmaker/htmnodes/htmelts.py
--rw-r--r--  2.0 unx    11244 b- defN 24-Jan-09 13:38 whakerpy/htmlmaker/htmnodes/htmnode.py
--rw-r--r--  2.0 unx     1842 b- defN 24-Jan-09 13:38 whakerpy/httpd/__init__.py
--rw-r--r--  2.0 unx    14608 b- defN 24-Mar-26 10:05 whakerpy/httpd/handler.py
--rw-r--r--  2.0 unx     8450 b- defN 24-Mar-26 10:05 whakerpy/httpd/hresponse.py
--rw-r--r--  2.0 unx     4511 b- defN 24-Mar-26 10:05 whakerpy/httpd/hserver.py
--rw-r--r--  2.0 unx     7092 b- defN 24-Jan-09 13:38 whakerpy/httpd/hstatus.py
--rw-r--r--  2.0 unx      205 b- defN 24-Jan-09 13:38 whakerpy/webapp/__init__.py
--rw-r--r--  2.0 unx     5387 b- defN 24-Jan-09 13:38 whakerpy/webapp/webconfig.py
--rw-r--r--  2.0 unx     3455 b- defN 24-Jan-09 13:38 whakerpy/webapp/weblocalserver.py
--rw-r--r--  2.0 unx     4522 b- defN 24-Jan-09 13:38 whakerpy/webapp/webresponse.py
--rw-r--r--  2.0 unx      823 b- defN 24-Mar-26 10:06 WhakerPy-0.5.1.dist-info/AUTHORS
--rw-r--r--  2.0 unx    35149 b- defN 24-Mar-26 10:06 WhakerPy-0.5.1.dist-info/LICENSE
--rw-r--r--  2.0 unx    47438 b- defN 24-Mar-26 10:06 WhakerPy-0.5.1.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-Mar-26 10:06 WhakerPy-0.5.1.dist-info/WHEEL
--rw-r--r--  2.0 unx        9 b- defN 24-Mar-26 10:06 WhakerPy-0.5.1.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     2695 b- defN 24-Mar-26 10:06 WhakerPy-0.5.1.dist-info/RECORD
-31 files, 231044 bytes uncompressed, 71842 bytes compressed:  68.9%
+-rw-r--r--  2.0 unx    11479 b- defN 24-Apr-29 12:09 whakerpy/htmlmaker/htmnodes/htmnode.py
+-rw-r--r--  2.0 unx     1905 b- defN 24-Apr-25 14:56 whakerpy/httpd/__init__.py
+-rw-r--r--  2.0 unx     7494 b- defN 24-Apr-25 14:56 whakerpy/httpd/handler.py
+-rw-r--r--  2.0 unx     8806 b- defN 24-Apr-29 08:09 whakerpy/httpd/hresponse.py
+-rw-r--r--  2.0 unx     3869 b- defN 24-Apr-25 14:56 whakerpy/httpd/hserver.py
+-rw-r--r--  2.0 unx     7976 b- defN 24-Apr-29 12:36 whakerpy/httpd/hstatus.py
+-rw-r--r--  2.0 unx    15628 b- defN 24-Apr-30 14:24 whakerpy/httpd/hutils.py
+-rw-r--r--  2.0 unx      265 b- defN 24-Apr-25 15:29 whakerpy/webapp/__init__.py
+-rw-r--r--  2.0 unx     6830 b- defN 24-Apr-30 10:40 whakerpy/webapp/webconfig.py
+-rw-r--r--  2.0 unx     3138 b- defN 24-Apr-21 14:36 whakerpy/webapp/weblocalserver.py
+-rw-r--r--  2.0 unx     4626 b- defN 24-Apr-29 12:35 whakerpy/webapp/webresponse.py
+-rw-r--r--  2.0 unx     6909 b- defN 24-Apr-30 10:40 whakerpy/webapp/webwsgi.py
+-rw-r--r--  2.0 unx      823 b- defN 24-Apr-30 14:29 WhakerPy-0.6.dist-info/AUTHORS
+-rw-r--r--  2.0 unx    35149 b- defN 24-Apr-30 14:29 WhakerPy-0.6.dist-info/LICENSE
+-rw-r--r--  2.0 unx    47900 b- defN 24-Apr-30 14:29 WhakerPy-0.6.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-Apr-30 14:29 WhakerPy-0.6.dist-info/WHEEL
+-rw-r--r--  2.0 unx        9 b- defN 24-Apr-30 14:29 WhakerPy-0.6.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2935 b- defN 24-Apr-30 14:29 WhakerPy-0.6.dist-info/RECORD
+34 files, 253160 bytes uncompressed, 79219 bytes compressed:  68.7%
```

## zipnote {}

```diff
@@ -12,14 +12,17 @@
 
 Filename: whakerpy/htmlmaker/hexc.py
 Comment: 
 
 Filename: whakerpy/htmlmaker/treeelts.py
 Comment: 
 
+Filename: whakerpy/htmlmaker/treeerror.py
+Comment: 
+
 Filename: whakerpy/htmlmaker/treenode.py
 Comment: 
 
 Filename: whakerpy/htmlmaker/basenodes/__init__.py
 Comment: 
 
 Filename: whakerpy/htmlmaker/basenodes/baseelts.py
@@ -57,38 +60,44 @@
 
 Filename: whakerpy/httpd/hserver.py
 Comment: 
 
 Filename: whakerpy/httpd/hstatus.py
 Comment: 
 
+Filename: whakerpy/httpd/hutils.py
+Comment: 
+
 Filename: whakerpy/webapp/__init__.py
 Comment: 
 
 Filename: whakerpy/webapp/webconfig.py
 Comment: 
 
 Filename: whakerpy/webapp/weblocalserver.py
 Comment: 
 
 Filename: whakerpy/webapp/webresponse.py
 Comment: 
 
-Filename: WhakerPy-0.5.1.dist-info/AUTHORS
+Filename: whakerpy/webapp/webwsgi.py
+Comment: 
+
+Filename: WhakerPy-0.6.dist-info/AUTHORS
 Comment: 
 
-Filename: WhakerPy-0.5.1.dist-info/LICENSE
+Filename: WhakerPy-0.6.dist-info/LICENSE
 Comment: 
 
-Filename: WhakerPy-0.5.1.dist-info/METADATA
+Filename: WhakerPy-0.6.dist-info/METADATA
 Comment: 
 
-Filename: WhakerPy-0.5.1.dist-info/WHEEL
+Filename: WhakerPy-0.6.dist-info/WHEEL
 Comment: 
 
-Filename: WhakerPy-0.5.1.dist-info/top_level.txt
+Filename: WhakerPy-0.6.dist-info/top_level.txt
 Comment: 
 
-Filename: WhakerPy-0.5.1.dist-info/RECORD
+Filename: WhakerPy-0.6.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## whakerpy/__init__.py

```diff
@@ -5,10 +5,10 @@
 """
 
 from .htmlmaker import *
 from .httpd import *
 from .messages import error
 from .webapp import *
 
-__version__ = "0.5.1"
+__version__ = "0.6"
 ___author__ = "Brigitte Bigi"
 __copyright__ = "Copyright (C) 2023-2024 Brigitte Bigi, Laboratoire Parole et Langage, Aix-en-Provence, France"
```

## whakerpy/htmlmaker/__init__.py

```diff
@@ -104,14 +104,15 @@
 from .treeelts import HTMLHeaderNode
 from .treeelts import HTMLNavNode
 from .treeelts import HTMLMainNode
 from .treeelts import HTMLFooterNode
 from .treeelts import HTMLScriptNode
 
 from .treenode import HTMLTree
+from .treeerror import HTMLTreeError
 
 __all__ = (
     "HTML_EMPTY_TAGS",
     "HTML_TAGS",
     "HTML_VISIBLE_ATTR",
     "HTML_GLOBAL_ATTR",
     "HTML_TAG_ATTR",
@@ -138,9 +139,10 @@
     "HTMLNode",
     "HTMLHeadNode",
     "HTMLHeaderNode",
     "HTMLNavNode",
     "HTMLMainNode",
     "HTMLFooterNode",
     "HTMLScriptNode",
-    "HTMLTree"
+    "HTMLTree",
+    "HTMLTreeError"
 )
```

## whakerpy/htmlmaker/hexc.py

```diff
@@ -111,15 +111,15 @@
 
 # -----------------------------------------------------------------------
 
 
 class NodeParentIdentifierError(ValueError):
     """:ERROR 9312:.
 
-    "Expected HTML Parent node identifier {:s}. Got '{!s:s}' instead."
+    Expected HTML Parent node identifier {:s}. Got '{!s:s}' instead.
 
     """
 
     def __init__(self, expected, value):
         self._status = 9312
         self.parameter = error(self._status) + \
                          (error(self._status, "globals")).format(expected, value)
```

## whakerpy/htmlmaker/treeelts.py

```diff
@@ -34,14 +34,16 @@
 
     This banner notice must not be removed.
 
     -------------------------------------------------------------------------
 
 """
 
+import os
+
 from .hexc import NodeChildTagError
 from .hconsts import HEAD_TAGS
 from .emptynodes import EmptyNode
 from .htmnodes import HTMLNode
 
 # ---------------------------------------------------------------------------
 
@@ -112,55 +114,68 @@
             raise TypeError("Expected a dict.")
 
         child_node = EmptyNode(self.identifier, None, "meta", attributes=metadict)
         self._children.append(child_node)
 
     # -----------------------------------------------------------------------
 
-    def link(self, rel, href, link_type=None) -> None:
+    def link(self, rel: str, href: str, link_type: str = None) -> None:
         """Add a link tag to the header.
 
         :param rel: (str)
         :param href: (str) Path and/or name of the link reference
         :param link_type: (str) Mimetype of the link file
 
         """
         d = dict()
         d["rel"] = rel
-        d["href"] = href
+
+        if len(href) > 0 and href[0].isalpha():
+            d["href"] = os.sep + href
+        else:
+            d["href"] = href
+
         if link_type is not None:
             d["type"] = link_type
         child_node = EmptyNode(self.identifier, None, "link", attributes=d)
         self._children.append(child_node)
 
     # -----------------------------------------------------------------------
 
     def script(self, src, script_type) -> None:
         """Add a meta tag to the header.
 
-        :param src: (str) Script source file
-        :param script_type: (str) Script type
+        :param src: (str) Script source file or Script content
+        :param script_type: (str) Script type or None if script content
 
         """
-        d = dict()
-        d["src"] = src
-        d["type"] = script_type
+        if script_type is not None:
+            d = dict()
+            d["type"] = script_type
 
-        child_node = HTMLNode(self.identifier, None, "script", attributes=d)
-        self._children.append(child_node)
+            if len(src) > 0 and src[0].isalpha():
+                d["src"] = os.sep + src
+            else:
+                d["src"] = src
+
+            child_node = HTMLNode(self.identifier, None, "script", attributes=d)
+            self._children.append(child_node)
+        else:
+            child_node = HTMLNode(self.identifier, None, "script", value=str(src))
+            self._children.append(child_node)
 
     # -----------------------------------------------------------------------
 
-    def css(self, script_content) -> None:
+    def css(self, css_content) -> None:
         """Append css style content.
 
         :param script_content: (str) CSS content
 
         """
-        child_node = HTMLNode(self.identifier, None, "style", value=str(script_content))
+        child_node = HTMLNode(self.identifier, None, "style", value=str(css_content))
         self._children.append(child_node)
 
 # ---------------------------------------------------------------------------
 
 
 class HTMLHeaderNode(HTMLNode):
     """Convenient class to represent the header node of an HTML tree.
```

## whakerpy/htmlmaker/treenode.py

```diff
@@ -34,14 +34,15 @@
 
     This banner notice must not be removed.
 
     -------------------------------------------------------------------------
 
 """
 
+from __future__ import annotations
 import os
 
 from .hexc import NodeTypeError
 from .hexc import NodeIdentifierError
 from .basenodes import BaseNode
 from .basenodes import Doctype
 from .basenodes import HTMLComment
@@ -259,31 +260,32 @@
 
         :param head_node: (HTMLNode)
 
         :Raises: NodeTypeError: if head_node is not an HTMLNode
         :raises: NodeIdentifierError: if head_node identifier is not "head"
 
         """
-        if isinstance(head_node, HTMLNode) is False:
+        # if isinstance(head_node, HTMLNode) is False:
+        if hasattr(head_node, 'identifier') is False:
             raise NodeTypeError(type(head_node))
         if head_node.identifier != "head":
             raise NodeIdentifierError("head", head_node.identifier)
         head_node.set_parent(self.__html.identifier)
         self.__html.remove_child("head")
         self.__html.insert_child(0, head_node)
 
     # head node element of the HTMLTree.
     head = property(get_head, set_head)
 
     # -----------------------------------------------------------------------
 
-    def get_body_header(self) -> HTMLNode:
+    def get_body_header(self) -> HTMLNode | None:
         """Get the body->header element node.
 
-        :return: (HTMLNode) Body header node element
+        :return: (HTMLNode | None) Body header node element
 
         """
         return self._get_body().get_child("body_header")
 
     # -----------------------------------------------------------------------
 
     def set_body_header(self, body_node):
@@ -291,15 +293,16 @@
 
         :param body_node: (HTMLNode)
 
         :Raises: NodeTypeError: if head_node is not an HTMLNode
         :Raises: NodeIdentifierError: if head_node identifier is not "body_header"
 
         """
-        if isinstance(body_node, HTMLNode) is False:
+        # if isinstance(body_node, HTMLNode) is False:
+        if hasattr(body_node, 'identifier') is False:
             raise NodeTypeError(type(body_node))
         if body_node.identifier != "body_header":
             raise NodeIdentifierError("body_header", body_node.identifier)
         body_node.set_parent(self._get_body().identifier)
         self._get_body().remove_child("body_header")
         self._get_body().insert_child(0, body_node)
 
@@ -322,15 +325,16 @@
 
         :param body_node: (HTMLNode)
 
         :Raises: NodeTypeError: if head_node is not an HTMLNode
         :raises: NodeIdentifierError: if head_node identifier is not "body_nav"
 
         """
-        if isinstance(body_node, HTMLNode) is False:
+        #if isinstance(body_node, HTMLNode) is False:
+        if hasattr(body_node, 'identifier') is False:
             raise NodeTypeError(type(body_node))
         if body_node.identifier != "body_nav":
             raise NodeIdentifierError("body_nav", body_node.identifier)
         body_node.set_parent(self._get_body().identifier)
         self._get_body().remove_child("body_nav")
         self._get_body().insert_child(1, body_node)
 
@@ -364,15 +368,16 @@
         """Replace the current body->footer node by the given one.
 
         :param body_node: (HTMLNode)
         :Raises: NodeTypeError: if head_node is not an HTMLNode
         :Raises: NodeIdentifierError: if head_node identifier is not "body_footer"
 
         """
-        if isinstance(body_node, HTMLNode) is False:
+        #if isinstance(body_node, HTMLNode) is False:
+        if hasattr(body_node, 'identifier') is False:
             raise NodeTypeError(type(body_node))
         if body_node.identifier != "body_footer":
             raise NodeIdentifierError("body_footer", body_node.identifier)
         body_node.set_parent(self._get_body().identifier)
         self._get_body().remove_child("body_footer")
         self._get_body().append_child(body_node)
 
@@ -395,15 +400,16 @@
 
         :param body_node: (HTMLNode)
 
         :Raises: NodeTypeError: if head_node is not an HTMLNode
         :raises: NodeIdentifierError: if head_node identifier is not "body_script"
 
         """
-        if isinstance(body_node, HTMLNode) is False:
+        #if isinstance(body_node, HTMLNode) is False:
+        if hasattr(body_node, 'identifier') is False:
             raise NodeTypeError(type(body_node))
         if body_node.identifier != "body_script":
             raise NodeIdentifierError("body_script", body_node.identifier)
         body_node.set_parent(self._get_body().identifier)
         self._get_body().remove_child("body_script")
         self._get_body().append_child(body_node)
 
@@ -476,15 +482,15 @@
 
     # -----------------------------------------------------------------------
 
     def image(self, src: str, alt_text: str, identifier: str = None, class_name: str = None) -> HTMLNode:
         """Add an image to the body->main.
 
         :param src: (str) The path of the image file
-        :param alt_text: (str) the alternative text if for some reasons the image doesn't display or for narrator
+        :param alt_text: (str) the alternative text if for some reason the image doesn't display or for narrator
         :param identifier: (str) Optional, the identifier of the node (and also the id of the tag in the html generated)
         :param class_name: (str) Optional, the classes attribute for css of the button tag
 
         :return: (HTMLNode) The image node created
 
         """
         attributes = {
@@ -511,15 +517,18 @@
 
         :param node: (HTMLNode) Any element node
         :param nbs: (int) Number of space for indentation
         :raises: NodeTypeError: If the given parameter is not an HTMLNode
         :return: (str) Serialized node only if it has children or a value.
 
         """
-        if isinstance(node, HTMLNode) is False:
+        if node is None:
+            return ""
+        # if isinstance(node, HTMLNode) is False:
+        if hasattr(node, 'identifier') is False:
             raise NodeTypeError(type(node))
 
         if node.children_size() > 0 or node.get_value() is not None:
             return node.serialize(nbs)
         return ""
 
     # -----------------------------------------------------------------------
@@ -545,19 +554,26 @@
         for akey in self._get_body().get_attribute_keys():
             avalue = self._get_body().get_attribute_value(akey)
             s += " " + akey
             if avalue is not None:
                 s += '="' + avalue + '"'
         s += ">\n"
 
-        s += self.serialize_element(self.get_body_header(), nbs)
-        s += self.serialize_element(self.get_body_nav(), nbs)
-        s += self.get_body_main().serialize(nbs)
-        s += self.serialize_element(self.get_body_footer(), nbs)
-        s += self.serialize_element(self.get_body_script(), nbs)
+        # It should be "s += self.__html.get_child("body").serialize(nbs)"
+        # but the tree has main then header then nav then footer!
+        if self.get_body_header() is not None:
+            s += self.serialize_element(self.get_body_header(), nbs)
+        if self.get_body_nav() is not None:
+            s += self.serialize_element(self.get_body_nav(), nbs)
+        if self.get_body_main() is not None:
+            s += self.get_body_main().serialize(nbs)
+        if self.get_body_footer() is not None:
+            s += self.serialize_element(self.get_body_footer(), nbs)
+        if self.get_body_script() is not None:
+            s += self.serialize_element(self.get_body_script(), nbs)
         s += "\n</body>\n</html>\n"
 
         return s
 
     # -----------------------------------------------------------------------
 
     def serialize_to_file(self, filename: str, nbs: int = 4) -> str:
```

## whakerpy/htmlmaker/emptynodes/emptyelts.py

```diff
@@ -121,15 +121,15 @@
 
         """
         try:
             key = str(key)
         except Exception:
             raise NodeAttributeError(key)
 
-        if key not in HTML_GLOBAL_ATTR:
+        if key not in HTML_GLOBAL_ATTR and key.startswith("data-") is False:
             raise NodeAttributeError(key)
 
         return key
 
 # ---------------------------------------------------------------------------
```

## whakerpy/htmlmaker/emptynodes/emptynode.py

```diff
@@ -34,14 +34,15 @@
 
     This banner notice must not be removed.
 
     -------------------------------------------------------------------------
 
 """
 
+from __future__ import annotations
 from ..hexc import NodeAttributeError
 from ..hexc import NodeTagError
 from ..basenodes import BaseNode
 from ..hconsts import HTML_EMPTY_TAGS
 from ..hconsts import HTML_TAG_ATTR
 from ..hconsts import HTML_GLOBAL_ATTR
 from ..hconsts import HTML_VISIBLE_ATTR
@@ -64,15 +65,15 @@
 
     - &lt;tag /&gt;
     - &lt;tag k=v /&gt;
     - &lt;tag k1=v2 k2=v2 k3 /&gt;
 
     """
 
-    def __init__(self, parent: str, identifier: str, tag: str, attributes: dict = dict()):
+    def __init__(self, parent: str | None, identifier: str, tag: str, attributes: dict = dict()):
         """Create a new empty node.
 
         :param parent: (str) Parent identifier
         :param identifier: (str) This node identifier
         :param tag: (str) The element tag. Converted in lower case.
         :param attributes: (dict) key=(str) value=(str or None)
         :raises: NodeInvalidIdentifierError:
@@ -117,14 +118,15 @@
         try:
             key = str(key)
             key = key.lower()
         except Exception:
             raise NodeAttributeError(key)
 
         if key not in HTML_GLOBAL_ATTR and \
+                key.startswith("data-") is False and \
                 key not in HTML_VISIBLE_ATTR and \
                 key not in HTML_TAG_ATTR.keys() and \
                 key not in ARIA_TAG_ATTR.keys():
             raise NodeAttributeError(key)
 
         return key
```

## whakerpy/htmlmaker/htmnodes/htmnode.py

```diff
@@ -34,22 +34,23 @@
 
     This banner notice must not be removed.
 
     -------------------------------------------------------------------------
 
 """
 
+from __future__ import annotations
 import logging
 import traceback
 
 from ..hconsts import HTML_TAGS
 from ..hexc import NodeParentIdentifierError
+from ..hexc import NodeTypeError
 from ..hexc import NodeKeyError
 from ..hexc import NodeTagError
-from ..basenodes import BaseNode
 from ..emptynodes import BaseTagNode
 
 # ---------------------------------------------------------------------------
 
 
 class TagNode(BaseTagNode):
     """A node for any HTML element.
@@ -74,15 +75,15 @@
 
     To work around this limitation, let value be the whole content of the
     tag. In the example, value is "value_part1 <b> text_bold </b> value_part2"
     and the tag has no <b> child.
 
     """
 
-    def __init__(self, parent: str, identifier: str, tag: str, attributes=dict(), value=None):
+    def __init__(self, parent: str | None, identifier: str, tag: str, attributes=dict(), value=None):
         """Create a tag node to represent any HTML element.
 
         :param parent: (str) Parent identifier
         :param identifier: (str) This node identifier
 
         """
         # Identifier(s) of the children' node(s) :
@@ -153,16 +154,18 @@
 
         :param node: (BaseNode, BaseTagNode, EmptyNode, HTMLNode)
         :raises: TypeError:
         :raises: NodeKeyError:
         :raises: NodeParentIdentifierError:
 
         """
-        if isinstance(node, BaseNode) is False:
-            raise TypeError("Node expected.")
+        # if isinstance(node, BaseNode) is False:
+        #     raise TypeError("Node expected.")
+        if hasattr(node, 'identifier') is False:
+            raise NodeTypeError(type(node))
 
         if node.identifier == self._parent or node.identifier == self.identifier:
             raise NodeKeyError(self.identifier, node.identifier)
 
         if node.get_parent() != self.identifier:
             raise NodeParentIdentifierError(self.identifier, node.get_parent())
 
@@ -177,16 +180,18 @@
         :param pos: (int) Index position
         :param node: (BaseNode, BaseTagNode, EmptyNode, HTMLNode)
         :raises: NodeKeyError:
         :raises: TypeError:
         :raises: Exception:
 
         """
-        if isinstance(node, BaseNode) is False:
-            raise TypeError("Node expected.")
+        # if isinstance(node, BaseNode) is False:
+        #    raise TypeError("Node expected.")
+        if hasattr(node, 'identifier') is False:
+            raise NodeTypeError(type(node))
 
         if node.identifier == self._parent or node.identifier == self.identifier:
             raise NodeKeyError(self.identifier, node.identifier)
 
         if node.get_parent() != self.identifier:
             raise NodeParentIdentifierError(self.identifier, node.get_parent())
```

## whakerpy/httpd/__init__.py

```diff
@@ -1,13 +1,13 @@
 # -*- coding: UTF-8 -*-
 """
 :filename: sppas.ui.whakerpy.httpd.__init__.py
 :author:   Brigitte Bigi
 :contact:  contact@sppas.org
-:summary:  Manage an HTTPD server and an handler for any web-based app.
+:summary:  Manage an HTTPD server and a handler for any web-based app.
 
 .. _This file is part of SPPAS: https://sppas.org/
 ..
     -------------------------------------------------------------------------
 
      ___   __    __    __    ___
     /     |  \  |  \  |  \  /              the automatic
@@ -37,17 +37,20 @@
 
     -------------------------------------------------------------------------
 
 """
 
 from .hstatus import HTTPDValueError
 from .hstatus import HTTPDStatus
+from .hutils import HTTPDHandlerUtils
 from .handler import HTTPDHandler
 from .hserver import BaseHTTPDServer
 from .hresponse import BaseResponseRecipe
 
 __all__ = (
     "BaseResponseRecipe",
     "HTTPDStatus",
     "HTTPDValueError",
     "HTTPDHandler",
-    "BaseHTTPDServer")
+    "HTTPDHandlerUtils",
+    "BaseHTTPDServer"
+)
```

## whakerpy/httpd/handler.py

```diff
@@ -1,10 +1,10 @@
 # -*- coding: UTF-8 -*-
 """
-:filename: sppas.ui.whakerpy.httpd.handler.py
+:filename: whakerpy.httpd.handler.py
 :author:   Brigitte Bigi
 :contributor: Florian Lopitaux
 :contact:  contact@sppas.org
 :summary:  Manage an HTTPD handler for any web-based application.
 
 .. _This file is part of SPPAS: https://sppas.org/
 ..
@@ -36,30 +36,29 @@
 
     This banner notice must not be removed.
 
     -------------------------------------------------------------------------
 
 """
 
-import os
-import json
+from __future__ import annotations
 import logging
-import codecs
-import mimetypes
 import http.server
-from urllib.parse import parse_qsl
 
 from .hstatus import HTTPDStatus
+from .hutils import HTTPDHandlerUtils
 
 # ---------------------------------------------------------------------------
 
 
 class HTTPDHandler(http.server.BaseHTTPRequestHandler):
     """Web-based application HTTPD handler.
 
+    This class is used to handle the HTTP requests that arrive at the server.
+
     This class is instantiated by the server each time a request is received
     and then a response is created. This is an HTTPD handler for any Web-based
     application server. It parses the request and the headers, then call a
     specific method depending on the request type.
 
     In this handler, HTML pages are supposed to not be static. Instead,
     they are serialized from an HTMLTree instance -- so not read from disk.
@@ -92,294 +91,110 @@
 
         """
         status = HTTPDStatus.check(status)
         self.send_response(status)
 
         if mime_type is not None:
             self.send_header('Content-Type', mime_type)
+
         self.end_headers()
 
     # -----------------------------------------------------------------------
 
-    def _static_content(self, filename: str, mime_type: str) -> tuple:
-        """Return the file content and the corresponding status.
+    def _response(self, content: bytes, status: int, mime_type: str = None) -> None:
+        """Make the appropriate HTTPD response.
 
-        :param filename: (str) The path of the file to return
+        :param content: (bytes) The HTML response content
+        :param status: (int) The HTTPD status code of the response
         :param mime_type: (str) The mime type of the file response
 
-        :return: tuple(bytes, HTTPDStatus)
-
         """
-        if os.path.exists(filename) is True:
-            if os.path.isfile(filename) is True:
-                content = HTTPDHandler.open_file_to_binary(filename, mime_type)
-                return content, HTTPDStatus()
-
-            else:
-                content = bytes("<html><body>Error 403: Forbidden."
-                                "The client can't have access to the requested {:s}."
-                                "</body></html>".format(filename), "utf-8")
-
-                status = HTTPDStatus()
-                status.code = 403
-                return content, status
-
-        # it does not exist!
-        content = bytes("<html><body>Error 404: Not found."
-                        "The server does not have the requested {:s}."
-                        "</body></html>".format(filename), "utf-8")
+        self._set_headers(status, mime_type)
+        self.wfile.write(content)
 
-        status = HTTPDStatus()
-        status.code = 404
-        return content, status
+        if status == 410:
+            self.server.shutdown()
 
     # -----------------------------------------------------------------------
 
-    def _bakery(self, events: dict, mime_type: str) -> tuple:
+    def _bakery(self, handler_utils: HTTPDHandlerUtils, events: dict, mime_type: str) -> tuple:
         """Process the events and return the html page content or json data and status.
 
+        :param handler_utils: (HTTPDhandlerUtils)
         :param events: (dict) key=event name, value=event value
         :param mime_type: (str) The mime type of the file response
 
         :return: tuple(bytes, HTTPDStatus) the content of the response the httpd status
 
         """
-        # Test if the server is our
-        if hasattr(self.server, 'page_bakery') is False:
-            # Server is not the custom one for SPPAS wapp.
-            return self._static_content(self.path[1:], mime_type)
-
-        # Requested page name and page bakery for all the pages created
-        # dynamically -- i.e. from an HTMLTree.
-        page_name = os.path.basename(self.path)
-
-        if mime_type == "application/json":
-            content, status = self.server.page_bakery(page_name, events, True)
-        else:
-            content, status = self.server.page_bakery(page_name, events)
-
-        # but the HTML page may be static
-        if status == 404:
-            content, status = self._static_content(self.path[1:], mime_type)
+        # Server is not the custom one for SPPAS wapp.
+        if not hasattr(self.server, 'page_bakery'):
+            return handler_utils.static_content(self.path[1:])
+
+        # get the response
+        content, status = self.server.page_bakery(handler_utils.get_page_name(), events,
+                                                  handler_utils.has_to_return_data(mime_type))
 
         return content, status
 
     # -----------------------------------------------------------------------
-
-    def _response(self, content: bytes, status: int, mime_type: str = None) -> None:
-        """Make the appropriate HTTPD response.
-
-        :param content: (bytes) The HTML response content
-        :param status: (int) The HTTPD status code of the response
-        :param mime_type: (str) The mime type of the file response
-
-        """
-        if status == 418:
-            # 418: I'm not a teapot. Used as a response to a blocked request.
-            # With no response content, the browser will display an empty page.
-            self._set_headers(418, mime_type)
-        elif status == 205:
-            # 205 Reset Content. The request has been received. Tells the
-            # user agent to reset the document which sent this request.
-            # With no response content, the browser will continue to display
-            # the current page.
-            self._set_headers(205, mime_type)
-        else:
-            self._set_headers(status, mime_type)
-            self.wfile.write(content)
-            if status == 410:
-                # 410 Gone. Only possible in the context of a local app.
-                # On web, the server does not shut down when the client
-                # is asking for!
-                self.server.shutdown()
-
-    # -----------------------------------------------------------------------
     # Override BaseHTTPRequestHandler classes.
     # -----------------------------------------------------------------------
 
     def do_HEAD(self) -> None:
         """Prepare the response to a HEAD request."""
         logging.debug("HEAD -- requested: {}".format(self.path))
         self._set_headers(200)
 
     # -----------------------------------------------------------------------
 
     def do_GET(self) -> None:
-        """Prepare the response to a GET request.
-
-        """
+        """Prepare the response to a GET request."""
         logging.debug("GET -- requested: {}".format(self.path))
 
-        # parse the path
-        try:
-            default = self.server.default()
-            self.path = HTTPDHandler.filter_path(self.path, default_path=default)[0]
-        except AttributeError:
-            # Server is not the custom one for dynamic app.
-            self.path = HTTPDHandler.filter_path(self.path)[0]
+        handler_utils = HTTPDHandlerUtils(self.headers, self.path, self.__get_default_page())
+        self.path = handler_utils.get_path()
+        mime_type = HTTPDHandlerUtils.get_mime_type(self.path)
 
-        mime_type = HTTPDHandler.get_mime_type(self.path)
-
-        # The client requested an HTML page. Response content is created
-        # by the server.
+        # The client requested an HTML page. Response content is created by the server.
         if mime_type == "text/html":
-            content, status = self._bakery(dict(), mime_type)
+            content, status = self._bakery(handler_utils, dict(), mime_type)
+        # The client requested a static file
         else:
-            # The client requested a css, a script, an image, a font, etc.
-            # These are statics' content. The handler is reading it from disk,
-            # and it makes the response itself.
-            content, status = self._static_content(self.path[1:], mime_type)
+            content, status = handler_utils.static_content(self.path[1:])
 
         self._response(content, status.code, mime_type)
 
     # -----------------------------------------------------------------------
 
     def do_POST(self) -> None:
-        """Prepare the response to a POST request.
-
-        """
+        """Prepare the response to a POST request."""
         logging.debug("POST -- requested: {}".format(self.path))
 
-        # parse the path
-        try:
-            default = self.server.default()
-            self.path = HTTPDHandler.filter_path(self.path, default_path=default)[0]
-        except AttributeError:
-            # Server is not the custom one for dynamic app.
-            self.path = HTTPDHandler.filter_path(self.path)[0]
-
-        # Parse the posted data
-        events = HTTPDHandler.extract_body_content(self.rfile, self.headers.get('Content-Type'),
-                                                   self.headers.get('Content-Length'))
-
-        # Create the response
-        if "application/json" in self.headers.get('Accept'):
-            mime_type = "application/json"
-            content, status = self._bakery(events, mime_type)
-        else:
-            mime_type = "text/html"
-            content, status = self._bakery(events, mime_type)
+        handler_utils = HTTPDHandlerUtils(self.headers, self.path, self.__get_default_page())
+        events, accept = handler_utils.process_post(self.rfile)
 
-        self._response(content, status.code, mime_type)
+        content, status = self._bakery(handler_utils, events, accept)
+        self._response(content, status.code, accept)
 
     # -----------------------------------------------------------------------
 
     def log_request(self, code='-', size='-') -> None:
         """Override. For a quiet handler pls!!!."""
         pass
 
     # -----------------------------------------------------------------------
-    # PUBLIC STATIC METHODS
+    # PRIVATE METHODS
     # -----------------------------------------------------------------------
 
-    @staticmethod
-    def get_mime_type(filename: str) -> str:
-        """Returns the mime type of given file name or path.
-
-        :param filename: (str) The name or path of the file
+    def __get_default_page(self) -> str:
+        """Get the default page in case if the url doesn't specify any page.
 
-        :return: (str) The mime type of the file or 'unknown' if we can't find the type
-
-        """
-        mime_type, _ = mimetypes.guess_type(filename)
-
-        if mime_type is not None:
-            return mime_type
-        else:
-            return "unknown"
-
-    # -----------------------------------------------------------------------
-
-    @staticmethod
-    def open_file_to_binary(filename: str, mime_type: str):
-        """Open and read the given file and transform the content to bytes value.
-
-        :param filename: (str) The path of the file to read
-        :param mime_type: (str) The mime type of the file response
-
-        :return: (bytes) the file content in bytes format
-
-        """
-        if mime_type is not None and (mime_type.startswith("text") or mime_type == "application/javascript"):
-            with codecs.open(filename, "r", "utf-8") as fp:
-                content = bytes("", "utf-8")
-
-                for line in fp.readlines():
-                    content += bytes(line, "utf-8")
-
-                return content
-        else:
-            return open(filename, "rb").read()
-
-    # -----------------------------------------------------------------------
-
-    @staticmethod
-    def filter_path(path: str, default_path: str = "index.html") -> tuple[str, str]:
-        """Parse the path to return the correct filename and page name (for webapp package : WebSiteData class).
-
-        :param path: (str) The path obtain from the http request
-        :param default_path: (str) The default path to add if the path is juste '/'
-
-        :return: (tuple[str, str]) first : the filename requested
-                                   second : the page name (for webapp package)
-
-        """
-        # this block has to be before the '/' condition (example: http://localhost:8080/?wexa_color=light)
-        if "?" in path:
-            path = path[:path.index("?")]
-
-        filename = path
-        if filename == "/":
-            filename += default_path
-
-        page_name = path
-        if page_name.startswith('/'):
-            page_name = page_name[1:]
-
-        return filename, page_name
-
-    # -----------------------------------------------------------------------
-
-    @staticmethod
-    def extract_body_content(content, content_type: str, content_length: str) -> dict:
-        """Read and parse the body content of a POST request.
-        Return a dictionary with keys and values.
-
-        :param content: (Binary object) the body of the POST request
-        :param content_type: (str) the content type of the body, given (or not) in the request header
-        :param content_length: (str) the content length of the body, given (or not) in the request header
-
-        :return: (dict) the dictionary that contains the events to process,
-                        return an empty dictionary if there is an error.
+        :return: (str) the default page name
 
         """
         try:
-            length = int(content_length)
-        # if the length is None or not a string which contains an integer if somebody set the header with bad values
-        except (TypeError, ValueError):
-            length = 0
-
-        # read file and print traceback
-        data = content.read(length).decode("utf-8")
-        logging.debug("POST -- data: {}".format(data))
-
-        # if content-type is not defined in the header request
-        if content_type is None or content_length == 0:
-            data = dict()
-
-        # parse text data from forms
-        elif content_type.startswith("application/x-www-form-urlencoded") or content_type.startswith("multipart/form-data"):
-            data = dict(parse_qsl(
-                data,
-                keep_blank_values=True,
-                strict_parsing=False  # errors are silently ignored
-            ))
-
-        # parse json data from request.js
-        else:
-            try:
-                data = json.loads(data)
-            except json.JSONDecodeError:
-                logging.error("Can't decode JSON POSTED data : {}".format(data))
+            default = self.server.default()
+        except AttributeError:  # Server is not the custom one for dynamic app.
+            default = "index.html"
 
-        # return data parsed in python dictionary
-        return data
+        return default
```

## whakerpy/httpd/hresponse.py

```diff
@@ -1,9 +1,9 @@
 """
-:filename: sppas.ui.whakerpy.httpd.hresponse.py
+:filename: whakerpy.httpd.hresponse.py
 :author:   Brigitte Bigi
 :contact:  contact@sppas.org
 :summary:  Base class to create an HTML response.
 
 .. _This file is part of SPPAS: https://sppas.org/
 ..
     -------------------------------------------------------------------------
@@ -34,14 +34,15 @@
 
     This banner notice must not be removed.
 
     -------------------------------------------------------------------------
 
 """
 
+from __future__ import annotations
 import os
 import json
 
 from whakerpy.htmlmaker import HTMLComment
 from whakerpy.htmlmaker import HTMLNode
 from whakerpy.htmlmaker import HTMLTree
 
@@ -96,45 +97,52 @@
 
         # Define workers: the HTML bakery
         if tree is not None and isinstance(tree, HTMLTree):
             self._htree = tree
         else:
             self._htree = HTMLTree(self._name.replace(" ", "_"))
 
-        # Test if this tree can manage events (from buttons, forms, etc)
+        # Test if this tree can manage events (from buttons, forms, etc.)
         shead = self._htree.head.serialize()
 
         if "notify_event" not in shead:
             js = HTMLNode(self._htree.head.identifier, None, "script",
                           value=JS_NOTIFY_EVENT)
             self._htree.head.append_child(js)
 
         if "request.js" not in shead:
             self._htree.head.script(src=os.path.join("whakerpy", "request.js"), script_type="application/javascript")
 
         self.create()
 
     # -----------------------------------------------------------------------
 
-    def get_json_data(self) -> str:
+    def get_data(self) -> str | bytes:
         """Gets the current data to send to the client following this request.
 
-        :return: (str) The json data in the string format
+        :return: (str) The data in the string format or json depending on the type.
 
         """
-        return json.dumps(self._data)
+        if isinstance(self._data, dict):
+            return json.dumps(self._data)
+
+        elif isinstance(self._data, bytes) or isinstance(self._data, bytearray) or isinstance(self._data, str):
+            return self._data
+
+        else:
+            raise ValueError(f"Unexpected data type to response to the client : {type(self._data)}")
 
     # -----------------------------------------------------------------------
 
-    def reset_json_data(self) -> None:
+    def reset_data(self) -> None:
         """Clear json data of the response.
         This function has to be called after each response send to the client to avoid overflow problems.
 
         """
-        self._data.clear()
+        self._data = dict()
 
     # -----------------------------------------------------------------------
     # Getters
     # -----------------------------------------------------------------------
 
     @property
     def name(self) -> str:
```

## whakerpy/httpd/hserver.py

```diff
@@ -1,9 +1,9 @@
 """
-:filename: sppas.ui.whakerpy.httpd.server.py
+:filename: whakerpy.httpd.server.py
 :author:   Brigitte Bigi
 :contact:  contact@sppas.org
 :summary: This is the Web-based application HTTPD server.
 
 .. _This file is part of SPPAS: https://sppas.org/
 ..
     -------------------------------------------------------------------------
@@ -36,16 +36,15 @@
 
     -------------------------------------------------------------------------
 
 """
 
 import http.server
 
-from .hstatus import HTTPDStatus
-from .hresponse import BaseResponseRecipe
+from .hutils import HTTPDHandlerUtils
 
 # ---------------------------------------------------------------------------
 
 
 class BaseHTTPDServer(http.server.ThreadingHTTPServer):
     """A base class for any custom HTTPD server.
 
@@ -89,38 +88,21 @@
         :param app: (str) Any string definition for custom use
 
         """
         raise NotImplementedError
 
     # -----------------------------------------------------------------------
 
-    def page_bakery(self, page_name: str, events: dict, is_json_data_to_return: bool = False) -> tuple:
+    def page_bakery(self, page_name: str, events: dict, has_to_return_data: bool = False) -> tuple:
         """Return the page content and response status.
 
         This method should be invoked after a POST request in order to
         take the events into account when baking the HTML page content.
 
         :param page_name: (str) Requested page name
         :param events: (dict) key=event name, value=event value
-        :param is_json_data_to_return: (bool) False by default - Boolean
-        value to know if the server return json data or html page
+        :param has_to_return_data: (bool) False by default - Boolean to know if the server return data or html page
 
         :return: tuple(bytes, HTTPDStatus)
 
         """
-        # Get the response from the appropriate bakery.
-        if page_name in self._pages:
-            if isinstance(self._pages[page_name], BaseResponseRecipe) is True:
-                bakery = self._pages[page_name]
-                content = bytes(bakery.bake(events), "utf-8")
-
-                if is_json_data_to_return:
-                    # get data set by the current page
-                    content = bytes(bakery.get_json_data(), "utf-8")
-                    bakery.reset_json_data()
-
-                return content, bakery.status
-
-        # or not!
-        status = HTTPDStatus()
-        status.code = 404
-        return bytes(" ", "utf-8"), status
+        return HTTPDHandlerUtils.bakery(self._pages, page_name, events, has_to_return_data)
```

## whakerpy/httpd/hstatus.py

```diff
@@ -1,10 +1,10 @@
 # -*- coding: UTF-8 -*-
 """
-:filename: sppas.ui.whakerpy.httpd.hstatus.py
+:filename: whakerpy.httpd.hstatus.py
 :author:   Brigitte Bigi
 :contact:  contact@sppas.org
 :summary:  The HTTPD status codes.
 
 .. _This file is part of SPPAS: https://sppas.org/
 ..
     -------------------------------------------------------------------------
@@ -35,15 +35,17 @@
 
     This banner notice must not be removed.
 
     -------------------------------------------------------------------------
 
 """
 
+from __future__ import annotations
 from whakerpy.messages import error
+from whakerpy.htmlmaker import HTMLTreeError
 
 # -----------------------------------------------------------------------
 
 
 class HTTPDValueError(ValueError):
     """:ERROR 0377:.
 
@@ -171,21 +173,21 @@
         if value not in HTTPDStatus.HTTPD_STATUS.keys():
             raise HTTPDValueError(value)
 
         return value
 
     # -----------------------------------------------------------------------
 
-    def __init__(self):
+    def __init__(self, code: int = 200):
         """Create the private member for the status code.
 
         Default status code is 200 for an "OK" httpd response.
 
         """
-        self.__scode = 200
+        self.__scode = self.check(code)
 
     # -----------------------------------------------------------------------
 
     def get(self):
         """Return the status code value (int)."""
         return self.__scode
 
@@ -198,22 +200,40 @@
         """
         value = self.check(value)
         self.__scode = value
 
     code = property(get, set)
 
     # -----------------------------------------------------------------------
+
+    def to_html(self, encode: bool = False, msg_error: str = None) -> HTMLTreeError | bytes:
+        """Create an error HTML page for the instance of status error and return the tree instance (or serialize).
+
+        :param encode: (bool) Optional, False by default, Boolean to know if we serialize the return or not
+        :param msg_error: (str) Optional, an error message for more information for the user
+
+        :return: (HTMLTreeError | bytes) the tree error generated, encoded in bytes for response or object instance
+
+        """
+        tree = HTMLTreeError(self, msg_error)
+
+        if encode is True:
+            return tree.serialize().encode("utf-8")
+        else:
+            return tree
+
+    # -----------------------------------------------------------------------
     # Overloads
     # -----------------------------------------------------------------------
 
     def __str__(self):
         return str(self.__scode)
 
     # -----------------------------------------------------------------------
 
     def __repr__(self):
-        return "{:d}: {:s}".format(self.__scode, HTTPDStatus.HTTPD_STATUS[self.__scode])
+        return "{:d} {:s}".format(self.__scode, HTTPDStatus.HTTPD_STATUS[self.__scode])
 
     # -----------------------------------------------------------------------
 
     def __eq__(self, other):
         return self.__scode == other
```

## whakerpy/webapp/__init__.py

```diff
@@ -1,9 +1,11 @@
 from .webconfig import WebSiteData
 from .webresponse import WebSiteResponse
 from .weblocalserver import WebSiteApplication
+from .webwsgi import WSGIApplication
 
 __all__ = (
     "WebSiteData",
     "WebSiteResponse",
-    "WebSiteApplication"
+    "WebSiteApplication",
+    "WSGIApplication"
 )
```

## whakerpy/webapp/webconfig.py

```diff
@@ -34,18 +34,23 @@
 
     This banner notice must not be removed.
 
     -------------------------------------------------------------------------
 
 """
 
+from __future__ import annotations
 import codecs
 import os
 import json
 
+from ..htmlmaker import HTMLTree
+from ..httpd import BaseResponseRecipe
+from .webresponse import WebSiteResponse
+
 # ---------------------------------------------------------------------------
 
 
 class WebSiteData:
     """Storage class of a webapp configuration, extracted from a JSON file.
 
     For each dynamic page of a webapp, this class contains the filename of
@@ -150,14 +155,49 @@
         if page in self._pages:
             if "footer" in self._pages[page]:
                 return self._pages[page]["footer"]
 
         return False
 
     # -----------------------------------------------------------------------
+
+    def create_pages(self, web_response=WebSiteResponse, default_path: str = "") -> dict:
+        """Instantiate all pages response from the json.
+
+        :param web_response: (BaseResponseRecipe) the class to used to create the pages,
+                            WebSiteResponse class used by default
+        :param default_path: (str) None by default, the default path for all pages
+
+        :return: (dict) a dictionary with key = page name and value = the response object
+
+        """
+        pages = dict()
+
+        tree = HTMLTree("sample")
+        for page_name in self._pages:
+            page_path = os.path.join(default_path, self.filename(page_name))
+            pages[page_name] = web_response(page_path, tree)
+
+        return pages
+
+    # -----------------------------------------------------------------------
+
+    def bake_response(self, page_name: str, default: str = "") -> BaseResponseRecipe | None:
+        """Return the bakery system to create the page dynamically.
+
+        To be overridden by subclasses.
+
+        :param page_name: (str) Name of an HTML page
+        :param default: (str) The default path
+        :return: (BaseResponseRecipe)
+
+        """
+        raise NotImplementedError
+
+    # -----------------------------------------------------------------------
     # Overloads
     # -----------------------------------------------------------------------
 
     def __format__(self, fmt):
         return str(self).__format__(fmt)
 
     def __iter__(self):
```

## whakerpy/webapp/weblocalserver.py

```diff
@@ -1,40 +1,33 @@
 """
-:filename:  whakerpy.webapp.weblocalservere.py
-:author:   Mathias Cazals, Brigitte Bigi
-:contact:  contact@sppas.org
-:summary:  Create a generic HTTPD localhost server.
+:filename: whakerpy.webapp.weblocalserver.py
+:author: Brigitte Bigi
+:contact: contact@sppas.org
+:summary: Create a HTTPD localhost server.
 
-.. _This file was part of SPPAS: https://sppas.org/ and migrated in WhakerPy,
-.. on 2023-12-08.
+.. _This file was part of WhakerPy: https://whakerpy.sf.net
     -------------------------------------------------------------------------
 
-     ___   __    __    __    ___
-    /     |  \  |  \  |  \  /              the automatic
-    \__   |__/  |__/  |___| \__             annotation and
-       \  |     |     |   |    \             analysis
-    ___/  |     |     |   | ___/              of speech
-
-    Copyright (C) 2011-2023 Brigitte Bigi
+    Copyright (C) 2023-2024 Brigitte Bigi
     Laboratoire Parole et Langage, Aix-en-Provence, France
 
     Use of this software is governed by the GNU Public License, version 3.
 
-    SPPAS is free software: you can redistribute it and/or modify
+    WhakerPy is free software: you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation, either version 3 of the License, or
     (at your option) any later version.
 
-    SPPAS is distributed in the hope that it will be useful,
+    WhakerPy is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
 
     You should have received a copy of the GNU General Public License
-    along with SPPAS. If not, see <https://www.gnu.org/licenses/>.
+    along with WhakerPy. If not, see <https://www.gnu.org/licenses/>.
 
     This banner notice must not be removed.
 
     -------------------------------------------------------------------------
 
 """
```

## whakerpy/webapp/webresponse.py

```diff
@@ -37,30 +37,30 @@
     -------------------------------------------------------------------------
 
 """
 
 import logging
 import codecs
 
-from whakerpy.httpd import BaseResponseRecipe
 from whakerpy.httpd import HTTPDStatus
+from whakerpy.httpd import BaseResponseRecipe
 
 # ---------------------------------------------------------------------------
 
 
 class WebSiteResponse(BaseResponseRecipe):
     """Create an HTML response content.
 
     Can be used when all pages of a webapp are sharing the same header, nav
     and footer. Then, **only one tree** is created for all pages, and its
     body->main is changed depending on the requested page.
 
     """
 
-    def __init__(self, name="index.html", tree=None):
+    def __init__(self, name="index.html", tree=None, **kwargs):
         """Create a HTTPD Response instance with a default response.
 
         Useful when creating dynamically the HTML Tree for a webapp.
         The "main" part of the body is re-created every time bake() is invoked.
         Here, it's loaded from a static file.
 
         :param name: (str) Filename of the body main content.
@@ -107,23 +107,25 @@
     def _invalidate(self) -> None:
         """Remove all children nodes of the body "main".
 
         Delete the body main content and nothing else.
 
         """
         node = self._htree.body_main
-        for i in reversed(range(node.children_size())):
-            node.pop_child(i)
+        node.clear_children()
+        # for i in reversed(range(node.children_size())):
+        #     node.pop_child(i)
 
     # -----------------------------------------------------------------------
 
     def _bake(self) -> None:
         """Create the dynamic page content in HTML.
 
         Load the body->main content from a file and add it to the tree.
 
         """
         logging.debug(" -> Set {:s} content to the body->main".format(self._name))
         # Define this page main content.
         with codecs.open(self._name, "r", "utf-8") as fp:
             lines = fp.readlines()
-            self._htree.body_main.set_value(" ".join(lines))
+            if self._htree.get_body_main() is not None:
+                self._htree.body_main.set_value(" ".join(lines))
```

## Comparing `WhakerPy-0.5.1.dist-info/AUTHORS` & `WhakerPy-0.6.dist-info/AUTHORS`

 * *Files identical despite different names*

## Comparing `WhakerPy-0.5.1.dist-info/LICENSE` & `WhakerPy-0.6.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `WhakerPy-0.5.1.dist-info/METADATA` & `WhakerPy-0.6.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: WhakerPy
-Version: 0.5.1
+Version: 0.6
 Summary: Web HTML maker in Python - a light web application framework
 Author-email: Brigitte Bigi <contact@sppas.org>
 License: GNU GENERAL PUBLIC LICENSE
                                Version 3, 29 June 2007
         
          Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
          Everyone is permitted to copy and distribute verbatim copies
@@ -692,36 +692,37 @@
 Requires-Python: >=3.9
 Description-Content-Type: text/markdown
 License-File: LICENSE
 License-File: AUTHORS
 Provides-Extra: docs
 Requires-Dist: pygments ; extra == 'docs'
 Requires-Dist: markdown2 ; extra == 'docs'
-Requires-Dist: Clamming >=1.6 ; extra == 'docs'
+Requires-Dist: ClammingPy >=1.7 ; extra == 'docs'
 Provides-Extra: tests
 Requires-Dist: coverage ~=7.3.0 ; extra == 'tests'
 Requires-Dist: selenium ~=4.18.1 ; extra == 'tests'
 Requires-Dist: python-dotenv ~=1.0.0 ; extra == 'tests'
 
 # WhakerPy - a Web HTML maker in Python
 
 
 ## Overview
 
-WhakerPy is an open source library to create dynamic HTML content; it's a light web application framework.
+WhakerPy is an open source library to create dynamic HTML content and web applications. It's a light web application framework.
 
 Create and manipulate HTML from the power of Python:
 
 * Easy to learn, consistent, simple syntax.
 * Flexible and easy usage.
 * Create HTML pages dynamically.
-* Can save as static files, and/or
-* Run locally with its HTTPD server and response "bakery" system.
+* Can save as static HTML files.
+* Create a web-frontend with its HTTPD response "bakery" system.
+* Run locally with its HTTPD server.
 
-Not enough? Install <https://whakerexa.sf.net> too, an extension for WhakerPy. It includes useful CSS frameworks, JavaScripts, and Python classes for a stylized static or dynamic content.
+Not enough? Install <https://whakerexa.sf.net> too, an extension for WhakerPy. It includes useful CSS frameworks, and JavaScripts for a stylized static or dynamic content.
 
 ## License
 
 WhakerPy is under the terms of the GNU General Public License version 3.
 
 
 ## Install WhakerPy
@@ -738,36 +739,31 @@
 
 ```bash
 > python -m pip install dist/<WhakerPy-xxx.whl>
 ```
 
 ### From its repo:
 
-Download the repository and unpack it, or clone with `git`. Optionally, it can be installed with:
-
-```bash
-> python -m pip install .
-```
-
-Install all the optional dependencies with:
-
-```bash
-> python -m pip install ".[doc, dev, test]"
-```
-
-WhakerPy package includes the following folders and files:
+Download the latest ".zip" and unpack it, or clone the repository with `git`. WhakerPy package includes the following folders and files:
 
 1. "whakerpy": the source code package
-2. "docs": the documentation of whakerpy library in HTML and Markdown
-3. "sample": a webapp sample
+2. "docs": the documentation of `whakerpy` library in HTML and Markdown
+3. "sample": a web application sample 
 4. "tests": the tests of the source code
 
+```bash
+> unzip WhakerPy-0.6.zip 
+> git clone https://git.code.sf.net/p/whakerpy/code whakerpy-code
+> python -m pip install .
+```
 
 ## Quick Start
 
+### Create a dynamic HTML tree
+
 Open a Python interpreter and type or paste the following:
 
 ```python
 >>> from whakerpy.htmlmaker import HTMLTree
 >>> from whakerpy.htmlmaker import HTMLNode
 >>> htree = HTMLTree("index")
 >>> node = HTMLNode(htree.body_main.identifier, None, "h1", value="this is a title")
@@ -817,56 +813,62 @@
 
 ```python
 >>> import webbrowser
 >>> file_whakerpy = htree.serialize_to_file('file.html')
 >>> webbrowser.open_new_tab(file_whakerpy)
 ```
 
-## Create a web application frontend with dynamic HTML content
+### Create a web application frontend with dynamic HTML content
 
 For a quick start, see the file `sample.py` in the repo. It shows a very simple solution to create a server that can handle dynamic content. This content is created from a custom `BaseResponseRecipe()` object, available in the file `samples/response.py`. The response is the interface between a local back-end python application and the web front-end.
 
-For a more complex example of an already in-used web frontend, see: <https://sourceforge.net/p/sppas/code/ci/master/tree/sppas/ui/swapp/app_setup/setupmaker.py>.
+For a more complex example of an already in-used application web frontend, see: <https://sourceforge.net/p/sppas/code/ci/master/tree/sppas/ui/swapp/app_setup/setupmaker.py>.
 
 
 ## Projects using WhakerPy
 
-WhakerPy was initially developed within SPPAS <https://sppas.org>; it was extracted from its original software by the author to lead its own life as standalone package. The "setup" of SPPAS is entirely based on `whakerpy` API.
+WhakerPy was initially developed within SPPAS <https://sppas.org>. It was extracted from its original software by the author to lead its own life as standalone package. The "setup" of SPPAS is entirely based on `whakerpy` API.
 
 Other projects: 
 
 - the website <https://auto-cuedspeech.org> is entirely based on WhakerPy.
 - the website <https://sppas.org> is entirely based on WhakerPy.
 - *contact the author if your project is using WhakerPy*
 
 
 # The developer's corner
 
 ## Create a wheel
 
-WhakerPy is no system dependent. Information to build its wheel are stored into the file `pyproject.toml`. 
-
+WhakerPy is no system dependent. Information to build its wheel are stored into the file `pyproject.toml`.
 The universal wheel is created with: `python -m build`
 
 
-## Make the doc
+## Make the documentation
 
-The API documentation is available in the `doc` folder. Click the file `index.html` to browse throw the documented classes.
+The API documentation is available in the `docs` folder. Click the file `index.html` to browse throw the documented classes.
+The documentation requires Whakerexa <https://whakerexa.sf.net>, which is already available into the "docs" folder of the distributed ".zip" archive of WhakerPy. If not, download and unzip it into the "docs" folder.
 
-To re-generate the doc, install the required external program, then launch the doc generator:
+To re-generate the documentation, install the required external program, then launch the doc generator:
 ```bash
 >python -m pip install ".[docs]"
 >python makedoc.py
 ```
 
 
 ## Test/Analyze source code
 
+Install the optional dependencies with:
+
+```bash
+> python -m pip install ".[tests]"
+```
+
 Code coverage can be analyzed with unittest and coverage. 
-Install them with the command: `python -m pip install ".[test]"`.
+Install them with the command: `python -m pip install ".[tests]"`.
 Then, perform the following steps:
 
 1. `coverage run -m unittest`
 2. `coverage report` to see a summary report into the terminal,
 or use this command to get the result in XML format: `coverage xml`
 
 The whakerpy package can be analyzed with SonarQube by following these steps:
@@ -875,21 +877,22 @@
 2. Download and install SonarQube: `docker pull sonarqube:latest`
 3. Start the SonarQube server: 
    `docker run --stop-timeout 3600 -d --name sonarqube -p 9000:9000 sonarqube:latest`
    Log in to http://localhost:9000. Both login and password are "admin".  
    Add the python plugin and restart server.
 4. Click "Add project" with name "WhakerPy", and provide it a token
 5. Download sonar-scanner client. On macOS its: `brew install sonar-scanner`.
-6. Launch: `sonar-scanner -Dsonar.tokan="paste the token here"`
+6. Launch: `sonar-scanner -Dsonar.token="paste the token here"`
 7. See results in the opened URL. You may not forget that it's an *automatic* code analyzer, 
    not an *intelligent* one.
 
 
-## How to contribute
+## Help / How to contribute
 
-If you plan to contribute to the code, please send an e-mail to the author.
+If you plan to contribute to the code or to report a bug, please send an e-mail to the author.
+Any and all constructive comments are welcome.
 
 
 ## Author/Copyright
 
 Copyright (C) 2023-2024 - [Brigitte Bigi](https://sppas.org/bigi/) - <contact@sppas.org>, 
 Laboratoire Parole et Langage, Aix-en-Provence, France.
```

## Comparing `WhakerPy-0.5.1.dist-info/RECORD` & `WhakerPy-0.6.dist-info/RECORD`

 * *Files 25% similar despite different names*

```diff
@@ -1,31 +1,34 @@
-whakerpy/__init__.py,sha256=y8fkTZ6KGtWKz4ULYPjyVqj_1yKsr2cm5VslES6lPcM,349
+whakerpy/__init__.py,sha256=ZJxGTv-n7g7zZgcR-Q418n_Q98p3Ph3mU0R73lLehEk,347
 whakerpy/messages.py,sha256=N7avfnLzCBEQGTlNuxKYXTEryWtNQdaZYfx2LI00G0A,2595
-whakerpy/htmlmaker/__init__.py,sha256=KQoa6esxMCBq9Kz1OHUYqnkTRkx0kBa9hTiUufN6TCM,4554
+whakerpy/htmlmaker/__init__.py,sha256=lDvkNOU31S2-fkKf3awyvpC4Wjv4rYJ_hwdI_hIRn1k,4612
 whakerpy/htmlmaker/hconsts.py,sha256=8b64cr4iSi2bBkmgxOIPEK8byiPQSv_uJfW0ZXzQfEk,10576
-whakerpy/htmlmaker/hexc.py,sha256=2d7xfy5U-KKLdua5zAAgBEpu2Ffod_lddDyypcLuOJc,5837
-whakerpy/htmlmaker/treeelts.py,sha256=IUis_Nt9QaN91oxpVWMP1VRzf3OLjMW4tMznJS5nLh4,6951
-whakerpy/htmlmaker/treenode.py,sha256=vN9SwBPPHLilIvJvtADR9d8y05i2czKmb4LWSK2hycs,21740
+whakerpy/htmlmaker/hexc.py,sha256=mxnTcwMq49PLVhmgwSjTmTu8qgn-Y1XpzJoW6katvaQ,5835
+whakerpy/htmlmaker/treeelts.py,sha256=km5bfMB_LR5v2VFbr0rmwHcRSXeOXz5ygUsnc0cINkI,7435
+whakerpy/htmlmaker/treeerror.py,sha256=lFDi2rvZHNhHT2rPmMjV3nwXOj4KyPwQkhjueA1-PlU,2319
+whakerpy/htmlmaker/treenode.py,sha256=AgabdDdQNSmaHVcE1b3a421XOhXNWVFu0ke-sE2z4Oo,22554
 whakerpy/htmlmaker/basenodes/__init__.py,sha256=xqPEsrS3c5BnmKYhsWsj2YPkL36HHn8gp0CyJwYD2as,160
 whakerpy/htmlmaker/basenodes/baseelts.py,sha256=mL1XouuEkv18AKoXMl3-kaBwtqpXrvcWCbM8A_GyI3Y,3920
 whakerpy/htmlmaker/basenodes/basenode.py,sha256=_vN0rLYF9FGVgm6RzsMvqS9Dd2dHxGD0PxJxgUvgwQ0,6313
 whakerpy/htmlmaker/emptynodes/__init__.py,sha256=4ExH0MrzRe-ndDFycZR2PDgF0-BxPAdgLP_NwwkmwEQ,314
-whakerpy/htmlmaker/emptynodes/emptyelts.py,sha256=IdPGa0IyyuBd3YDzfAEwO6j3n16Jxh3KZWXe0h5A5w8,4885
-whakerpy/htmlmaker/emptynodes/emptynode.py,sha256=cxypZk1kTmLGgnQIq1cDnCbgSLDIxb2EBjYEqILzx60,9696
+whakerpy/htmlmaker/emptynodes/emptyelts.py,sha256=WnZIJ0gHwGMLauXTxMLo-H-95FUavRdaHhKDeQLyw_Q,4922
+whakerpy/htmlmaker/emptynodes/emptynode.py,sha256=gHwI0E5hCnD_8CEbi-2m7JN0bQ3WOIvuprErsqeXh3Y,9793
 whakerpy/htmlmaker/htmnodes/__init__.py,sha256=weHNOTsIbMpZnq2yH_Ojwhb0IfT7shFl9ZHO9n2h9QM,172
 whakerpy/htmlmaker/htmnodes/htmelts.py,sha256=sMsqNs8nW8b41NK5Oo9CSDTwAyMRxPU4RkZm0DJKSpU,5460
-whakerpy/htmlmaker/htmnodes/htmnode.py,sha256=RkrQN0nkFsGcWRr2sV3gYrFI-05Noci75UxcPavkDfM,11244
-whakerpy/httpd/__init__.py,sha256=qdceGheI8WFQyYlj4MKGBlYa3e968J1OKC6nYg9iT8c,1842
-whakerpy/httpd/handler.py,sha256=95bK69t9O9LOU689mPXSP5KcoLXOO_5RQyWwxHW6NuE,14608
-whakerpy/httpd/hresponse.py,sha256=I0VzyN6_5DJboCi44kssrqU_oruwpKEwWdmzevSiE9A,8450
-whakerpy/httpd/hserver.py,sha256=MLEavbFNvWWWrBasT5ldAy7Pyl_23TNz2ACtujzQReA,4511
-whakerpy/httpd/hstatus.py,sha256=nfz4B87upRU-9T_aitTIvnR9txB_s3TRIq84HYZ0-Iw,7092
-whakerpy/webapp/__init__.py,sha256=lgg2fTws-yv3J11a_hJbXWFyKaZY8Dc493ssT7sF_Ck,205
-whakerpy/webapp/webconfig.py,sha256=U5NrLb5vtHiF8hYmJmhnrMQPzQ38ElZdHAkghHyaMlY,5387
-whakerpy/webapp/weblocalserver.py,sha256=ATTFvozhEyaVZ_N0nnb0C_4LTFZk2RZFun5cEAJdsow,3455
-whakerpy/webapp/webresponse.py,sha256=1QjC0TnKM_WG77VLxKC7ANs_9BNcPLDKq2eLNSEyAv8,4522
-WhakerPy-0.5.1.dist-info/AUTHORS,sha256=VxX-EbiPRiYZzL7ORjFHUn7qcbWI_m6lAQVgJDQtRss,823
-WhakerPy-0.5.1.dist-info/LICENSE,sha256=kUJsoydS2oRQRaa2QmE96oFylIAjYE81DEuZl_BftFw,35149
-WhakerPy-0.5.1.dist-info/METADATA,sha256=oJXQpiFlwebWcuYHl7sBpk_OAZEEulVbxMceOecC010,47438
-WhakerPy-0.5.1.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
-WhakerPy-0.5.1.dist-info/top_level.txt,sha256=WvMtNTB-L1Yyh9XfsWCvu04eZOEefxHQnqGzb-VdTvg,9
-WhakerPy-0.5.1.dist-info/RECORD,,
+whakerpy/htmlmaker/htmnodes/htmnode.py,sha256=j6j77rhGXd_-U9vNiUIz2Ln3eE5Lw4JwZptNb_qHqLw,11479
+whakerpy/httpd/__init__.py,sha256=-9pAiCq3uJptEDBviYNHQE3nu87N2AFURp8G7vdV-Es,1905
+whakerpy/httpd/handler.py,sha256=WmT-U0jM1esyuac3HdV4otPh01W094TCDjsP1TIXr6g,7494
+whakerpy/httpd/hresponse.py,sha256=Z6VfGFDloNQDjq4B2c3OTwkb9N_kYRmS5Zy8f8exkDc,8806
+whakerpy/httpd/hserver.py,sha256=ByxTtZBVw7Iug1Oozs99T607C_D4hFThAdRyHNbkTB8,3869
+whakerpy/httpd/hstatus.py,sha256=KA0ck1ZvLgmGarxD-Pl1xkcCg9EzNDkA9NGqL0t2-CY,7976
+whakerpy/httpd/hutils.py,sha256=S8_jLWejgmfyfhZLxqBRs5vtdccz1NC5xx4Ok7_cEQ8,15628
+whakerpy/webapp/__init__.py,sha256=RHsqs4fjHZMF6RlqzKniZd-seLDC9IZkKJA8nK32jv4,265
+whakerpy/webapp/webconfig.py,sha256=VbjNKzuFOJOsbqkETE4GiBFf8W-gVaYjxmIu25NfeK4,6830
+whakerpy/webapp/weblocalserver.py,sha256=c1n8I74xOiVVjPa9Rsy2JzfE0TjHqxhfqhzuyF7kt7M,3138
+whakerpy/webapp/webresponse.py,sha256=Tq3Qexp1aG-E4hzzngIXzNK53qRkmmuyk87Q-t1HyTE,4626
+whakerpy/webapp/webwsgi.py,sha256=QATZeZC9gU3fTl69BRL6x4574J9VAcQ2wffHCpDu6BE,6909
+WhakerPy-0.6.dist-info/AUTHORS,sha256=VxX-EbiPRiYZzL7ORjFHUn7qcbWI_m6lAQVgJDQtRss,823
+WhakerPy-0.6.dist-info/LICENSE,sha256=kUJsoydS2oRQRaa2QmE96oFylIAjYE81DEuZl_BftFw,35149
+WhakerPy-0.6.dist-info/METADATA,sha256=lFhUiUIKDkapTsWFmce_CGjEvS1nI3scJ_ggF3Z6BFk,47900
+WhakerPy-0.6.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+WhakerPy-0.6.dist-info/top_level.txt,sha256=WvMtNTB-L1Yyh9XfsWCvu04eZOEefxHQnqGzb-VdTvg,9
+WhakerPy-0.6.dist-info/RECORD,,
```

