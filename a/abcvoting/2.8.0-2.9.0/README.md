# Comparing `tmp/abcvoting-2.8.0-py3-none-any.whl.zip` & `tmp/abcvoting-2.9.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,19 +1,19 @@
-Zip file size: 69951 bytes, number of entries: 17
--rw-r--r--  2.0 unx        0 b- defN 23-Jul-04 13:59 abcvoting/__init__.py
--rw-r--r--  2.0 unx   163258 b- defN 23-Jul-04 13:59 abcvoting/abcrules.py
--rw-r--r--  2.0 unx    29677 b- defN 23-Jul-04 13:59 abcvoting/abcrules_gurobi.py
--rw-r--r--  2.0 unx    18059 b- defN 23-Jul-04 13:59 abcvoting/abcrules_mip.py
--rw-r--r--  2.0 unx     9643 b- defN 23-Jul-04 13:59 abcvoting/abcrules_ortools.py
--rw-r--r--  2.0 unx    14376 b- defN 23-Jul-04 13:59 abcvoting/fileio.py
--rw-r--r--  2.0 unx    38434 b- defN 23-Jul-04 13:59 abcvoting/generate.py
--rw-r--r--  2.0 unx    12941 b- defN 23-Jul-04 13:59 abcvoting/misc.py
--rw-r--r--  2.0 unx     6151 b- defN 23-Jul-04 13:59 abcvoting/output.py
--rw-r--r--  2.0 unx    11253 b- defN 23-Jul-04 13:59 abcvoting/preferences.py
--rw-r--r--  2.0 unx    60809 b- defN 23-Jul-04 13:59 abcvoting/properties.py
--rw-r--r--  2.0 unx    14692 b- defN 23-Jul-04 13:59 abcvoting/scores.py
--rw-r--r--  2.0 unx     1071 b- defN 23-Jul-04 13:59 abcvoting-2.8.0.dist-info/LICENSE
--rw-r--r--  2.0 unx     7783 b- defN 23-Jul-04 13:59 abcvoting-2.8.0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Jul-04 13:59 abcvoting-2.8.0.dist-info/WHEEL
--rw-r--r--  2.0 unx       10 b- defN 23-Jul-04 13:59 abcvoting-2.8.0.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     1353 b- defN 23-Jul-04 13:59 abcvoting-2.8.0.dist-info/RECORD
-17 files, 389602 bytes uncompressed, 67767 bytes compressed:  82.6%
+Zip file size: 68675 bytes, number of entries: 17
+-rw-r--r--  2.0 unx        0 b- defN 24-Apr-03 08:55 abcvoting/__init__.py
+-rw-r--r--  2.0 unx   163258 b- defN 24-Apr-03 08:55 abcvoting/abcrules.py
+-rw-r--r--  2.0 unx    29656 b- defN 24-Apr-03 08:55 abcvoting/abcrules_gurobi.py
+-rw-r--r--  2.0 unx    18059 b- defN 24-Apr-03 08:55 abcvoting/abcrules_mip.py
+-rw-r--r--  2.0 unx     9643 b- defN 24-Apr-03 08:55 abcvoting/abcrules_ortools.py
+-rw-r--r--  2.0 unx    14382 b- defN 24-Apr-03 08:55 abcvoting/fileio.py
+-rw-r--r--  2.0 unx    33578 b- defN 24-Apr-03 08:55 abcvoting/generate.py
+-rw-r--r--  2.0 unx    12941 b- defN 24-Apr-03 08:55 abcvoting/misc.py
+-rw-r--r--  2.0 unx     6151 b- defN 24-Apr-03 08:55 abcvoting/output.py
+-rw-r--r--  2.0 unx    11253 b- defN 24-Apr-03 08:55 abcvoting/preferences.py
+-rw-r--r--  2.0 unx    60753 b- defN 24-Apr-03 08:55 abcvoting/properties.py
+-rw-r--r--  2.0 unx    14692 b- defN 24-Apr-03 08:55 abcvoting/scores.py
+-rw-r--r--  2.0 unx     1071 b- defN 24-Apr-03 08:55 abcvoting-2.9.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     7992 b- defN 24-Apr-03 08:55 abcvoting-2.9.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-Apr-03 08:55 abcvoting-2.9.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       10 b- defN 24-Apr-03 08:55 abcvoting-2.9.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     1353 b- defN 24-Apr-03 08:55 abcvoting-2.9.0.dist-info/RECORD
+17 files, 384884 bytes uncompressed, 66491 bytes compressed:  82.7%
```

## zipnote {}

```diff
@@ -30,23 +30,23 @@
 
 Filename: abcvoting/properties.py
 Comment: 
 
 Filename: abcvoting/scores.py
 Comment: 
 
-Filename: abcvoting-2.8.0.dist-info/LICENSE
+Filename: abcvoting-2.9.0.dist-info/LICENSE
 Comment: 
 
-Filename: abcvoting-2.8.0.dist-info/METADATA
+Filename: abcvoting-2.9.0.dist-info/METADATA
 Comment: 
 
-Filename: abcvoting-2.8.0.dist-info/WHEEL
+Filename: abcvoting-2.9.0.dist-info/WHEEL
 Comment: 
 
-Filename: abcvoting-2.8.0.dist-info/top_level.txt
+Filename: abcvoting-2.9.0.dist-info/top_level.txt
 Comment: 
 
-Filename: abcvoting-2.8.0.dist-info/RECORD
+Filename: abcvoting-2.9.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## abcvoting/abcrules_gurobi.py

```diff
@@ -165,15 +165,15 @@
         for i, voter in enumerate(profile):
             # maximum number of approved candidates that this voter can have in a committee
             max_in_committee[voter] = min(len(voter.approved), committeesize)
             for x in range(1, max_in_committee[voter] + 1):
                 utility[(voter, x)] = model.addVar(vtype=gb.GRB.BINARY, name=f"utility({i,x})")
 
         # constraint: the committee has the required size
-        model.addConstr(gb.quicksum(in_committee) == committeesize)
+        model.addConstr(in_committee.sum() == committeesize)
 
         # constraint: utilities are consistent with actual committee
         for voter in profile:
             model.addConstr(
                 gb.quicksum(utility[voter, x] for x in range(1, max_in_committee[voter] + 1))
                 == gb.quicksum(in_committee[cand] for cand in voter.approved)
             )
@@ -230,15 +230,15 @@
         for i, voter in enumerate(profile):
             # maximum number of approved candidates that this voter can have in a committee
             max_in_committee[voter] = min(len(voter.approved), committeesize)
             for x in range(1, max_in_committee[voter] + 1):
                 utility[(voter, x)] = model.addVar(vtype=gb.GRB.BINARY, name=f"utility({i, x})")
 
         # constraint: the committee has the required size
-        model.addConstr(gb.quicksum(in_committee) == committeesize)
+        model.addConstr(in_committee.sum() == committeesize)
 
         # constraint: utilities are consistent with actual committee
         for voter in profile:
             model.addConstr(
                 gb.quicksum(utility[voter, x] for x in range(1, max_in_committee[voter] + 1))
                 == gb.quicksum(in_committee[cand] for cand in voter.approved)
             )
@@ -659,15 +659,15 @@
                     # distances are always <= len(voter.approved) + committeesize
                     voteratmostdistances[(i, dist)] = 1
                 if dist < abs(len(voter.approved) - committeesize):
                     # distances are never < abs(len(voter.approved) - committeesize)
                     voteratmostdistances[(i, dist)] = 0
 
         # constraint: the committee has the required size
-        model.addConstr(gb.quicksum(in_committee) == committeesize)
+        model.addConstr(in_committee.sum() == committeesize)
 
         # constraint: distances are consistent with actual committee
         for i, voter in enumerate(profile):
             not_approved = [cand for cand in profile.candidates if cand not in voter.approved]
             for dist in range(profile.num_cand + 1):
                 if isinstance(voteratmostdistances[(i, dist)], int):
                     # trivially satisfied
```

## abcvoting/fileio.py

```diff
@@ -1,12 +1,12 @@
 """
 Read and write data to files.
 
 Two data formats are supported:
-1. the Preflib format (soi, toi, soc or toc), and
+1. the Preflib format (soi, toi, soc, toc, or cat), and
 2. .abc.yaml files (more expressive than Preflib files).
 """
 
 import os
 import ruamel.yaml
 import preflibtools.instances as preflib
 from abcvoting.preferences import Profile, Voter
```

## abcvoting/generate.py

```diff
@@ -1,22 +1,46 @@
 """
 Random generation of approval profiles.
 
-This module is based on the paper
-    *How to Sample Approval Elections?*
-    Stanisław Szufa, Piotr Faliszewski, Łukasz Janeczko, Martin Lackner, Arkadii Slinko,
-    Krzysztof Sornat, Nimrod Talmon.
-    https://arxiv.org/abs/2207.01140
+This module is based on the paper on the package
+`prefsampling <https://github.com/COMSOC-Community/prefsampling>`_.
 """
 
-import math
 import numpy as np
+import prefsampling.approval as app_samplers
+import prefsampling.ordinal as ord_samplers
+import prefsampling.point as point_samplers
+from prefsampling.core.euclidean import (
+    sample_election_positions as prefsampling_sample_election_positions,
+)
 from numpy.random import default_rng
-from abcvoting.preferences import Profile
-from abcvoting import misc
+from abcvoting.preferences import Profile, Voter
+
+
+def prefsampling_wrapper(sampler, sampler_params):
+    """
+    Wrapper for prefsampling functions to map the outcome of the samplers to an abcvoting profile.
+
+    Parameters
+    ----------
+        sampler : Callable
+            The prefsampling function.
+        sampler_params : dict
+            The arguments passed to the sampler, all are passed as kwargs.
+
+    Returns
+    -------
+        abcvoting.preferences.Profile
+    """
+    samples = sampler(**sampler_params)
+    num_candidates = sampler_params["num_candidates"]
+    profile = Profile(num_candidates)
+    for sample in samples:
+        profile.add_voter(Voter(sample, num_cand=num_candidates))
+    return profile
 
 
 def random_profile(num_voters, num_cand, prob_distribution):
     """
     Generate a random profile using the probability distribution `prob_distribution`.
 
     The following probability distributions are supported:
@@ -95,43 +119,24 @@
             normalization. Specifically, `replace` *  (`num_cand` choose `setsize`) are added
             in each iteration.
 
     Returns
     -------
         abcvoting.preferences.Profile
     """
-    currsize = 1.0
-    approval_sets = []
-    replacedsets = {}
-
-    for _ in range(num_voters):
-        r = rng.random() * currsize
-        if r < 1.0:
-            # base case: sample uniformly at random
-            randset = list(range(num_cand))
-            rng.shuffle(randset)
-            randset = randset[:setsize]
-            approval_sets.append(randset)
-            key = tuple(set(randset))
-            if key in replacedsets:
-                replacedsets[key] += 1
-            else:
-                replacedsets[key] = 1
-            currsize += replace
-        else:
-            # sample from one of the replaced ballots
-            r = rng.integers(0, sum(replacedsets.values()))
-            for approval_set, count in replacedsets.items():
-                if r <= count:
-                    approval_sets.append(list(approval_set))
-                    break
-                r -= count
-    profile = Profile(num_cand)
-    profile.add_voters(approval_sets)
-    return profile
+
+    return prefsampling_wrapper(
+        app_samplers.urn_constant_size,
+        {
+            "num_voters": num_voters,
+            "num_candidates": num_cand,
+            "rel_num_approvals": setsize / num_cand,
+            "alpha": replace,
+        },
+    )
 
 
 def random_ic_fixed_size_profile(num_voters, num_cand, setsize):
     """
     Generate a random profile using the *IC with fixed-size approval sets* distribution.
 
     Parameters
@@ -145,32 +150,28 @@
         setsize : int
             Number of candidates that each voter approves.
 
     Returns
     -------
         abcvoting.preferences.Profile
     """
-    approval_sets = []
-    for _ in range(num_voters):
-        randset = list(range(num_cand))
-        rng.shuffle(randset)
-        randset = randset[:setsize]
-        approval_sets.append(randset)
-    profile = Profile(num_cand)
-    profile.add_voters(approval_sets)
-    return profile
+    return prefsampling_wrapper(
+        app_samplers.impartial_constant_size,
+        {
+            "num_voters": num_voters,
+            "num_candidates": num_cand,
+            "rel_num_approvals": setsize / num_cand,
+        },
+    )
 
 
 def random_mallows_profile(num_voters, num_cand, setsize, dispersion):
     """
     Generate a random profile using the *Truncated Mallows* probability distribution.
 
-    Based on the definition for the repeated insertion model (RIM) in
-    https://icml.cc/2011/papers/135_icmlpaper.pdf
-
     Parameters
     ----------
         num_voters : int
             The desired number of voters in the profile.
 
         num_cand : int
             The desired number of candidates in the profile.
@@ -182,62 +183,24 @@
             Dispersion parameter of the Mallows model.
 
     Returns
     -------
         abcvoting.preferences.Profile
     """
 
-    def _select_pos(distribution):
-        """Returns a randomly selected value with the help of the distribution."""
-        if round(sum(distribution), 10) != 1.0:
-            raise Exception("Invalid Distribution", distribution, "sum:", sum(distribution))
-        r = round(rng.random(), 10)  # or random.uniform(0, 1)
-        pos = -1
-        s = 0
-        for p in distribution:
-            pos += 1
-            s += p
-            if s >= r:
-                return pos
-
-        return pos  # in case of rounding errors
-
-    if not 0 < dispersion <= 1:
-        raise Exception("Invalid dispersion, needs to be in (0, 1].")
-    reference_ranking = list(range(num_cand))
-    rng.shuffle(reference_ranking)
-    insert_dist = _compute_mallows_insert_distributions(num_cand, dispersion)
-    approval_sets = []
-    for _ in range(num_voters):
-        vote = []
-        for i, distribution in enumerate(insert_dist):
-            pos = _select_pos(distribution)
-            vote.insert(pos, reference_ranking[i])
-
-        approval_sets.append(vote[:setsize])
-    profile = Profile(num_cand)
-    profile.add_voters(approval_sets)
-    return profile
-
-
-def _compute_mallows_insert_distributions(num_cand, dispersion):
-    """
-    Compute the insertion probability vectors for the dispersion and a given number of candidates.
-    """
-    distributions = []
-    denominator = 0
-    for i in range(num_cand):
-        # compute the denominator = dispersion^0 + dispersion^1
-        # + ... dispersion^(i-1)
-        denominator += pow(dispersion, i)
-        dist = []
-        for j in range(i + 1):  # 0..i
-            dist.append(pow(dispersion, i - j) / denominator)
-        distributions.append(dist)
-    return distributions
+    return prefsampling_wrapper(
+        app_samplers.truncated_ordinal,
+        {
+            "num_voters": num_voters,
+            "num_candidates": num_cand,
+            "rel_num_approvals": setsize / num_cand,
+            "ordinal_sampler": ord_samplers.mallows,
+            "ordinal_sampler_parameters": {"phi": dispersion},
+        },
+    )
 
 
 # Impartial Culture
 def random_ic_profile(num_voters, num_cand, p=0.5):
     """
     Generate a random profile using the *Independent Culture (IC)* probability distribution.
 
@@ -261,38 +224,17 @@
     Corresponds to *p-IC* in:
 
     *How to Sample Approval Elections?*
     Stanisław Szufa, Piotr Faliszewski, Łukasz Janeczko, Martin Lackner, Arkadii Slinko,
     Krzysztof Sornat, Nimrod Talmon.
     https://arxiv.org/abs/2207.01140
     """
-    approval_sets = [set() for _ in range(num_voters)]
-    for i in range(num_voters):
-        for j in range(num_cand):
-            if rng.random() <= p:
-                approval_sets[i].add(j)
-    profile = Profile(num_cand)
-    profile.add_voters(approval_sets)
-    return profile
-
-
-def _ordinal_urn_profile(num_voters, num_cand, replace):
-    """
-    Generate rankings according to the Urn probability distribution.
-    """
-    rankings = []
-    urn_size = 1.0
-    for j in range(num_voters):
-        rho = rng.uniform(0, urn_size)
-        if rho <= 1.0:
-            rankings.append(rng.permutation(num_cand))
-        else:
-            rankings.append(rankings[rng.integers(0, j)])
-        urn_size += replace
-    return rankings
+    return prefsampling_wrapper(
+        app_samplers.impartial, {"num_voters": num_voters, "num_candidates": num_cand, "p": p}
+    )
 
 
 def random_urn_profile(num_voters, num_cand, p, replace):
     """
     Generate a random profile using the *Polya Urn* probability distribution.
 
     Parameters
@@ -313,30 +255,19 @@
             the ballot of the first iteration is chosen and a chance of 0.5 that a new ballot is
             drawn from p-IC.
 
     Returns
     -------
         abcvoting.preferences.Profile
     """
-    approval_sets = []
-    urn_size = 1.0
-    for j in range(num_voters):
-        rho = rng.uniform(0, urn_size)
-        if rho <= 1.0:
-            vote = set()
-            for c in range(num_cand):
-                if rng.random() <= p:
-                    vote.add(c)
-            approval_sets.append(vote)
-        else:
-            approval_sets.append(approval_sets[rng.integers(0, j)])
-        urn_size += replace
-    profile = Profile(num_cand)
-    profile.add_voters(approval_sets)
-    return profile
+
+    return prefsampling_wrapper(
+        app_samplers.urn,
+        {"num_voters": num_voters, "num_candidates": num_cand, "p": p, "alpha": replace},
+    )
 
 
 def random_truncated_urn_profile(num_voters, num_cand, setsize, replace):
     """
     Generate a random profile using the *Truncated Polya Urn* probability distribution.
 
     Parameters
@@ -366,21 +297,25 @@
     References
     ----------
     *How to Sample Approval Elections?*
     Stanisław Szufa, Piotr Faliszewski, Łukasz Janeczko, Martin Lackner, Arkadii Slinko,
     Krzysztof Sornat, Nimrod Talmon.
     https://arxiv.org/abs/2207.01140
     """
-    ordinal_votes = _ordinal_urn_profile(num_voters, num_cand, replace)
-    approval_sets = []
-    for v in range(num_voters):
-        approval_sets.append(set(ordinal_votes[v][:setsize]))
-    profile = Profile(num_cand)
-    profile.add_voters(approval_sets)
-    return profile
+
+    return prefsampling_wrapper(
+        app_samplers.truncated_ordinal,
+        {
+            "num_voters": num_voters,
+            "num_candidates": num_cand,
+            "rel_num_approvals": setsize / num_cand,
+            "ordinal_sampler": ord_samplers.urn,
+            "ordinal_sampler_parameters": {"alpha": replace},
+        },
+    )
 
 
 # Resampling
 def random_resampling_profile(num_voters, num_cand, p, phi):
     """
     Generate a random profile using the *Resampling* probability distribution.
 
@@ -413,31 +348,18 @@
     References
     ----------
     *How to Sample Approval Elections?*
     Stanisław Szufa, Piotr Faliszewski, Łukasz Janeczko, Martin Lackner, Arkadii Slinko,
     Krzysztof Sornat, Nimrod Talmon.
     https://arxiv.org/abs/2207.01140
     """
-    k = int(p * num_cand)
-    central_vote = set(range(k))
-
-    approval_sets = [set() for _ in range(num_voters)]
-    for v in range(num_voters):
-        vote = set()
-        for c in range(num_cand):
-            if rng.random() < phi:
-                if rng.random() < p:
-                    vote.add(c)
-            else:
-                if c in central_vote:
-                    vote.add(c)
-        approval_sets[v] = vote
-    profile = Profile(num_cand)
-    profile.add_voters(approval_sets)
-    return profile
+    return prefsampling_wrapper(
+        app_samplers.resampling,
+        {"num_voters": num_voters, "num_candidates": num_cand, "phi": phi, "p": p},
+    )
 
 
 def random_disjoint_resampling_profile(num_voters, num_cand, p, phi=None, num_groups=2):
     """
     Generate a random profile using the *(p,phi,g)-Disjoint Resampling* probability distribution.
 
     Parameters
@@ -476,44 +398,27 @@
     ----------
     *How to Sample Approval Elections?*
     Stanisław Szufa, Piotr Faliszewski, Łukasz Janeczko, Martin Lackner, Arkadii Slinko,
     Krzysztof Sornat, Nimrod Talmon.
     https://arxiv.org/abs/2207.01140
     """
 
-    def _uniform_in_simplex(n):
-        """Return uniformly random vector in the n-simplex."""
-        k = rng.exponential(scale=1.0, size=n)
-        return k / sum(k)
-
     if phi is None:
         phi = rng.random()
-    k = int(p * num_cand)
-
-    sizes = _uniform_in_simplex(num_groups)
-    sizes = np.cumsum(np.concatenate(([0], sizes)))
-
-    approval_sets = [set() for _ in range(num_voters)]
 
-    for g in range(num_groups):
-        central_vote = {g * k + i for i in range(k)}
-
-        for v in range(int(sizes[g] * num_voters), int(sizes[g + 1] * num_voters)):
-            vote = set()
-            for c in range(num_cand):
-                if rng.random() <= phi:
-                    if rng.random() <= p:
-                        vote.add(c)
-                else:
-                    if c in central_vote:
-                        vote.add(c)
-            approval_sets[v] = vote
-    profile = Profile(num_cand)
-    profile.add_voters(approval_sets)
-    return profile
+    return prefsampling_wrapper(
+        app_samplers.disjoint_resampling,
+        {
+            "num_voters": num_voters,
+            "num_candidates": num_cand,
+            "phi": phi,
+            "p": p,
+            "g": num_groups,
+        },
+    )
 
 
 def random_noise_model_profile(num_voters, num_cand, p, phi, distance="hamming"):
     """
     Generate a random profile using the *Random Noise* probability distribution.
 
     Parameters
@@ -551,56 +456,119 @@
     References
     ----------
     *How to Sample Approval Elections?*
     Stanisław Szufa, Piotr Faliszewski, Łukasz Janeczko, Martin Lackner, Arkadii Slinko,
     Krzysztof Sornat, Nimrod Talmon.
     https://arxiv.org/abs/2207.01140
     """
-    k = int(p * num_cand)
-    set_a = set(range(k))
-    set_b = set(range(num_cand)) - set_a
-
-    choices = []
-    probabilites = []
-
-    # PREPARE BUCKETS
-    for x in range(len(set_a) + 1):
-        num_options_in = misc.binom(len(set_a), x)
-        for y in range(len(set_b) + 1):
-            num_options_out = misc.binom(len(set_b), y)
-
-            if distance == "hamming":
-                factor = phi ** (len(set_a) - x + y)  # Hamming
-            elif distance == "jaccard":
-                factor = phi ** ((len(set_a) - x + y) / (len(set_a) + y))  # Jaccard
-            elif distance == "zelinka":
-                factor = phi ** max(len(set_a) - x, y)  # Zelinka
-            elif distance == "bunke-shearer":
-                factor = phi ** (max(len(set_a) - x, y) / max(len(set_a), x + y))  # Bunke-Shearer
-            else:
-                raise ValueError(f"Distance {distance} not known.")
 
-            num_options = num_options_in * num_options_out * factor
+    if distance == "hamming":
+        noise_type = app_samplers.NoiseType.HAMMING
+    elif distance == "jaccard":
+        noise_type = app_samplers.NoiseType.JACCARD
+    elif distance == "zelinka":
+        noise_type = app_samplers.NoiseType.ZELINKA
+    elif distance == "bunke-shearer":
+        noise_type = app_samplers.NoiseType.BUNKE_SHEARER
+    else:
+        raise ValueError(f"unknown name of distance: {distance}")
+    return prefsampling_wrapper(
+        app_samplers.noise,
+        {
+            "num_voters": num_voters,
+            "num_candidates": num_cand,
+            "phi": phi,
+            "p": p,
+            "noise_type": noise_type,
+        },
+    )
+
+
+def prefsampling_euclidean_wrapper(
+    num_voters,
+    num_cand,
+    voter_prob_distribution,
+    candidate_prob_distribution,
+    voter_points,
+    candidate_points,
+    return_points,
+    sampler,
+    sampler_params,
+):
+    """
+    Wrapper for prefsampling functions.
+
+    Maps the outcome of the samplers to an abcvoting profile.
+    This is specific to the Euclidean samplers.
+
+    Parameters
+    ----------
+        num_voters : int
+            The desired number of voters in the profile.
+
+        num_cand : int
+            The desired number of candidates in the profile.
+
+        voter_prob_distribution : PointProbabilityDistribution or None
+            A probability distribution used to generate voter points.
+
+        candidate_prob_distribution : PointProbabilityDistribution or None
+            A probability distribution used to generate candidate points.
+
+        voter_points : iterable
+            A list of points.
+
+            The length of this list must be `num_voters`. The dimension of the points must be
+            the same as the points in `candiddate_points` or as specified by
+            `candidate_prob_distribution`. This parameter is only used if `voter_prob_distribution`
+            is `None`.
+
+        candidate_points : iterable
+            A list of points.
+
+            The length of this list must be `num_cand`. The dimension of the points must be
+            the same as the points in `voter_points` or as specified by `voter_prob_distribution`.
+            This parameter is only used if `candidate_prob_distribution` is `None`.
+
+        return_points : bool, optional
+            If true, also return the list of voter points and a list of candidate points.
+
+        sampler : Callable
+            The prefsampling function.
 
-            choices.append((x, y))
-            probabilites.append(num_options)
+        sampler_params : dict
+            The arguments passed to the sampler, all arguments are passed as kwargs.
 
-    denominator = sum(probabilites)
-    probabilites = [p / denominator for p in probabilites]
-
-    # SAMPLE VOTES
-    approval_sets = []
-    for _ in range(num_voters):
-        _id = rng.choice(range(len(choices)), 1, p=probabilites)[0]
-        x, y = choices[_id]
-        vote = set(rng.choice(list(set_a), x, replace=False))
-        vote = vote.union(set(rng.choice(list(set_b), y, replace=False)))
-        approval_sets.append(vote)
-    profile = Profile(num_cand)
-    profile.add_voters(approval_sets)
+    Returns
+    -------
+        abcvoting.preferences.Profile | tuple[abcvoting.preferences.Profile,np.ndarray,np.ndarray]
+    """
+    voter_prob_distribution_func = None
+    if voter_prob_distribution is not None:
+        voter_prob_distribution_func = voter_prob_distribution.prefsampling_function()
+    candidate_prob_distribution_func = None
+    if candidate_prob_distribution is not None:
+        candidate_prob_distribution_func = candidate_prob_distribution.prefsampling_function()
+    voters_pos, candidates_pos = prefsampling_sample_election_positions(
+        num_voters,
+        num_cand,
+        voter_prob_distribution_func,
+        dict(),
+        candidate_prob_distribution_func,
+        dict(),
+        voter_points,
+        candidate_points,
+    )
+    sampler_params["num_voters"] = num_voters
+    sampler_params["num_candidates"] = num_cand
+    sampler_params["voters_positions"] = voters_pos
+    sampler_params["candidates_positions"] = candidates_pos
+    profile = prefsampling_wrapper(sampler, sampler_params)
+    if return_points:
+        return profile, voters_pos, candidates_pos
     return profile
 
 
 def random_euclidean_fixed_size_profile(
     num_voters,
     num_cand,
     voter_prob_distribution,
@@ -648,38 +616,25 @@
         return_points : bool, optional
             If true, also return the list of voter points and a list of candidate points.
 
     Returns
     -------
         abcvoting.preferences.Profile
     """
-
-    voter_points, candidate_points = _voter_and_candidate_points(
+    return prefsampling_euclidean_wrapper(
         num_voters,
         num_cand,
         voter_prob_distribution,
         candidate_prob_distribution,
         voter_points,
         candidate_points,
+        return_points,
+        app_samplers.euclidean_constant_size,
+        {"rel_num_approvals": setsize / num_cand},
     )
-    profile = Profile(num_cand)
-    approval_sets = []
-    for voterpoint in voter_points:
-        distances = {
-            cand: np.linalg.norm(voterpoint - candidate_points[cand])
-            for cand in profile.candidates
-        }
-        cands_sorted = sorted(distances, key=distances.get)
-        approval_sets.append(cands_sorted[:setsize])
-    profile.add_voters(approval_sets)
-
-    if return_points:
-        return profile, voter_points, candidate_points
-
-    return profile
 
 
 def random_euclidean_threshold_profile(
     num_voters,
     num_cand,
     voter_prob_distribution,
     candidate_prob_distribution,
@@ -704,24 +659,24 @@
 
         candidate_prob_distribution : PointProbabilityDistribution or None
             A probability distribution used to generate candidate points.
 
         threshold : float
             Voters' tolerance for approving candidates. This is a float >= 1.
 
-            A voter approves all candididates that have at a distance of at most `threshold` * `d`,
+            A voter approves all candidates that have at a distance of at most `threshold` * `d`,
             where `d` is the minimum distance between this voter and any candidate.
             Setting `threshold` to 1 means that only the closest candidate is approved (there
             might be more than one).
 
         voter_points : iterable
             A list of points.
 
             The length of this list must be `num_voters`. The dimension of the points must be
-            the same as the points in `candiddate_points` or as specified by
+            the same as the points in `candidate_points` or as specified by
             `candidate_prob_distribution`. This parameter is only used if `voter_prob_distribution`
             is `None`.
 
         candidate_points : iterable
             A list of points.
 
             The length of this list must be `num_cand`. The dimension of the points must be
@@ -731,45 +686,26 @@
         return_points : bool, optional
             If true, also return the list of voter points and a list of candidate points.
 
     Returns
     -------
         abcvoting.preferences.Profile
     """
-
-    if threshold < 1:
-        raise ValueError("threshold must be >= 1.")
-
-    voter_points, candidate_points = _voter_and_candidate_points(
+    return prefsampling_euclidean_wrapper(
         num_voters,
         num_cand,
         voter_prob_distribution,
         candidate_prob_distribution,
         voter_points,
         candidate_points,
+        return_points,
+        app_samplers.euclidean_threshold,
+        {"threshold": threshold},
     )
 
-    profile = Profile(num_cand)
-    approval_sets = []
-    for voterpoint in voter_points:
-        distances = {
-            cand: np.linalg.norm(voterpoint - candidate_points[cand])
-            for cand in profile.candidates
-        }
-        mindist = min(distances.values())
-        approval_sets.append(
-            [cand for cand in profile.candidates if distances[cand] <= mindist * threshold]
-        )
-    profile.add_voters(approval_sets)
-
-    if return_points:
-        return profile, voter_points, candidate_points
-
-    return profile
-
 
 def random_euclidean_vcr_profile(
     num_voters,
     num_cand,
     voter_prob_distribution,
     candidate_prob_distribution,
     voter_radius,
@@ -831,87 +767,26 @@
     References
     ----------
     *How to Sample Approval Elections?*
     Stanisław Szufa, Piotr Faliszewski, Łukasz Janeczko, Martin Lackner, Arkadii Slinko,
     Krzysztof Sornat, Nimrod Talmon.
     https://arxiv.org/abs/2207.01140
     """
-    voter_points, candidate_points = _voter_and_candidate_points(
+
+    return prefsampling_euclidean_wrapper(
         num_voters,
         num_cand,
         voter_prob_distribution,
         candidate_prob_distribution,
         voter_points,
         candidate_points,
+        return_points,
+        app_samplers.euclidean_vcr,
+        {"voters_radius": voter_radius, "candidates_radius": candidate_radius},
     )
-    try:
-        if len(voter_radius) != num_voters:
-            raise ValueError("Length of `voter_radius` must be equal to `num_voters`.")
-        voter_range = voter_radius
-    except TypeError:
-        voter_range = np.array([voter_radius for _ in range(num_voters)])
-    try:
-        if len(candidate_radius) != num_cand:
-            raise ValueError("Length of `candidate_radius` must be equal to `num_cand`.")
-        cand_range = candidate_radius
-    except TypeError:
-        cand_range = np.array([candidate_radius for _ in range(num_cand)])
-
-    approval_sets = [set() for _ in range(num_voters)]
-    for v in range(num_voters):
-        for c in range(num_cand):
-            if voter_range[v] + cand_range[c] >= np.linalg.norm(
-                voter_points[v] - candidate_points[c]
-            ):
-                approval_sets[v].add(c)
-    profile = Profile(num_cand)
-    profile.add_voters(approval_sets)
-
-    if return_points:
-        return profile, voter_points, candidate_points
-
-    return profile
-
-
-def _voter_and_candidate_points(
-    num_voters,
-    num_cand,
-    voter_prob_distribution,
-    candidate_prob_distribution,
-    voter_points,
-    candidate_points,
-):
-    if voter_prob_distribution is not None:
-        voter_points = np.array([random_point(voter_prob_distribution) for _ in range(num_voters)])
-        voter_dimension = voter_prob_distribution.dimension
-    else:
-        voter_dimension = {len(p) for p in voter_points}
-        if len(voter_dimension) != 1:
-            raise ValueError("Voter points have different dimensions.")
-        voter_points = np.array(voter_points)
-        if len(voter_points) != num_voters:
-            raise ValueError("Length of `voters` is not the same as `num_voters`.")
-        voter_dimension = min(voter_dimension)
-    if candidate_prob_distribution is not None:
-        candidate_points = np.array(
-            [random_point(candidate_prob_distribution) for _ in range(num_cand)]
-        )
-        candidate_dimension = candidate_prob_distribution.dimension
-    else:
-        candidate_dimension = {len(p) for p in candidate_points}
-        if len(candidate_dimension) != 1:
-            raise ValueError("Candidate points have different dimensions.")
-        candidate_points = np.array(candidate_points)
-        if len(candidate_points) != num_cand:
-            raise ValueError("Length of `candidates` is not the same as `num_cand`.")
-        candidate_dimension = min(candidate_dimension)
-    if voter_dimension != candidate_dimension:
-        raise ValueError("Voter points and candidate points have a different dimension.")
-
-    return voter_points, candidate_points
 
 
 class PointProbabilityDistribution:
     r"""
     Class for specifying a probability distribution generating points.
 
     Parameters
@@ -979,15 +854,16 @@
         for dist in distributions:
             if dist.name.startswith("2d"):
                 for _ in range(1000):
                     points.append(generate.random_point(dist))
                 title_coord = [dist.center_point[0], dist.center_point[1] + 0.6]
             else:
                 for _ in range(100):
-                    points.append([generate.random_point(dist), 0])
+                    point = generate.random_point(dist)
+                    points.append(np.array([point[0], 0]))
                 title_coord = [dist.center_point[0], 0.2]
             title = dist.name + "\n"
             if dist.width != 1.0:
                 title += f"(width={dist.width})"
             plt.annotate(title, title_coord, ha="center")
 
         ax.scatter([x for x, y in points], [y for x, y in points], alpha=0.5, s=5)
@@ -1008,80 +884,82 @@
         except ValueError as error:
             raise ValueError(
                 f"Could not extract dimension from probability distribution {name}."
             ) from error
 
         try:
             len(center_point)
-            self.center_point = np.array(center_point)
+            self.center_point = np.array(center_point, dtype=float)
             if len(self.center_point) != self.dimension:
                 raise ValueError("Center point has a wrong dimension.")
         except TypeError:
-            self.center_point = np.array([center_point] * self.dimension)
+            self.center_point = np.array([center_point] * self.dimension, dtype=float)
+
+    def prefsampling_function(self):
+        if self.name == "1d_interval":
+            return lambda num_points: point_samplers.cube(
+                num_points, 1, center_point=self.center_point, widths=self.width
+            )
+        elif self.name == "1d_gaussian":
+            return lambda num_points: point_samplers.gaussian(
+                num_points, 1, center_point=self.center_point, sigmas=self.sigma
+            )
+        elif self.name == "1d_gaussian_interval":
+            return lambda num_points: point_samplers.gaussian(
+                num_points,
+                1,
+                center_point=self.center_point,
+                sigmas=self.sigma,
+                widths=[self.width],
+            )
+        elif self.name == "2d_disc":
+            return lambda num_points: point_samplers.ball_uniform(
+                num_points, 2, center_point=self.center_point, widths=self.width
+            )
+        elif self.name == "2d_square":
+            return lambda num_points: point_samplers.cube(
+                num_points, 2, center_point=self.center_point, widths=self.width
+            )
+        elif self.name == "2d_gaussian":
+            return lambda num_points: point_samplers.gaussian(
+                num_points, 2, center_point=self.center_point, sigmas=self.sigma
+            )
+        elif self.name == "2d_gaussian_disc":
+            return lambda num_points: point_samplers.ball_resampling(
+                num_points,
+                2,
+                lambda: point_samplers.gaussian(
+                    1, 2, center_point=self.center_point, sigmas=self.sigma
+                )[0],
+                {},
+                center_point=self.center_point,
+                width=self.width,
+            )
+        elif self.name == "3d_cube":
+            return lambda num_points: point_samplers.cube(
+                num_points, 3, center_point=self.center_point, widths=self.width
+            )
+        else:
+            raise ValueError(f"unknown name of point distribution: {self.name}")
 
 
 def random_point(prob_distribution):
     """
     Generate a point in space according to a given probability distribution.
 
     Parameters
     ----------
         prob_distribution : PointProbabilityDistribution
             A probability distribution (see :class:`PointProbabilityDistribution`).
 
     Returns
     -------
-        abcvoting.preferences.Profile
+        np.ndarray
     """
-    if prob_distribution.name == "1d_interval":
-        offset = prob_distribution.center_point[0] - prob_distribution.width / 2
-        point = rng.random() * prob_distribution.width + offset
-    elif prob_distribution.name == "1d_gaussian":
-        point = rng.normal(prob_distribution.center_point[0], prob_distribution.sigma)
-    elif prob_distribution.name == "1d_gaussian_interval":
-        while True:
-            point = rng.normal(prob_distribution.center_point[0], prob_distribution.sigma)
-            if (
-                prob_distribution.center_point[0] - prob_distribution.width / 2
-                <= point
-                <= prob_distribution.center_point[0] + prob_distribution.width / 2
-            ):
-                break
-    elif prob_distribution.name == "2d_disc":
-        phi = 2.0 * 180.0 * rng.random()
-        radius = math.sqrt(rng.random()) * prob_distribution.width / 2
-        point = [
-            prob_distribution.center_point[0] + radius * math.cos(phi),
-            prob_distribution.center_point[1] + radius * math.sin(phi),
-        ]
-    elif prob_distribution.name == "2d_square":
-        offset = prob_distribution.center_point - prob_distribution.width / 2
-        point = rng.random(2) * prob_distribution.width + offset
-    elif prob_distribution.name == "2d_gaussian":
-        point = [
-            rng.normal(prob_distribution.center_point[0], prob_distribution.sigma),
-            rng.normal(prob_distribution.center_point[1], prob_distribution.sigma),
-        ]
-    elif prob_distribution.name == "2d_gaussian_disc":
-        while True:
-            point = [
-                rng.normal(prob_distribution.center_point[0], prob_distribution.sigma),
-                rng.normal(prob_distribution.center_point[1], prob_distribution.sigma),
-            ]
-            if (
-                np.linalg.norm(point - prob_distribution.center_point)
-                <= prob_distribution.width / 2
-            ):
-                break
-    elif prob_distribution.name == "3d_cube":
-        point = rng.random(3) * prob_distribution.width + prob_distribution.center_point
-    else:
-        raise ValueError(f"unknown name of point distribution: {prob_distribution.name}")
-
-    return point
+    return prob_distribution.prefsampling_function()(1)[0]
 
 
 PROBABILITY_DISTRIBUTIONS = {
     "IC fixed-size": random_ic_fixed_size_profile,
     "IC": random_ic_profile,
     "Truncated Mallows": random_mallows_profile,
     "Urn fixed-size": random_urn_fixed_size_profile,
```

## abcvoting/properties.py

```diff
@@ -658,28 +658,28 @@
         model.addConstr(
             gb.quicksum(utility[(voter, x)] for x in range(1, len(committee) + 1))
             == gb.quicksum(in_committee[cand] for cand in voter.approved)
         )
 
     # constraint: the condition of having strictly more approved candidates in
     # dominating committee will be satisfied for at least one voter
-    model.addConstr(gb.quicksum(condition_strictly_more) >= 1)
+    model.addConstr(condition_strictly_more.sum() >= 1)
 
     # constraint: all voters should have at least as many preferred candidates
     # in the dominating committee as in the query committee.
     # for the voter with the condition_strictly_more variable set to 1, it should have
     # at least one more preferred candidate in the dominating committee.
     for i, voter in enumerate(profile):
         model.addConstr(
             gb.quicksum(utility[(voter, x)] for x in range(1, len(committee) + 1))
             >= num_apprvd_cands_query[i] + condition_strictly_more[i]
         )
 
     # constraint: committee has the right size
-    model.addConstr(gb.quicksum(in_committee) == len(committee))
+    model.addConstr(in_committee.sum() == len(committee))
 
     # set the objective function
     model.setObjective(
         gb.quicksum(
             utility[(voter, x)] for voter in profile for x in range(1, len(committee) + 1)
         ),
         gb.GRB.MAXIMIZE,
@@ -812,15 +812,15 @@
     # strictly less than ell approved candidates in committee
     for vi, voter in enumerate(profile):
         model.addConstr((in_group[vi] == 1) >> (len(voter.approved & committee) + 1 <= ell))
 
     in_cut = model.addVars(profile.num_cand, vtype=gb.GRB.BINARY, name="in_cut")
 
     # the voters in group should agree on at least ell candidates
-    model.addConstr(gb.quicksum(in_cut) >= ell)
+    model.addConstr(in_cut.sum() >= ell)
 
     # candidates in cut should be approved by all voters in group
     for vi, voter in enumerate(profile):
         for cand in profile.candidates:
             if cand not in voter.approved:
                 # in_group[vi] implies not in_cut[cand]
                 model.addConstr(in_cut[cand] <= 1 - in_group[vi])
@@ -964,15 +964,15 @@
     )
 
     # binary variables: indicate whether a candidate is in the intersection
     # of approved candidates over voters inside the group
     in_cut = model.addVars(profile.num_cand, vtype=gb.GRB.BINARY, name="in_cut")
 
     # the voters in group should agree on at least ell candidates
-    model.addConstr(gb.quicksum(in_cut) >= ell)
+    model.addConstr(in_cut.sum() >= ell)
 
     # candidates in cut should be approved by all voters in group
     for vi, voter in enumerate(profile):
         for cand in profile.candidates:
             if cand not in voter.approved:
                 # in_group[vi] implies not in_cut[cand]
                 model.addConstr(in_cut[cand] <= 1 - in_group[vi])
@@ -1517,18 +1517,18 @@
     set_of_voters = model.addVars(range(len(profile)), vtype=gb.GRB.BINARY)
     set_of_candidates = model.addVars(range(profile.num_cand), vtype=gb.GRB.BINARY)
     beta = model.addVar(lb=1, ub=set_upper_bound, vtype=gb.GRB.INTEGER)
     model.addConstr(beta <= set_of_candidates.sum())
 
     # coalition large enough to deserve |set_of_candidates| seats
     model.addConstr(
-        gb.quicksum(set_of_candidates) * quota
+        set_of_candidates.sum() * quota
         <= gb.quicksum(voter.weight * set_of_voters[vi] for vi, voter in enumerate(profile))
     )
-    model.addConstr(gb.quicksum(set_of_voters) >= 1)
+    model.addConstr(set_of_voters.sum() >= 1)
     for i, voter in enumerate(profile):
         # if i is in set_of_voters, then:
         # (a) i has utility at most beta-1 in committee
         utility_in_committee = len(committee & voter.approved)
         model.addConstr(utility_in_committee * set_of_voters[i] <= beta - 1)
         # (b) i has utility at least beta in set_of_candidates
         approved_in_set_of_candidates = [
@@ -1699,18 +1699,18 @@
     model = gb.Model()
 
     set_of_voters = model.addVars(range(len(profile)), vtype=gb.GRB.BINARY)
     set_of_candidates = model.addVars(range(profile.num_cand), vtype=gb.GRB.BINARY)
 
     # set_of_voters is large enough to afford set_of_candidates
     model.addConstr(
-        gb.quicksum(set_of_candidates) * quota
+        set_of_candidates.sum() * quota
         <= gb.quicksum(voter.weight * set_of_voters[vi] for vi, voter in enumerate(profile))
     )
-    model.addConstr(gb.quicksum(set_of_voters) >= 1)
+    model.addConstr(set_of_voters.sum() >= 1)
 
     # every voter in set_of_voters prefers set_of_candidates to committee
     for i, voter in enumerate(profile):
         approved = [
             (c in voter.approved) * set_of_candidates[i] for i, c in enumerate(profile.candidates)
         ]
         model.addConstr(
```

## Comparing `abcvoting-2.8.0.dist-info/LICENSE` & `abcvoting-2.9.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `abcvoting-2.8.0.dist-info/METADATA` & `abcvoting-2.9.0.dist-info/METADATA`

 * *Files 4% similar despite different names*

```diff
@@ -1,62 +1,66 @@
 Metadata-Version: 2.1
 Name: abcvoting
-Version: 2.8.0
+Version: 2.9.0
 Summary: A Python library of approval-based committee (ABC) rules
 Home-page: https://github.com/martinlackner/abcvoting/
 Author: Martin Lackner
 Author-email: unexpected@sent.at
 License: MIT License
 Project-URL: Bug Tracker, https://github.com/martinlackner/abcvoting/issues
 Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Programming Language :: Python :: 3.11
+Classifier: Programming Language :: Python :: 3.12
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Operating System :: OS Independent
 Classifier: Intended Audience :: Science/Research
-Requires-Python: >=3.7
+Requires-Python: >=3.8
 Description-Content-Type: text/markdown
 License-File: LICENSE
-Requires-Dist: networkx[default] (>=2.6.3)
-Requires-Dist: mip (>=1.14.0)
-Requires-Dist: ruamel.yaml (>=0.17)
-Requires-Dist: numpy (>=1.21)
-Requires-Dist: gurobipy (>=9.5.0)
-Requires-Dist: preflibtools (>=2.0.12)
+Requires-Dist: networkx[default] >=2.6.3
+Requires-Dist: mip >=1.14.0
+Requires-Dist: ruamel.yaml >=0.17
+Requires-Dist: numpy >=1.21
+Requires-Dist: gurobipy >=11.0
+Requires-Dist: preflibtools >=2.0.12
+Requires-Dist: prefsampling >=0.1.15
 Provides-Extra: dev
-Requires-Dist: pytest (>=6) ; extra == 'dev'
-Requires-Dist: coverage[toml] (>=5.3) ; extra == 'dev'
-Requires-Dist: black (==22.3.0) ; extra == 'dev'
-Requires-Dist: Sphinx (>=4.4.0) ; extra == 'dev'
-Requires-Dist: sphinx-rtd-theme (>=1.0.0) ; extra == 'dev'
-Requires-Dist: numpydoc (>=1.2) ; extra == 'dev'
-Requires-Dist: sphinx-codeautolink (>=0.10) ; extra == 'dev'
-Requires-Dist: matplotlib (>=3.4.3) ; extra == 'dev'
+Requires-Dist: pytest >=6 ; extra == 'dev'
+Requires-Dist: coverage[toml] >=5.3 ; extra == 'dev'
+Requires-Dist: black ==22.3.0 ; extra == 'dev'
+Requires-Dist: Sphinx >=7.0 ; extra == 'dev'
+Requires-Dist: sphinx-rtd-theme >=1.0.0 ; extra == 'dev'
+Requires-Dist: numpydoc >=1.5 ; extra == 'dev'
+Requires-Dist: sphinx-codeautolink >=0.15 ; extra == 'dev'
+Requires-Dist: matplotlib >=3.4.3 ; extra == 'dev'
 
 [![DOI](https://zenodo.org/badge/192713860.svg)](https://zenodo.org/badge/latestdoi/192713860)
 [![DOI](https://joss.theoj.org/papers/10.21105/joss.04880/status.svg)](https://doi.org/10.21105/joss.04880)
 [![PyPi](https://badgen.net/pypi/v/abcvoting)](https://pypi.org/project/abcvoting/)
 ![Python versions](https://badgen.net/pypi/python/abcvoting)
 [![Build badge](https://github.com/martinlackner/abcvoting/workflows/Build/badge.svg)](https://github.com/martinlackner/abcvoting/actions)
 [![Unittests badge](https://github.com/martinlackner/abcvoting/workflows/Unittests/badge.svg)](https://github.com/martinlackner/abcvoting/actions)
 [![docs](https://readthedocs.org/projects/abcvoting/badge/?version=latest&style=plastic)](https://abcvoting.readthedocs.io/en/latest/)
 [![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)
 [![codecov](https://codecov.io/gh/martinlackner/abcvoting/branch/master/graph/badge.svg)](https://codecov.io/gh/martinlackner/abcvoting)
 
 # abcvoting
 
+> [!NOTE]
 > - [**Documentation**](https://abcvoting.readthedocs.io/)
 > - [**Installation**](https://abcvoting.readthedocs.io/en/latest/installation.html)  
 > - [**How to cite the abcvoting library**](https://abcvoting.readthedocs.io/en/latest/howtocite.html)
 > - [**Acknowledgements and contributors**](https://abcvoting.readthedocs.io/en/latest/acks.html)
 > - [**► abcvoting web app**](https://pref.tools/abcvoting/)
 
+For an overview of other software tools related to Computational Social Choice, see the [COMSOC community page](https://comsoc-community.org/tools).
+
 ## A Python library of approval-based committee (ABC) rules
 
 **A**pproval-**b**ased **c**ommittee rules (ABC rules) are voting methods for selecting a committee, i.e., a fixed-size subset of candidates.
 ABC rules are also known as approval-based multi-winner rules.
 The input of such rules are
 [approval ballots](https://en.wikipedia.org/wiki/Approval_voting#/media/File:Approval_ballot.svg).
 We recommend the book
@@ -103,15 +107,16 @@
 * Extended Justified Representation (EJR)
 
 * Priceability
 
 * The core property
 
 Instead of using the abcvoting Python library, you can also use the 
-[**abcvoting web application**](https://pref.tools/abcvoting/) by Dominik Peters.
+[**abcvoting web application**](https://pref.tools/abcvoting/) by Dominik Peters
+(which is based on this Python library).
 
 ## Installation
 
 As simple as:
 
 ```bash
 pip install abcvoting
@@ -121,15 +126,15 @@
 
 ## Development
 
 Install all dependencies including development requirements and the abcvoting package in
 [development mode](https://setuptools.readthedocs.io/en/latest/userguide/development_mode.html):
 
 ```bash
-pip install -e .[dev]
+pip install -e ".[dev]"
 ```
 
 Basic unit tests can be run by excluding tests which require additional dependencies:
 
 ```bash
 pytest  -m "not mipgurobi and not gmpy2 and not slow" tests/
 ```
```

## Comparing `abcvoting-2.8.0.dist-info/RECORD` & `abcvoting-2.9.0.dist-info/RECORD`

 * *Files 18% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 abcvoting/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 abcvoting/abcrules.py,sha256=yjLhKEtX8WLLHfxc166Eqfl6iLKaR35edAQvVlqOui8,163258
-abcvoting/abcrules_gurobi.py,sha256=ABTbYgK7LxPPoCrG1JezJ56RqzEipcM8tws-wCXCTOA,29677
+abcvoting/abcrules_gurobi.py,sha256=hni7COX6HFcmRoG4ekZp4HacjuzKCHiYvVhX9eJGe2s,29656
 abcvoting/abcrules_mip.py,sha256=CA3gWtx5SAaShDlQbrycm4p1Lhfs8QBvmDUoxDr6I04,18059
 abcvoting/abcrules_ortools.py,sha256=Fhstb21gVU2wVPWHV70jWOKP62SUTAy-SgWESpIenbs,9643
-abcvoting/fileio.py,sha256=X2iRls5Iiyu1KDuqV1OguxUaYeiak7hmvAYsN6YZ6dI,14376
-abcvoting/generate.py,sha256=wZB99BPemIlvZEgASpo0HNpD2outB01yukeBZ_rtmkw,38434
+abcvoting/fileio.py,sha256=7Y-gOAMjHW8rElC-1FDU2X7j5z9bBB8z-hu_xgcbaFM,14382
+abcvoting/generate.py,sha256=-LtEFU6stuiSEVjTrmE1WxFXe4G8JXos-kc6gDQgnWw,33578
 abcvoting/misc.py,sha256=TsAB_LyaSgBq3zww04YdqDxKeVRTWvXa1KqQ0ZeIryk,12941
 abcvoting/output.py,sha256=bD4LWIcNOfV7XeqaCYXNyb-lKn5QRVT_h0eD6MqDvMA,6151
 abcvoting/preferences.py,sha256=l95d2pgPDqLMTqlNCxr6BqDhQ4B1BTQfV9UJGt4y_Jk,11253
-abcvoting/properties.py,sha256=vG89ZpZ406LkDE8RElCmYVV-TqPYtZLz54HK5H1x_Qk,60809
+abcvoting/properties.py,sha256=17d3DjLggre24w5xlMqEEHPqAE2TeTyVkICDsXJ4lqM,60753
 abcvoting/scores.py,sha256=oHlolGYom9UEPvWZFElI21v_PFVvm3bRRpjqdWC2IAo,14692
-abcvoting-2.8.0.dist-info/LICENSE,sha256=zGd2CLhEHQwEF_aLnpMnFDcyFG5OPJ20CxPNalkkdPo,1071
-abcvoting-2.8.0.dist-info/METADATA,sha256=5iJfg_6O-gKj3F4H5gxzxG-iOLX7p0CbxIsDR3ao5vM,7783
-abcvoting-2.8.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-abcvoting-2.8.0.dist-info/top_level.txt,sha256=960L_hveJVZkHrbdTu94Hppp6fnwbG-REV5RxlFhKFA,10
-abcvoting-2.8.0.dist-info/RECORD,,
+abcvoting-2.9.0.dist-info/LICENSE,sha256=zGd2CLhEHQwEF_aLnpMnFDcyFG5OPJ20CxPNalkkdPo,1071
+abcvoting-2.9.0.dist-info/METADATA,sha256=uSodODtLZ2rusiP_au5CiARmy9x0X2RNUE9ipLgO3m0,7992
+abcvoting-2.9.0.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+abcvoting-2.9.0.dist-info/top_level.txt,sha256=960L_hveJVZkHrbdTu94Hppp6fnwbG-REV5RxlFhKFA,10
+abcvoting-2.9.0.dist-info/RECORD,,
```

