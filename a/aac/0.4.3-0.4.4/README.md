# Comparing `tmp/aac-0.4.3-py3-none-any.whl.zip` & `tmp/aac-0.4.4-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,85 +1,86 @@
-Zip file size: 91997 bytes, number of entries: 83
--rw-r--r--  2.0 unx      681 b- defN 24-Feb-26 21:57 aac/__init__.py
--rw-r--r--  2.0 unx      184 b- defN 24-Feb-26 21:57 aac/__main__.py
--rw-r--r--  2.0 unx    39404 b- defN 24-Feb-26 21:57 aac/aac.aac
--rw-r--r--  2.0 unx       93 b- defN 24-Feb-26 21:57 aac/context/__init__.py
--rw-r--r--  2.0 unx     3340 b- defN 24-Feb-26 21:57 aac/context/constants.py
--rw-r--r--  2.0 unx     3555 b- defN 24-Feb-26 21:57 aac/context/definition.py
--rw-r--r--  2.0 unx    45417 b- defN 24-Feb-26 21:57 aac/context/language_context.py
--rw-r--r--  2.0 unx      416 b- defN 24-Feb-26 21:57 aac/context/language_error.py
--rw-r--r--  2.0 unx     1179 b- defN 24-Feb-26 21:57 aac/context/lexeme.py
--rw-r--r--  2.0 unx     1193 b- defN 24-Feb-26 21:57 aac/context/source_location.py
--rw-r--r--  2.0 unx     2025 b- defN 24-Feb-26 21:57 aac/context/util.py
--rw-r--r--  2.0 unx      613 b- defN 24-Feb-26 21:57 aac/execute/__init__.py
--rw-r--r--  2.0 unx     4123 b- defN 24-Feb-26 21:57 aac/execute/aac_execution_result.py
--rw-r--r--  2.0 unx     6357 b- defN 24-Feb-26 21:57 aac/execute/command_line.py
--rw-r--r--  2.0 unx      280 b- defN 24-Feb-26 21:57 aac/execute/hookspecs.py
--rw-r--r--  2.0 unx     1351 b- defN 24-Feb-26 21:57 aac/execute/plugin_manager.py
--rw-r--r--  2.0 unx     3728 b- defN 24-Feb-26 21:57 aac/execute/plugin_runner.py
--rw-r--r--  2.0 unx       66 b- defN 24-Feb-26 21:57 aac/in_out/__init__.py
--rw-r--r--  2.0 unx      253 b- defN 24-Feb-26 21:57 aac/in_out/constants.py
--rw-r--r--  2.0 unx     2507 b- defN 24-Feb-26 21:57 aac/in_out/paths.py
--rw-r--r--  2.0 unx     2274 b- defN 24-Feb-26 21:57 aac/in_out/writer.py
--rw-r--r--  2.0 unx       63 b- defN 24-Feb-26 21:57 aac/in_out/files/__init__.py
--rw-r--r--  2.0 unx      925 b- defN 24-Feb-26 21:57 aac/in_out/files/aac_file.py
--rw-r--r--  2.0 unx     1640 b- defN 24-Feb-26 21:57 aac/in_out/files/find.py
--rw-r--r--  2.0 unx      443 b- defN 24-Feb-26 21:57 aac/in_out/parser/__init__.py
--rw-r--r--  2.0 unx     4901 b- defN 24-Feb-26 21:57 aac/in_out/parser/_cache.py
--rw-r--r--  2.0 unx      538 b- defN 24-Feb-26 21:57 aac/in_out/parser/_cache_manager.py
--rw-r--r--  2.0 unx     9476 b- defN 24-Feb-26 21:57 aac/in_out/parser/_parse_source.py
--rw-r--r--  2.0 unx      601 b- defN 24-Feb-26 21:57 aac/in_out/parser/_parser_error.py
--rw-r--r--  2.0 unx     4682 b- defN 24-Feb-26 21:57 aac/in_out/parser/_yaml.py
--rw-r--r--  2.0 unx       74 b- defN 24-Feb-26 21:57 aac/plugins/__init__.py
--rw-r--r--  2.0 unx     5817 b- defN 24-Feb-26 21:57 aac/plugins/aac_primitives/__init__.py
--rw-r--r--  2.0 unx     1171 b- defN 24-Feb-26 21:57 aac/plugins/aac_primitives/aac_primitive_constraints.aac
--rw-r--r--  2.0 unx    13451 b- defN 24-Feb-26 21:57 aac/plugins/aac_primitives/aac_primitive_constraints_impl.py
--rw-r--r--  2.0 unx     1875 b- defN 24-Feb-26 21:57 aac/plugins/check/__init__.py
--rw-r--r--  2.0 unx      723 b- defN 24-Feb-26 21:57 aac/plugins/check/check_aac.aac
--rw-r--r--  2.0 unx    10760 b- defN 24-Feb-26 21:57 aac/plugins/check/check_aac_impl.py
--rw-r--r--  2.0 unx     2417 b- defN 24-Feb-26 21:57 aac/plugins/constraint_assignment_arguments/__init__.py
--rw-r--r--  2.0 unx      529 b- defN 24-Feb-26 21:57 aac/plugins/constraint_assignment_arguments/constraint_assignment_arguments.aac
--rw-r--r--  2.0 unx     7514 b- defN 24-Feb-26 21:57 aac/plugins/constraint_assignment_arguments/constraint_assignment_arguments_impl.py
--rw-r--r--  2.0 unx     2085 b- defN 24-Feb-26 21:57 aac/plugins/exclusive_fields/__init__.py
--rw-r--r--  2.0 unx      594 b- defN 24-Feb-26 21:57 aac/plugins/exclusive_fields/exclusive_fields.aac
--rw-r--r--  2.0 unx     2350 b- defN 24-Feb-26 21:57 aac/plugins/exclusive_fields/exclusive_fields_impl.py
--rw-r--r--  2.0 unx     4565 b- defN 24-Feb-26 21:57 aac/plugins/gen_plugin/__init__.py
--rw-r--r--  2.0 unx     2571 b- defN 24-Feb-26 21:57 aac/plugins/gen_plugin/gen_plugin.aac
--rw-r--r--  2.0 unx     7281 b- defN 24-Feb-26 21:57 aac/plugins/gen_plugin/gen_plugin_generator.aac
--rw-r--r--  2.0 unx     3251 b- defN 24-Feb-26 21:57 aac/plugins/gen_plugin/gen_plugin_impl.py
--rw-r--r--  2.0 unx       35 b- defN 24-Feb-26 21:57 aac/plugins/gen_plugin/templates/empty.jinja2
--rw-r--r--  2.0 unx     1396 b- defN 24-Feb-26 21:57 aac/plugins/gen_plugin/templates/feature_file.jinja2
--rw-r--r--  2.0 unx     6704 b- defN 24-Feb-26 21:57 aac/plugins/gen_plugin/templates/plugin_impl.jinja2
--rw-r--r--  2.0 unx    10212 b- defN 24-Feb-26 21:57 aac/plugins/gen_plugin/templates/plugin_init.jinja2
--rw-r--r--  2.0 unx     3939 b- defN 24-Feb-26 21:57 aac/plugins/gen_plugin/templates/plugin_unit_test.jinja2
--rw-r--r--  2.0 unx      215 b- defN 24-Feb-26 21:57 aac/plugins/gen_plugin/templates/project_readme.jinja2
--rw-r--r--  2.0 unx     1069 b- defN 24-Feb-26 21:57 aac/plugins/gen_plugin/templates/project_setup.jinja2
--rw-r--r--  2.0 unx      862 b- defN 24-Feb-26 21:57 aac/plugins/gen_plugin/templates/project_tox.jinja2
--rw-r--r--  2.0 unx     2425 b- defN 24-Feb-26 21:57 aac/plugins/generate/__init__.py
--rw-r--r--  2.0 unx     2245 b- defN 24-Feb-26 21:57 aac/plugins/generate/generate.aac
--rw-r--r--  2.0 unx    14699 b- defN 24-Feb-26 21:57 aac/plugins/generate/generate_impl.py
--rw-r--r--  2.0 unx       62 b- defN 24-Feb-26 21:57 aac/plugins/generate/helpers/__init__.py
--rw-r--r--  2.0 unx     4757 b- defN 24-Feb-26 21:57 aac/plugins/generate/helpers/python_helpers.py
--rw-r--r--  2.0 unx     2153 b- defN 24-Feb-26 21:57 aac/plugins/if_true_then_empty/__init__.py
--rw-r--r--  2.0 unx      558 b- defN 24-Feb-26 21:57 aac/plugins/if_true_then_empty/if_true_then_empty.aac
--rw-r--r--  2.0 unx     2286 b- defN 24-Feb-26 21:57 aac/plugins/if_true_then_empty/if_true_then_empty_impl.py
--rw-r--r--  2.0 unx     1993 b- defN 24-Feb-26 21:57 aac/plugins/no_ext_for_final/__init__.py
--rw-r--r--  2.0 unx      360 b- defN 24-Feb-26 21:57 aac/plugins/no_ext_for_final/no_ext_for_final.aac
--rw-r--r--  2.0 unx     2425 b- defN 24-Feb-26 21:57 aac/plugins/no_ext_for_final/no_ext_for_final_impl.py
--rw-r--r--  2.0 unx     2016 b- defN 24-Feb-26 21:57 aac/plugins/print_defs/__init__.py
--rw-r--r--  2.0 unx      447 b- defN 24-Feb-26 21:57 aac/plugins/print_defs/print_aac_definitions.aac
--rw-r--r--  2.0 unx     1423 b- defN 24-Feb-26 21:57 aac/plugins/print_defs/print_aac_definitions_impl.py
--rw-r--r--  2.0 unx     2158 b- defN 24-Feb-26 21:57 aac/plugins/root_schema_must_have_name/__init__.py
--rw-r--r--  2.0 unx      370 b- defN 24-Feb-26 21:57 aac/plugins/root_schema_must_have_name/root_schema_must_have_name.aac
--rw-r--r--  2.0 unx     2751 b- defN 24-Feb-26 21:57 aac/plugins/root_schema_must_have_name/root_schema_must_have_name_impl.py
--rw-r--r--  2.0 unx     1872 b- defN 24-Feb-26 21:57 aac/plugins/unique_root_keys/__init__.py
--rw-r--r--  2.0 unx      357 b- defN 24-Feb-26 21:57 aac/plugins/unique_root_keys/unique_root_keys.aac
--rw-r--r--  2.0 unx     1457 b- defN 24-Feb-26 21:57 aac/plugins/unique_root_keys/unique_root_keys_impl.py
--rw-r--r--  2.0 unx     1773 b- defN 24-Feb-26 21:57 aac/plugins/version/__init__.py
--rw-r--r--  2.0 unx      226 b- defN 24-Feb-26 21:57 aac/plugins/version/version.aac
--rw-r--r--  2.0 unx      875 b- defN 24-Feb-26 21:57 aac/plugins/version/version_impl.py
--rw-r--r--  2.0 unx    13241 b- defN 24-Feb-26 21:58 aac-0.4.3.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-Feb-26 21:58 aac-0.4.3.dist-info/WHEEL
--rw-r--r--  2.0 unx       53 b- defN 24-Feb-26 21:58 aac-0.4.3.dist-info/entry_points.txt
--rw-r--r--  2.0 unx        4 b- defN 24-Feb-26 21:58 aac-0.4.3.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     7799 b- defN 24-Feb-26 21:58 aac-0.4.3.dist-info/RECORD
-83 files, 304645 bytes uncompressed, 79355 bytes compressed:  74.0%
+Zip file size: 93224 bytes, number of entries: 84
+-rw-r--r--  2.0 unx      681 b- defN 24-Apr-30 19:38 aac/__init__.py
+-rw-r--r--  2.0 unx      184 b- defN 24-Apr-30 19:38 aac/__main__.py
+-rw-r--r--  2.0 unx    39404 b- defN 24-Apr-30 19:38 aac/aac.aac
+-rw-r--r--  2.0 unx       93 b- defN 24-Apr-30 19:38 aac/context/__init__.py
+-rw-r--r--  2.0 unx     3340 b- defN 24-Apr-30 19:38 aac/context/constants.py
+-rw-r--r--  2.0 unx     3555 b- defN 24-Apr-30 19:38 aac/context/definition.py
+-rw-r--r--  2.0 unx    36891 b- defN 24-Apr-30 19:38 aac/context/definition_parser.py
+-rw-r--r--  2.0 unx    11942 b- defN 24-Apr-30 19:38 aac/context/language_context.py
+-rw-r--r--  2.0 unx      416 b- defN 24-Apr-30 19:38 aac/context/language_error.py
+-rw-r--r--  2.0 unx     1179 b- defN 24-Apr-30 19:38 aac/context/lexeme.py
+-rw-r--r--  2.0 unx     1193 b- defN 24-Apr-30 19:38 aac/context/source_location.py
+-rw-r--r--  2.0 unx     2025 b- defN 24-Apr-30 19:38 aac/context/util.py
+-rw-r--r--  2.0 unx      613 b- defN 24-Apr-30 19:38 aac/execute/__init__.py
+-rw-r--r--  2.0 unx     4123 b- defN 24-Apr-30 19:38 aac/execute/aac_execution_result.py
+-rw-r--r--  2.0 unx     6357 b- defN 24-Apr-30 19:38 aac/execute/command_line.py
+-rw-r--r--  2.0 unx      280 b- defN 24-Apr-30 19:38 aac/execute/hookspecs.py
+-rw-r--r--  2.0 unx     1351 b- defN 24-Apr-30 19:38 aac/execute/plugin_manager.py
+-rw-r--r--  2.0 unx     3728 b- defN 24-Apr-30 19:38 aac/execute/plugin_runner.py
+-rw-r--r--  2.0 unx       66 b- defN 24-Apr-30 19:38 aac/in_out/__init__.py
+-rw-r--r--  2.0 unx      253 b- defN 24-Apr-30 19:38 aac/in_out/constants.py
+-rw-r--r--  2.0 unx     2507 b- defN 24-Apr-30 19:38 aac/in_out/paths.py
+-rw-r--r--  2.0 unx     2274 b- defN 24-Apr-30 19:38 aac/in_out/writer.py
+-rw-r--r--  2.0 unx       63 b- defN 24-Apr-30 19:38 aac/in_out/files/__init__.py
+-rw-r--r--  2.0 unx      925 b- defN 24-Apr-30 19:38 aac/in_out/files/aac_file.py
+-rw-r--r--  2.0 unx     1640 b- defN 24-Apr-30 19:38 aac/in_out/files/find.py
+-rw-r--r--  2.0 unx      443 b- defN 24-Apr-30 19:38 aac/in_out/parser/__init__.py
+-rw-r--r--  2.0 unx     4901 b- defN 24-Apr-30 19:38 aac/in_out/parser/_cache.py
+-rw-r--r--  2.0 unx      538 b- defN 24-Apr-30 19:38 aac/in_out/parser/_cache_manager.py
+-rw-r--r--  2.0 unx     9476 b- defN 24-Apr-30 19:38 aac/in_out/parser/_parse_source.py
+-rw-r--r--  2.0 unx      601 b- defN 24-Apr-30 19:38 aac/in_out/parser/_parser_error.py
+-rw-r--r--  2.0 unx     4682 b- defN 24-Apr-30 19:38 aac/in_out/parser/_yaml.py
+-rw-r--r--  2.0 unx       74 b- defN 24-Apr-30 19:38 aac/plugins/__init__.py
+-rw-r--r--  2.0 unx     5817 b- defN 24-Apr-30 19:38 aac/plugins/aac_primitives/__init__.py
+-rw-r--r--  2.0 unx     1171 b- defN 24-Apr-30 19:38 aac/plugins/aac_primitives/aac_primitive_constraints.aac
+-rw-r--r--  2.0 unx    13451 b- defN 24-Apr-30 19:38 aac/plugins/aac_primitives/aac_primitive_constraints_impl.py
+-rw-r--r--  2.0 unx     1875 b- defN 24-Apr-30 19:38 aac/plugins/check/__init__.py
+-rw-r--r--  2.0 unx      723 b- defN 24-Apr-30 19:38 aac/plugins/check/check_aac.aac
+-rw-r--r--  2.0 unx    10760 b- defN 24-Apr-30 19:38 aac/plugins/check/check_aac_impl.py
+-rw-r--r--  2.0 unx     2417 b- defN 24-Apr-30 19:38 aac/plugins/constraint_assignment_arguments/__init__.py
+-rw-r--r--  2.0 unx      529 b- defN 24-Apr-30 19:38 aac/plugins/constraint_assignment_arguments/constraint_assignment_arguments.aac
+-rw-r--r--  2.0 unx     7514 b- defN 24-Apr-30 19:38 aac/plugins/constraint_assignment_arguments/constraint_assignment_arguments_impl.py
+-rw-r--r--  2.0 unx     2085 b- defN 24-Apr-30 19:38 aac/plugins/exclusive_fields/__init__.py
+-rw-r--r--  2.0 unx      594 b- defN 24-Apr-30 19:38 aac/plugins/exclusive_fields/exclusive_fields.aac
+-rw-r--r--  2.0 unx     2350 b- defN 24-Apr-30 19:38 aac/plugins/exclusive_fields/exclusive_fields_impl.py
+-rw-r--r--  2.0 unx     4565 b- defN 24-Apr-30 19:38 aac/plugins/gen_plugin/__init__.py
+-rw-r--r--  2.0 unx     2571 b- defN 24-Apr-30 19:38 aac/plugins/gen_plugin/gen_plugin.aac
+-rw-r--r--  2.0 unx     7281 b- defN 24-Apr-30 19:38 aac/plugins/gen_plugin/gen_plugin_generator.aac
+-rw-r--r--  2.0 unx     3251 b- defN 24-Apr-30 19:38 aac/plugins/gen_plugin/gen_plugin_impl.py
+-rw-r--r--  2.0 unx       35 b- defN 24-Apr-30 19:38 aac/plugins/gen_plugin/templates/empty.jinja2
+-rw-r--r--  2.0 unx     1396 b- defN 24-Apr-30 19:38 aac/plugins/gen_plugin/templates/feature_file.jinja2
+-rw-r--r--  2.0 unx     6704 b- defN 24-Apr-30 19:38 aac/plugins/gen_plugin/templates/plugin_impl.jinja2
+-rw-r--r--  2.0 unx    10212 b- defN 24-Apr-30 19:38 aac/plugins/gen_plugin/templates/plugin_init.jinja2
+-rw-r--r--  2.0 unx     3939 b- defN 24-Apr-30 19:38 aac/plugins/gen_plugin/templates/plugin_unit_test.jinja2
+-rw-r--r--  2.0 unx      215 b- defN 24-Apr-30 19:38 aac/plugins/gen_plugin/templates/project_readme.jinja2
+-rw-r--r--  2.0 unx     1069 b- defN 24-Apr-30 19:38 aac/plugins/gen_plugin/templates/project_setup.jinja2
+-rw-r--r--  2.0 unx      862 b- defN 24-Apr-30 19:38 aac/plugins/gen_plugin/templates/project_tox.jinja2
+-rw-r--r--  2.0 unx     2425 b- defN 24-Apr-30 19:38 aac/plugins/generate/__init__.py
+-rw-r--r--  2.0 unx     2245 b- defN 24-Apr-30 19:38 aac/plugins/generate/generate.aac
+-rw-r--r--  2.0 unx    14699 b- defN 24-Apr-30 19:38 aac/plugins/generate/generate_impl.py
+-rw-r--r--  2.0 unx       62 b- defN 24-Apr-30 19:38 aac/plugins/generate/helpers/__init__.py
+-rw-r--r--  2.0 unx     4757 b- defN 24-Apr-30 19:38 aac/plugins/generate/helpers/python_helpers.py
+-rw-r--r--  2.0 unx     2153 b- defN 24-Apr-30 19:38 aac/plugins/if_true_then_empty/__init__.py
+-rw-r--r--  2.0 unx      558 b- defN 24-Apr-30 19:38 aac/plugins/if_true_then_empty/if_true_then_empty.aac
+-rw-r--r--  2.0 unx     2286 b- defN 24-Apr-30 19:38 aac/plugins/if_true_then_empty/if_true_then_empty_impl.py
+-rw-r--r--  2.0 unx     1993 b- defN 24-Apr-30 19:38 aac/plugins/no_ext_for_final/__init__.py
+-rw-r--r--  2.0 unx      360 b- defN 24-Apr-30 19:38 aac/plugins/no_ext_for_final/no_ext_for_final.aac
+-rw-r--r--  2.0 unx     2425 b- defN 24-Apr-30 19:38 aac/plugins/no_ext_for_final/no_ext_for_final_impl.py
+-rw-r--r--  2.0 unx     2016 b- defN 24-Apr-30 19:38 aac/plugins/print_defs/__init__.py
+-rw-r--r--  2.0 unx      447 b- defN 24-Apr-30 19:38 aac/plugins/print_defs/print_aac_definitions.aac
+-rw-r--r--  2.0 unx     1423 b- defN 24-Apr-30 19:38 aac/plugins/print_defs/print_aac_definitions_impl.py
+-rw-r--r--  2.0 unx     2158 b- defN 24-Apr-30 19:38 aac/plugins/root_schema_must_have_name/__init__.py
+-rw-r--r--  2.0 unx      370 b- defN 24-Apr-30 19:38 aac/plugins/root_schema_must_have_name/root_schema_must_have_name.aac
+-rw-r--r--  2.0 unx     2751 b- defN 24-Apr-30 19:38 aac/plugins/root_schema_must_have_name/root_schema_must_have_name_impl.py
+-rw-r--r--  2.0 unx     1872 b- defN 24-Apr-30 19:38 aac/plugins/unique_root_keys/__init__.py
+-rw-r--r--  2.0 unx      357 b- defN 24-Apr-30 19:38 aac/plugins/unique_root_keys/unique_root_keys.aac
+-rw-r--r--  2.0 unx     1457 b- defN 24-Apr-30 19:38 aac/plugins/unique_root_keys/unique_root_keys_impl.py
+-rw-r--r--  2.0 unx     1773 b- defN 24-Apr-30 19:38 aac/plugins/version/__init__.py
+-rw-r--r--  2.0 unx      226 b- defN 24-Apr-30 19:38 aac/plugins/version/version.aac
+-rw-r--r--  2.0 unx      875 b- defN 24-Apr-30 19:38 aac/plugins/version/version_impl.py
+-rw-r--r--  2.0 unx    13241 b- defN 24-Apr-30 19:38 aac-0.4.4.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-Apr-30 19:38 aac-0.4.4.dist-info/WHEEL
+-rw-r--r--  2.0 unx       53 b- defN 24-Apr-30 19:38 aac-0.4.4.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx        4 b- defN 24-Apr-30 19:38 aac-0.4.4.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     7889 b- defN 24-Apr-30 19:38 aac-0.4.4.dist-info/RECORD
+84 files, 308151 bytes uncompressed, 80442 bytes compressed:  73.9%
```

## zipnote {}

```diff
@@ -12,14 +12,17 @@
 
 Filename: aac/context/constants.py
 Comment: 
 
 Filename: aac/context/definition.py
 Comment: 
 
+Filename: aac/context/definition_parser.py
+Comment: 
+
 Filename: aac/context/language_context.py
 Comment: 
 
 Filename: aac/context/language_error.py
 Comment: 
 
 Filename: aac/context/lexeme.py
@@ -228,23 +231,23 @@
 
 Filename: aac/plugins/version/version.aac
 Comment: 
 
 Filename: aac/plugins/version/version_impl.py
 Comment: 
 
-Filename: aac-0.4.3.dist-info/METADATA
+Filename: aac-0.4.4.dist-info/METADATA
 Comment: 
 
-Filename: aac-0.4.3.dist-info/WHEEL
+Filename: aac-0.4.4.dist-info/WHEEL
 Comment: 
 
-Filename: aac-0.4.3.dist-info/entry_points.txt
+Filename: aac-0.4.4.dist-info/entry_points.txt
 Comment: 
 
-Filename: aac-0.4.3.dist-info/top_level.txt
+Filename: aac-0.4.4.dist-info/top_level.txt
 Comment: 
 
-Filename: aac-0.4.3.dist-info/RECORD
+Filename: aac-0.4.4.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## aac/__init__.py

```diff
@@ -8,15 +8,15 @@
     major = sys.version_info.major
     print(f"Python version {major}.{minor} is too low; AaC requires at least Python version 3.9 or higher to run.")
     exit(1)
 
 import logging
 import os
 
-__version__ = "0.4.3"
+__version__ = "0.4.4"
 __log_file_name__ = os.path.join(os.path.dirname(__file__), "aac.log")
 
 logging.basicConfig(
     format="%(asctime)s::%(pathname)s:%(lineno)d::%(levelname)s::%(message)s",
     filename=__log_file_name__,
     encoding="utf-8",
     level=logging.DEBUG,
```

## aac/context/language_context.py

```diff
@@ -1,18 +1,16 @@
 """The LanguageContext is a singleton that holds the current state of the AaC language, including all definitions and plugin runners."""
 from typing import Any, Type
-from enum import Enum, auto
 from os.path import join, dirname
 from aac.context.language_error import LanguageError
 from aac.execute.plugin_manager import get_plugin_manager
 from aac.execute.plugin_runner import PluginRunner
-from aac.in_out.parser._parse_source import parse
 from aac.context.definition import Definition
-from aac.context.lexeme import Lexeme
-from aac.context.util import get_python_module_name, get_python_class_name
+from aac.in_out.parser._parse_source import parse
+from aac.context.definition_parser import DefinitionParser
 
 AAC_LANG_FILE_NAME = "../aac.aac"
 AAC_LANG_FILE_PATH = join(dirname(__file__), AAC_LANG_FILE_NAME)
 
 
 class LanguageContext(object):
     """A singleton class that holds the current state of the AaC language."""
@@ -105,658 +103,17 @@
                 f"{value} is not a valid value for enum {aac_enum_name}",
                 definitions[0].source.uri
             )
 
     def parse_and_load(self, arg: str) -> list[Definition]:
         """Convenience function that parses a file or string and loads the definitions into the context."""
         parsed_definitions = parse(arg)
+        parser = DefinitionParser()
 
-        return self.load_definitions(parsed_definitions)
-
-    def load_definitions(  # noqa: C901
-        self, parsed_definitions: list[Definition]
-    ) -> list[Definition]:
-        """Loads the given definitions into the context and populates the instance with a python object."""
-
-        # Maintainer note:  Yes, this function is a bit of a monster...sorry about that.
-        # I wanted to keep all this stuff together because if it all works out this should be the
-        # only place where we have to deal with navigating the structure of the definitions and
-        # not using the python objects.  In order for this to work, any changes in here should
-        # avoid the use of he definition instance...other than actually creating it.
-
-        primitive_name_to_py_type = {
-            definition.name: definition.structure["primitive"]["python_type"]
-            for definition in parsed_definitions + self.get_definitions()
-            if definition.get_root_key() == "primitive"
-        }
-        fully_qualified_name_to_definition = {}
-
-        def find_definitions_by_name(name: str) -> list[Definition]:
-            result = []
-            for definition in self.get_definitions():
-                if definition.name == name:
-                    result.append(definition)
-            # if we didn't find any definitions in the context, check the parsed definitions
-            if len(result) == 0:
-                for definition in parsed_definitions:
-                    if definition.name == name:
-                        result.append(definition)
-            return result
-
-        def get_location_str(value: str, lexemes: list[Lexeme]) -> str:
-            lexeme = [lexeme for lexeme in lexemes if lexeme.value == value]
-            location_str = (
-                "Unable to identify source and location"  # this is the 'not found' case
-            )
-            if len(lexeme) == 1:  # this is the single match case
-                source_str = lexeme[0].source
-                line_str = lexeme[0].location.line + 1
-                location_str = f"File: {source_str}  Line: {line_str}"
-            elif len(lexeme) > 1:  # this is the ambiguous match case
-                # check to see if location source is the same for all matches
-                if all(
-                    [
-                        lexeme[0].source == lexeme[i].source
-                        for i in range(1, len(lexeme))
-                    ]
-                ):
-                    source_str = lexeme[0].source
-                    location_str = f"File: {source_str}  Possible Lines: {', '.join([str(lex.location.line+1) for lex in lexeme])}"
-                else:  # if not, just list each possible location
-                    location_str = "Unable to identify unique location - "
-                    for lex in lexeme:
-                        location_str += (
-                            f"File: {lex.source}  Line: {lex.location.line+1}  "
-                        )
-            return location_str
-
-        def get_inheritance_parents(definition: Definition) -> list[Type]:
-            """Looks up the inheritance parent classes for the given definition and returns them as a list of python classes."""
-            inheritance_parents = []
-
-            if "extends" in definition.structure[definition.get_root_key()]:
-                for parent in definition.structure[definition.get_root_key()][
-                    "extends"
-                ]:
-                    # I need to find the definition referenced by the extends
-                    parent_package = parent["package"]
-                    parent_name = parent["name"]
-                    parent_fully_qualified_name = ""
-                    try:
-                        parent_fully_qualified_name = f"{get_python_module_name(parent_package)}.{get_python_class_name(parent_name)}"
-                    except LanguageError as e:
-                        raise LanguageError(
-                            f"failed to establish parent fully qualified name from parent_package {parent_package} and parent_name {parent_name}: {e.message}", get_location_str(parent_name, definition.lexemes)
-                        )
-
-                    if (
-                        parent_fully_qualified_name
-                        in self.context_instance.fully_qualified_name_to_class
-                    ):
-                        inheritance_parents.append(
-                            self.context_instance.fully_qualified_name_to_class[
-                                parent_fully_qualified_name
-                            ]
-                        )
-                    else:
-                        # there is a chance that processing order just means we haven't gotten to the parent yet
-                        parent_definition = None
-                        if (
-                            parent_fully_qualified_name
-                            in fully_qualified_name_to_definition
-                        ):
-                            parent_definition = fully_qualified_name_to_definition[
-                                parent_fully_qualified_name
-                            ]
-
-                        if not parent_definition:
-                            raise LanguageError(
-                                f"Cannot find parent definition {parent_fully_qualified_name} for {definition.name}",
-                                get_location_str(parent_name, definition.lexemes),
-                            )
-
-                        if parent_definition.get_root_key() == "schema":
-                            inheritance_parents.append(
-                                create_schema_class(parent_definition)
-                            )
-                        else:
-                            # AaC only supports schema inheritance
-                            raise LanguageError(
-                                f"AaC extension is only supported for schema.  Unable to create parent class with AaC root: {parent_definition.get_root_key()}",
-                                get_location_str(parent_name, definition.lexemes),
-                            )
-
-            return inheritance_parents
-
-        def create_enum_class(enum_definition: Definition) -> Type:
-            if not enum_definition.get_root_key() == "enum":
-                raise LanguageError(
-                    f"Definition {enum_definition.name} is not an enum",
-                    get_location_str(
-                        enum_definition.get_root_key(), enum_definition.lexemes
-                    ),
-                )
-
-            fully_qualified_name = enum_definition.get_fully_qualified_name()
-            if (
-                fully_qualified_name
-                in self.context_instance.fully_qualified_name_to_class
-            ):
-                # we've already created the class, so nothing to do here
-                return self.context_instance.fully_qualified_name_to_class[
-                    fully_qualified_name
-                ]
-
-            # Note:  trying to allow extension with Enums fails, so I just removed it
-            #        but we can revisit and try to find a solution in the future if needed
-
-            values = {}
-            if "values" in enum_definition.structure["enum"]:
-                for value in enum_definition.structure["enum"]["values"]:
-                    values[value] = auto()
-            # create the enum class
-            instance_class = None
-            try:
-                instance_class = Enum(
-                    enum_definition.get_python_class_name(),
-                    values,
-                    module=enum_definition.get_python_module_name(),
-                )
-            except LanguageError as e:
-                raise LanguageError(
-                    f"Failed to create Enum instance_class for {enum_definition.name}: {e.message}",
-                    get_location_str(enum_definition.name, enum_definition.lexemes),
-                )
-            self.context_instance.fully_qualified_name_to_class[
-                fully_qualified_name
-            ] = instance_class
-            return instance_class
-
-        def create_schema_class(schema_definition: Definition) -> Type:
-            instance_class = None
-
-            fully_qualified_name = schema_definition.get_fully_qualified_name()
-            if schema_definition.get_root_key() == "primitive":
-                # this is a primitive, so there's no structure to create...just return the python type
-                return eval(primitive_name_to_py_type[schema_definition.name])
-            elif schema_definition.get_root_key() == "enum":
-                # this is an enum, so create the enum class
-                return create_enum_class(schema_definition)
-            elif schema_definition.get_root_key() != "schema":
-                raise LanguageError(
-                    f"Definition {schema_definition.name} is not a schema",
-                    get_location_str(
-                        schema_definition.get_root_key(), schema_definition.lexemes
-                    ),
-                )
-
-            if (
-                fully_qualified_name
-                in self.context_instance.fully_qualified_name_to_class
-            ):
-                # we've already created the class, so nothing to do here
-                return self.context_instance.fully_qualified_name_to_class[
-                    fully_qualified_name
-                ]
-
-            instance_class = None
-            inheritance_parents = get_inheritance_parents(schema_definition)
-            if len(inheritance_parents) == 0:
-                try:
-                    instance_class = type(
-                        schema_definition.get_python_class_name(),
-                        tuple([object]),
-                        {"__module__": schema_definition.get_python_module_name()},
-                    )
-                except LanguageError as e:
-                    raise LanguageError(
-                        f"Failed to create instance_class for {schema_definition.name}: {e.message}",
-                        get_location_str(
-                            schema_definition.name, schema_definition.lexemes
-                        ),
-                    )
-            else:
-                parent_classes = inheritance_parents  # the following causes a method resolution order (MRO) error when creating the type: [object] + inheritance_parents
-                try:
-                    instance_class = type(
-                        definition.get_python_class_name(),
-                        tuple(parent_classes),
-                        {"__module__": schema_definition.get_python_module_name()},
-                    )
-                except LanguageError as e:
-                    raise LanguageError(
-                        f"Failed to create instance_class for {schema_definition.name}: {e.message}",
-                        get_location_str(
-                            schema_definition.name, schema_definition.lexemes
-                        ),
-                    )
-
-            # now add the fields to the class
-            for field in schema_definition.structure["schema"]["fields"]:
-                field_name = field["name"]
-                field_type = field["type"]
-                is_list = False
-
-                clean_field_type = field_type
-                if field_type.endswith("[]"):
-                    is_list = True
-                    clean_field_type = field_type[:-2]
-                if "(" in clean_field_type:
-                    clean_field_type = clean_field_type[: clean_field_type.find("(")]
-
-                # let's make sure the type of the field is known, or create it if it's not
-                potential_definitions = find_definitions_by_name(clean_field_type)
-                if len(potential_definitions) != 1:
-                    if len(potential_definitions) == 0:
-                        raise LanguageError(
-                            f"Could not find AaC definition for type {clean_field_type} while loading {schema_definition.name}",
-                            get_location_str(field_type, schema_definition.lexemes),
-                        )
-                    else:
-                        raise LanguageError(
-                            f"Discovered multiple AaC definitions for type {clean_field_type} while loading {schema_definition.name}.  You may need to add a package name to differentiate.",
-                            get_location_str(field_type, schema_definition.lexemes),
-                        )
-
-                parsed_definition = potential_definitions[0]
-
-                create_schema_class(parsed_definition)
-
-                # since python is dynamically typed, we really don't have to worry about setting a type when we create the field
-                # we just need to make sure a reasonable default value is used, so for us that means an empty list or None
-                # Question:  is there ever a case where we may need a dict value?
-                if is_list:
-                    setattr(instance_class, field_name, [])
-                else:
-                    setattr(instance_class, field_name, None)
-
-            # finally store the class in the context
-            self.context_instance.fully_qualified_name_to_class[
-                fully_qualified_name
-            ] = instance_class
-            return instance_class
-
-        def create_object_instance(type_class: Type, fields: dict) -> Any:
-            result = type_class()
-            for field_name, field_value in fields.items():
-                setattr(result, field_name, field_value)
-            return result
-
-        def get_defined_fields(package: str, name: str) -> list[str]:
-            """Returns a list of defined fields for the given definition."""
-            result = []
-            defining_definition = None
-            for definition in self.get_definitions() + parsed_definitions:
-                if definition.name == name and definition.package == package:
-                    defining_definition = definition
-                    break
-            if (
-                "extends"
-                in defining_definition.structure[defining_definition.get_root_key()]
-            ):
-                for parent in defining_definition.structure[
-                    defining_definition.get_root_key()
-                ]["extends"]:
-                    result.extend(get_defined_fields(parent["package"], parent["name"]))
-            if "fields" in defining_definition.structure[definition.get_root_key()]:
-                result.extend(
-                    [
-                        field["name"]
-                        for field in definition.structure[definition.get_root_key()][
-                            "fields"
-                        ]
-                    ]
-                )
-            return result
-
-        def create_field_instance(
-            field_name: str,
-            field_type: str,
-            is_required: bool,
-            field_value: Any,
-            lexemes: list[Lexeme],
-        ) -> Any:
-            """Creates a instance of the given type and value."""
-            is_list = False
-            clean_field_type = field_type
-            if field_type.endswith("[]"):
-                is_list = True
-                clean_field_type = field_type[:-2]
-            if "(" in clean_field_type:
-                clean_field_type = clean_field_type[: clean_field_type.find("(")]
-
-            # now get the defining definition from the clean_field_type
-            defining_definitions = find_definitions_by_name(clean_field_type)
-            if not defining_definitions or len(defining_definitions) == 0:
-                raise LanguageError(
-                    f"Could not find definition for '{clean_field_type}'.",
-                    get_location_str(field_type, lexemes),
-                )
-            elif len(defining_definitions) > 1:
-                raise LanguageError(
-                    f"Found multiple definitions for '{clean_field_type}'.",
-                    get_location_str(field_type, lexemes),
-                )
-            defining_definition = defining_definitions[0]
-
-            if defining_definition.get_root_key() == "primitive":
-                # this is a primitive, so ensure the parsed value aligns with the type and return it
-                python_type = defining_definition.structure["primitive"]["python_type"]
-                if is_list:
-                    if not field_value:
-                        if is_required:
-                            raise LanguageError(message=f"Missing required field {field_name}.", location=None)
-                        field_value = []
-                    else:
-                        for item in field_value:
-                            if not isinstance(item, eval(python_type)):
-                                raise LanguageError(
-                                    message=f"Invalid value for field '{field_name}'.  Expected type '{python_type}', but found '{type(item)}'",
-                                    location=get_location_str(field_value, lexemes),
-                                )
-                else:
-                    if not field_value:
-                        if is_required:
-                            raise LanguageError(f"Missing required field {field_name}.")
-                    else:
-                        if "Any" != python_type:
-                            if not isinstance(field_value, eval(python_type)):
-                                raise LanguageError(
-                                    f"Invalid value for field '{field_name}'.  Expected type '{python_type}', but found '{type(field_value)}'",
-                                    get_location_str(field_value, lexemes),
-                                )
-                return field_value
-            elif defining_definition.get_root_key() == "enum":
-                # this is an enum, so ensure the parsed value aligns with the type and return it
-                enum_class = self.context_instance.fully_qualified_name_to_class[
-                    defining_definition.get_fully_qualified_name()
-                ]
-                if not enum_class:
-                    enum_class = create_enum_class(defining_definition)
-                if is_list:
-                    result = []
-                    for item in field_value:
-                        if not isinstance(item, str):
-                            raise LanguageError(
-                                f"Invalid value for field '{field_name}'.  Expected type 'str', but found '{type(item)}'",
-                                get_location_str(field_name, lexemes),
-                            )
-                        try:
-                            result.append(getattr(enum_class, item))
-                        except ValueError:
-                            raise LanguageError(
-                                f"{item} is not a valid value for enum {defining_definition.name}",
-                                get_location_str(item, lexemes),
-                            )
-                    return result
-                else:
-                    if not field_value:
-                        return None
-                    try:
-                        return self.create_aac_enum(
-                            defining_definition.get_fully_qualified_name(), field_value
-                        )
-                    except ValueError:
-                        raise LanguageError(
-                            f"{field_value} is not a valid value for enum {defining_definition.name}",
-                            get_location_str(field_value, lexemes),
-                        )
-            else:  # this isn't a primitive and isn't an enum, so it must be a schema
-                field_fully_qualified_name = (
-                    defining_definition.get_fully_qualified_name()
-                )
-
-                instance_class = self.context_instance.fully_qualified_name_to_class[
-                    field_fully_qualified_name
-                ]
-                if not instance_class:
-                    if defining_definition.get_root_key() == "schema":
-                        instance_class = create_schema_class(defining_definition)
-                    else:
-                        raise LanguageError(
-                            f"Unable to process AaC definition of type {field_fully_qualified_name} with root {defining_definition.get_root_key()}",
-                            get_location_str(field_name, lexemes),
-                        )
-                instance = None
-                if is_list:
-                    instance = []
-                    if not field_value:
-                        if is_required:
-                            raise LanguageError(f"Missing required field {field_name}")
-                    else:
-                        if not isinstance(field_value, list):
-                            if is_required:
-                                raise LanguageError(
-                                    f"Invalid parsed value for field '{field_name}'.  Expected type 'list', but found '{type(field_value)}'.  Value = {field_value}",
-                                    get_location_str(field_name, lexemes),
-                                )
-                            else:
-                                return instance
-                        for item in field_value:
-                            if not isinstance(item, dict):
-                                raise LanguageError(
-                                    f"Invalid parsed value for field '{field_name}'.  Expected type 'dict', but found '{type(item)}'. Value = {item}",
-                                    get_location_str(field_name, lexemes),
-                                )
-                            # go through the fields and create instances for each
-                            subfields = {}
-                            if "fields" not in defining_definition.structure["schema"]:
-                                raise LanguageError(
-                                    f"Schema '{defining_definition.name}' does not contain any fields.",
-                                    get_location_str(field_name, lexemes),
-                                )
-
-                            # make sure there are no undefined fields
-                            defined_field_names = get_defined_fields(
-                                defining_definition.package, defining_definition.name
-                            )
-                            item_field_names = [field for field in item.keys()]
-                            for item_field_name in item_field_names:
-                                if item_field_name not in defined_field_names:
-                                    raise LanguageError(
-                                        f"Found undefined field name '{item_field_name}' when expecting {defined_field_names} as defined in {defining_definition.name}",
-                                        get_location_str(item_field_name, lexemes),
-                                    )
-
-                            for subfield in defining_definition.structure["schema"][
-                                "fields"
-                            ]:
-                                subfield_name = subfield["name"]
-                                subfield_type = subfield["type"]
-                                subfield_is_required = False
-                                if "is_required" in subfield:
-                                    subfield_is_required = subfield["is_required"]
-                                subfield_value = None
-                                if subfield_name in item:
-                                    subfield_value = item[subfield_name]
-                                else:
-                                    if "default" in subfield:
-                                        # let's see if we need to cast the value
-                                        subfield_default_str = subfield["default"]
-                                        if isinstance(subfield_default_str, str):
-                                            type_map = {
-                                                "int": int,
-                                                "number": float,
-                                                "bool": lambda x: x.lower()
-                                                in ("yes", "true", "t", "1"),
-                                                "string": str,
-                                            }
-                                            if subfield_type in type_map:
-                                                subfield_value = type_map[
-                                                    subfield_type
-                                                ](subfield_default_str)
-                                        else:
-                                            subfield_value = subfield_default_str
-                                # we need to eliminate previously covered lexemes, so go through the list until we find subfield_name then add it and everything else
-                                found = False
-                                sub_lexemes = []
-                                for lex in lexemes:
-                                    if lex.value == subfield_name:
-                                        found = True
-                                        sub_lexemes.append(lex)
-                                    if found:
-                                        sub_lexemes.append(lex)
-                                subfields[subfield_name] = create_field_instance(
-                                    subfield_name,
-                                    subfield_type,
-                                    subfield_is_required,
-                                    subfield_value,
-                                    sub_lexemes,
-                                )
-                            instance.append(
-                                create_object_instance(instance_class, subfields)
-                            )
-                else:
-                    instance = None
-                    if not field_value:
-                        if is_required:
-                            raise LanguageError(
-                                f"Missing required field {field_name}",
-                                get_location_str(field_name, lexemes),
-                            )
-                        else:
-                            return instance
-                    if not isinstance(field_value, dict):
-                        # this is a complex type defined by a schema, with a field value so it should be a dict
-                        raise LanguageError(
-                            f"Invalid parsed value for field '{field_name}'.  Expected type 'dict', but found '{type(field_value)}'.  Value = {field_value}",
-                            get_location_str(field_name, lexemes),
-                        )
-
-                    # make sure there are no undefined fields
-                    defined_field_names = get_defined_fields(
-                        defining_definition.package, defining_definition.name
-                    )
-                    item_field_names = [field for field in field_value.keys()]
-                    for item_field_name in item_field_names:
-                        if item_field_name not in defined_field_names:
-                            raise LanguageError(
-                                f"Found undefined field name '{item_field_name}' when expecting {defined_field_names} as defined in {defining_definition.name}",
-                                get_location_str(item_field_name, lexemes),
-                            )
-
-                    subfields = {}
-                    if "fields" not in defining_definition.structure["schema"]:
-                        raise LanguageError(
-                            f"Schema '{defining_definition.name}' does not contain any fields.",
-                            get_location_str(field_name, lexemes),
-                        )
-                    for subfield in defining_definition.structure["schema"]["fields"]:
-                        subfield_name = subfield["name"]
-                        subfield_type = subfield["type"]
-                        subfield_is_required = False
-                        if "is_required" in subfield:
-                            subfield_is_required = subfield["is_required"]
-                        subfield_value = None
-                        if subfield_name in field_value:
-                            subfield_value = field_value[subfield_name]
-                        else:
-                            if "default" in subfield:
-                                # let's see if we need to cast the value
-                                subfield_default_str = subfield["default"]
-                                if isinstance(subfield_default_str, str):
-                                    type_map = {
-                                        "int": int,
-                                        "number": float,
-                                        "bool": lambda x: x.lower()
-                                        in ("yes", "true", "t", "1"),
-                                        "string": str,
-                                    }
-                                    if subfield_type in type_map:
-                                        subfield_value = type_map[subfield_type](
-                                            subfield_default_str
-                                        )
-                                else:
-                                    subfield_value = subfield_default_str
-                        # we need to eliminate previously covered lexemes, so go through the list until we find subfield_name then add it and everything else
-                        found = False
-                        sub_lexemes = []
-                        for lex in lexemes:
-                            if lex.value == subfield_name:
-                                found = True
-                                sub_lexemes.append(lex)
-                            if found:
-                                sub_lexemes.append(lex)
-                        subfields[subfield_name] = create_field_instance(
-                            subfield_name,
-                            subfield_type,
-                            subfield_is_required,
-                            subfield_value,
-                            sub_lexemes,
-                        )
-
-                    instance = create_object_instance(instance_class, subfields)
-
-                return instance
-
-        def create_definition_instance(definition: Definition) -> Any:
-            """Populates the instance field of a given definition."""
-            instance = None
-
-            defining_definition = None
-            for item in self.get_definitions() + parsed_definitions:
-                if item.get_root_key() == "schema":
-                    if "root" in item.structure["schema"]:
-                        if (
-                            definition.get_root_key()
-                            == item.structure["schema"]["root"]
-                        ):
-                            defining_definition = item
-
-            if not defining_definition:
-                raise LanguageError(
-                    f"Could not find definition for {definition.name} with root {definition.get_root_key()}",
-                    get_location_str(definition.get_root_key(), definition.lexemes),
-                )
-
-            if defining_definition.get_root_key() == "schema":
-                # since schemas are how we define "all the things" the root key of the defining definition should be 'schema'
-                create_schema_class(defining_definition)
-            else:
-                raise LanguageError(
-                    f"Definition for root key '{defining_definition.get_root_key()}' is not a Schema.",
-                    get_location_str(definition.get_root_key(), definition.lexemes),
-                )
-
-            instance = create_field_instance(
-                "root",
-                defining_definition.name,
-                True,
-                definition.structure[definition.get_root_key()],
-                definition.lexemes,
-            )
-
-            definition.instance = instance
-            return instance
-
-        # Start the load_definition function code here
-
-        fully_qualified_name_to_definition = {
-            definition.get_fully_qualified_name(): definition
-            for definition in parsed_definitions + self.get_definitions()
-            if "package" in definition.structure[definition.get_root_key()]
-        }
-
-        schema_defs_by_root = {}
-        for definition in self.get_definitions():
-            if definition.get_root_key() == "schema":
-                if definition.instance.root:
-                    schema_defs_by_root[definition.instance.root] = definition
-
-        result: list[Definition] = []
-        for definition in parsed_definitions:
-            # create and register the instance
-            create_definition_instance(definition)
-            result.append(definition)
-            self.context_instance.definitions.add(definition)
-            self.context_instance.fully_qualified_name_to_definition[
-                f"{definition.package}.{definition.name}"
-            ] = definition
-
-        return result
+        return parser.load_definitions(self, parsed_definitions)
 
     def remove_definitions(self, definitions: list[Definition]) -> None:
         """Remove the given definitions from the context."""
         for definition in definitions:
             self.context_instance.definitions.remove(definition)
             del self.context_instance.fully_qualified_name_to_definition[
                 f"{definition.package}.{definition.name}"
```

## Comparing `aac-0.4.3.dist-info/METADATA` & `aac-0.4.4.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: aac
-Version: 0.4.3
+Version: 0.4.4
 Summary: A distinctly different take on Model-Based System Engineering (MBSE) that allows a system modeller to define a system in simple yaml. 
 Keywords: MBSE
 Classifier: Programming Language :: Python :: 3.9
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Operating System :: OS Independent
 Classifier: Topic :: Scientific/Engineering
 Description-Content-Type: text/markdown
```

## Comparing `aac-0.4.3.dist-info/RECORD` & `aac-0.4.4.dist-info/RECORD`

 * *Files 3% similar despite different names*

```diff
@@ -1,14 +1,15 @@
-aac/__init__.py,sha256=PmdJQmLpXW63UBsClzAeXvW1mL6Mp9V63hTDtpZpGMc,681
+aac/__init__.py,sha256=66NMSYQXSPkhG_dxd2Rdjwy4Ukgt3BnKY1Bv34-RH0A,681
 aac/__main__.py,sha256=y4F8Ij8KtQ2ngIu2RhbNY50Scc58waKLhKUu4irkoVc,184
 aac/aac.aac,sha256=hW3mC_wcEOJNJNGgvgkVXU3Z8QZXAGfGG-iAQQ4sAhM,39404
 aac/context/__init__.py,sha256=KzlQOyArJrbh9jsb0BxEvT4DH6KGu-HLkXz0qvAhEGQ,93
 aac/context/constants.py,sha256=yZNSkbpfvEPPvMXHLt3xF8BuGN990FpP6SyRsM399L4,3340
 aac/context/definition.py,sha256=slApbPJFdBRUb91g0vbYv4Mq93NAFJ2Ub9ggMNVmoJk,3555
-aac/context/language_context.py,sha256=yp6PTTpDnWqpLEko6IZ5JdemRmr6hiZVExr3573Z5is,45417
+aac/context/definition_parser.py,sha256=ulSUVlnGdvpWf5tDUzP8h3peyYW9K9NrRik3jhoOrhI,36891
+aac/context/language_context.py,sha256=yWOQAEuthzZ1lUsQ7giYy6JxO8mfZqL6pV4XVBUQqaE,11942
 aac/context/language_error.py,sha256=mvwlIp4T3qqjxxhz9POZOVvm0xB-OgaS6BBaA36XTYo,416
 aac/context/lexeme.py,sha256=RPzYXOyNSb83bUNFnagayzrU5jUqfdxYzlTBF8SRPwU,1179
 aac/context/source_location.py,sha256=fZj9jj9rp7iFj7J5B_6CMCYlvReyxL1bpOuWNJsYMtQ,1193
 aac/context/util.py,sha256=qkzFKNk8L2yj7gJvZq6IBfSof5Hj01Ir9ES1aq3h778,2025
 aac/execute/__init__.py,sha256=l7xXXpX4FOMESojBmvsPxNv95g4vZxl93CIgslo3h5I,613
 aac/execute/aac_execution_result.py,sha256=O7bU3Ot3bpfK5XXOd6djSFKhiphtVnaXoK60z5R8PFw,4123
 aac/execute/command_line.py,sha256=JNi6mOzm3-EnuYs3Wx7jIBJTqHRmN5ypBKifDfbSASY,6357
@@ -72,12 +73,12 @@
 aac/plugins/root_schema_must_have_name/root_schema_must_have_name_impl.py,sha256=ecrzKVXFriH-pe7eq-hOnqrB3w4m-NvUpBk_r1otmrE,2751
 aac/plugins/unique_root_keys/__init__.py,sha256=lMp9qz4unAg_pj8A5Su7WycX8QWy5QqiIsXCq9pyZN0,1872
 aac/plugins/unique_root_keys/unique_root_keys.aac,sha256=rFo9iXlXiqC-i5cHhFFOiOYx813umZw568Z7bhz0b24,357
 aac/plugins/unique_root_keys/unique_root_keys_impl.py,sha256=BALEPQkTaWEQCV6ay1sN195tbO9year3znfMKlskhfg,1457
 aac/plugins/version/__init__.py,sha256=w-hFRq-1A3Ka1l_kziZ6Xr1SyXF8aC5Oo-Ud8SmjR24,1773
 aac/plugins/version/version.aac,sha256=_KsTx9u4KmwhorKgw7NkQoEr-9HnqZ40xKqqnZIom0E,226
 aac/plugins/version/version_impl.py,sha256=lFeo8cuDT6r8qVBuAHsEjE9nMDDhmW4_C2W-YI0zMzc,875
-aac-0.4.3.dist-info/METADATA,sha256=I2V5M9FCcNZaiJnNM1KxEpuXWuP41-rhSCg-bcGIoaU,13241
-aac-0.4.3.dist-info/WHEEL,sha256=oiQVh_5PnQM0E3gPdiz09WCNmwiHDMaGer_elqB3coM,92
-aac-0.4.3.dist-info/entry_points.txt,sha256=VlLg669v9njSJeVU9sRCXBWO7zp4pE_GkcH1Qm2RbeA,53
-aac-0.4.3.dist-info/top_level.txt,sha256=xOCuEGfR7nNuBR15J9eDu3CwMr8Rb2GEVL9HEilW1c4,4
-aac-0.4.3.dist-info/RECORD,,
+aac-0.4.4.dist-info/METADATA,sha256=Y_1vdtHwx0edHfH22hVtCobwYKxAPmS3BAA_Uq653Ys,13241
+aac-0.4.4.dist-info/WHEEL,sha256=oiQVh_5PnQM0E3gPdiz09WCNmwiHDMaGer_elqB3coM,92
+aac-0.4.4.dist-info/entry_points.txt,sha256=VlLg669v9njSJeVU9sRCXBWO7zp4pE_GkcH1Qm2RbeA,53
+aac-0.4.4.dist-info/top_level.txt,sha256=xOCuEGfR7nNuBR15J9eDu3CwMr8Rb2GEVL9HEilW1c4,4
+aac-0.4.4.dist-info/RECORD,,
```

