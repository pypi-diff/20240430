# Comparing `tmp/actoolkit-3.0.1b4-py3-none-any.whl.zip` & `tmp/actoolkit-3.0.1b5-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,56 +1,56 @@
-Zip file size: 124736 bytes, number of entries: 54
--rw-r--r--  2.0 unx    10160 b- defN 24-Apr-26 20:26 toolkit.py
--rw-r--r--  2.0 unx     1139 b- defN 24-Apr-26 20:26 astraSDK/__init__.py
--rw-r--r--  2.0 unx     3659 b- defN 24-Apr-26 20:26 astraSDK/apiresources.py
--rw-r--r--  2.0 unx    16993 b- defN 24-Apr-26 20:26 astraSDK/apps.py
--rw-r--r--  2.0 unx     8289 b- defN 24-Apr-26 20:26 astraSDK/backups.py
--rw-r--r--  2.0 unx     7355 b- defN 24-Apr-26 20:26 astraSDK/buckets.py
--rw-r--r--  2.0 unx     6972 b- defN 24-Apr-26 20:26 astraSDK/clouds.py
--rw-r--r--  2.0 unx    10776 b- defN 24-Apr-26 20:26 astraSDK/clusters.py
--rw-r--r--  2.0 unx    14439 b- defN 24-Apr-26 20:26 astraSDK/common.py
--rw-r--r--  2.0 unx     9115 b- defN 24-Apr-26 20:26 astraSDK/credentials.py
--rw-r--r--  2.0 unx     2663 b- defN 24-Apr-26 20:26 astraSDK/entitlements.py
--rw-r--r--  2.0 unx     7958 b- defN 24-Apr-26 20:26 astraSDK/groups.py
--rw-r--r--  2.0 unx     7162 b- defN 24-Apr-26 20:26 astraSDK/hooks.py
--rw-r--r--  2.0 unx    45273 b- defN 24-Apr-26 20:26 astraSDK/k8s.py
--rw-r--r--  2.0 unx     5458 b- defN 24-Apr-26 20:26 astraSDK/namespaces.py
--rw-r--r--  2.0 unx     3576 b- defN 24-Apr-26 20:26 astraSDK/notifications.py
--rw-r--r--  2.0 unx    10989 b- defN 24-Apr-26 20:26 astraSDK/protections.py
--rw-r--r--  2.0 unx     9735 b- defN 24-Apr-26 20:26 astraSDK/replications.py
--rw-r--r--  2.0 unx     5757 b- defN 24-Apr-26 20:26 astraSDK/rolebindings.py
--rw-r--r--  2.0 unx     7090 b- defN 24-Apr-26 20:26 astraSDK/scripts.py
--rw-r--r--  2.0 unx     9821 b- defN 24-Apr-26 20:26 astraSDK/settings.py
--rw-r--r--  2.0 unx     7083 b- defN 24-Apr-26 20:26 astraSDK/snapshots.py
--rw-r--r--  2.0 unx     2434 b- defN 24-Apr-26 20:26 astraSDK/storagebackends.py
--rw-r--r--  2.0 unx     5023 b- defN 24-Apr-26 20:26 astraSDK/storageclasses.py
--rw-r--r--  2.0 unx     9007 b- defN 24-Apr-26 20:26 astraSDK/users.py
--rw-r--r--  2.0 unx      883 b- defN 24-Apr-26 20:26 tkSrc/__init__.py
--rw-r--r--  2.0 unx    32031 b- defN 24-Apr-26 20:26 tkSrc/choices.py
--rw-r--r--  2.0 unx     3962 b- defN 24-Apr-26 20:26 tkSrc/classes.py
--rw-r--r--  2.0 unx    24645 b- defN 24-Apr-26 20:26 tkSrc/clone.py
--rw-r--r--  2.0 unx     2011 b- defN 24-Apr-26 20:26 tkSrc/copy.py
--rw-r--r--  2.0 unx    30083 b- defN 24-Apr-26 20:26 tkSrc/create.py
--rw-r--r--  2.0 unx    11071 b- defN 24-Apr-26 20:26 tkSrc/deploy.py
--rw-r--r--  2.0 unx     9791 b- defN 24-Apr-26 20:26 tkSrc/destroy.py
--rw-r--r--  2.0 unx    26842 b- defN 24-Apr-26 20:26 tkSrc/helpers.py
--rw-r--r--  2.0 unx     4964 b- defN 24-Apr-26 20:26 tkSrc/ipr.py
--rw-r--r--  2.0 unx    19364 b- defN 24-Apr-26 20:26 tkSrc/list.py
--rw-r--r--  2.0 unx    17049 b- defN 24-Apr-26 20:26 tkSrc/manage.py
--rw-r--r--  2.0 unx    81156 b- defN 24-Apr-26 20:26 tkSrc/parser.py
--rw-r--r--  2.0 unx     7187 b- defN 24-Apr-26 20:26 tkSrc/unmanage.py
--rw-r--r--  2.0 unx    12238 b- defN 24-Apr-26 20:26 tkSrc/update.py
--rw-r--r--  2.0 unx      446 b- defN 24-Apr-26 20:26 tkSrc/templates/jinja/app.jinja
--rw-r--r--  2.0 unx      532 b- defN 24-Apr-26 20:26 tkSrc/templates/jinja/appVault.jinja
--rw-r--r--  2.0 unx      406 b- defN 24-Apr-26 20:26 tkSrc/templates/jinja/backup.jinja
--rw-r--r--  2.0 unx      374 b- defN 24-Apr-26 20:26 tkSrc/templates/jinja/hook.jinja
--rw-r--r--  2.0 unx      277 b- defN 24-Apr-26 20:26 tkSrc/templates/jinja/ipr.jinja
--rw-r--r--  2.0 unx      417 b- defN 24-Apr-26 20:26 tkSrc/templates/jinja/protection.jinja
--rw-r--r--  2.0 unx      584 b- defN 24-Apr-26 20:26 tkSrc/templates/jinja/restore.jinja
--rw-r--r--  2.0 unx      533 b- defN 24-Apr-26 20:26 tkSrc/templates/jinja/snapshot.jinja
--rw-r--r--  2.0 unx    11357 b- defN 24-Apr-26 20:26 actoolkit-3.0.1b4.dist-info/LICENSE
--rw-r--r--  2.0 unx     9193 b- defN 24-Apr-26 20:26 actoolkit-3.0.1b4.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-Apr-26 20:26 actoolkit-3.0.1b4.dist-info/WHEEL
--rw-r--r--  2.0 unx       43 b- defN 24-Apr-26 20:26 actoolkit-3.0.1b4.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       23 b- defN 24-Apr-26 20:26 actoolkit-3.0.1b4.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     4255 b- defN 24-Apr-26 20:26 actoolkit-3.0.1b4.dist-info/RECORD
-54 files, 539735 bytes uncompressed, 118150 bytes compressed:  78.1%
+Zip file size: 124845 bytes, number of entries: 54
+-rw-r--r--  2.0 unx    10194 b- defN 24-Apr-29 21:01 toolkit.py
+-rw-r--r--  2.0 unx     1139 b- defN 24-Apr-29 21:01 astraSDK/__init__.py
+-rw-r--r--  2.0 unx     3659 b- defN 24-Apr-29 21:01 astraSDK/apiresources.py
+-rw-r--r--  2.0 unx    16993 b- defN 24-Apr-29 21:01 astraSDK/apps.py
+-rw-r--r--  2.0 unx     8289 b- defN 24-Apr-29 21:01 astraSDK/backups.py
+-rw-r--r--  2.0 unx     7355 b- defN 24-Apr-29 21:01 astraSDK/buckets.py
+-rw-r--r--  2.0 unx     6972 b- defN 24-Apr-29 21:01 astraSDK/clouds.py
+-rw-r--r--  2.0 unx    10776 b- defN 24-Apr-29 21:01 astraSDK/clusters.py
+-rw-r--r--  2.0 unx    14439 b- defN 24-Apr-29 21:01 astraSDK/common.py
+-rw-r--r--  2.0 unx     9115 b- defN 24-Apr-29 21:01 astraSDK/credentials.py
+-rw-r--r--  2.0 unx     2663 b- defN 24-Apr-29 21:01 astraSDK/entitlements.py
+-rw-r--r--  2.0 unx     7958 b- defN 24-Apr-29 21:01 astraSDK/groups.py
+-rw-r--r--  2.0 unx     7162 b- defN 24-Apr-29 21:01 astraSDK/hooks.py
+-rw-r--r--  2.0 unx    45273 b- defN 24-Apr-29 21:01 astraSDK/k8s.py
+-rw-r--r--  2.0 unx     5458 b- defN 24-Apr-29 21:01 astraSDK/namespaces.py
+-rw-r--r--  2.0 unx     3576 b- defN 24-Apr-29 21:01 astraSDK/notifications.py
+-rw-r--r--  2.0 unx    11162 b- defN 24-Apr-29 21:01 astraSDK/protections.py
+-rw-r--r--  2.0 unx     9735 b- defN 24-Apr-29 21:01 astraSDK/replications.py
+-rw-r--r--  2.0 unx     5757 b- defN 24-Apr-29 21:01 astraSDK/rolebindings.py
+-rw-r--r--  2.0 unx     7090 b- defN 24-Apr-29 21:01 astraSDK/scripts.py
+-rw-r--r--  2.0 unx     9821 b- defN 24-Apr-29 21:01 astraSDK/settings.py
+-rw-r--r--  2.0 unx     7083 b- defN 24-Apr-29 21:01 astraSDK/snapshots.py
+-rw-r--r--  2.0 unx     2434 b- defN 24-Apr-29 21:01 astraSDK/storagebackends.py
+-rw-r--r--  2.0 unx     5023 b- defN 24-Apr-29 21:01 astraSDK/storageclasses.py
+-rw-r--r--  2.0 unx     9007 b- defN 24-Apr-29 21:01 astraSDK/users.py
+-rw-r--r--  2.0 unx      883 b- defN 24-Apr-29 21:01 tkSrc/__init__.py
+-rw-r--r--  2.0 unx    32031 b- defN 24-Apr-29 21:01 tkSrc/choices.py
+-rw-r--r--  2.0 unx     3992 b- defN 24-Apr-29 21:01 tkSrc/classes.py
+-rw-r--r--  2.0 unx    24437 b- defN 24-Apr-29 21:01 tkSrc/clone.py
+-rw-r--r--  2.0 unx     2011 b- defN 24-Apr-29 21:01 tkSrc/copy.py
+-rw-r--r--  2.0 unx    29823 b- defN 24-Apr-29 21:01 tkSrc/create.py
+-rw-r--r--  2.0 unx    11098 b- defN 24-Apr-29 21:01 tkSrc/deploy.py
+-rw-r--r--  2.0 unx     9743 b- defN 24-Apr-29 21:01 tkSrc/destroy.py
+-rw-r--r--  2.0 unx    26916 b- defN 24-Apr-29 21:01 tkSrc/helpers.py
+-rw-r--r--  2.0 unx     4912 b- defN 24-Apr-29 21:01 tkSrc/ipr.py
+-rw-r--r--  2.0 unx    19392 b- defN 24-Apr-29 21:01 tkSrc/list.py
+-rw-r--r--  2.0 unx    16912 b- defN 24-Apr-29 21:01 tkSrc/manage.py
+-rw-r--r--  2.0 unx    81403 b- defN 24-Apr-29 21:01 tkSrc/parser.py
+-rw-r--r--  2.0 unx     7249 b- defN 24-Apr-29 21:01 tkSrc/unmanage.py
+-rw-r--r--  2.0 unx    12344 b- defN 24-Apr-29 21:01 tkSrc/update.py
+-rw-r--r--  2.0 unx      446 b- defN 24-Apr-29 21:01 tkSrc/templates/jinja/app.jinja
+-rw-r--r--  2.0 unx      532 b- defN 24-Apr-29 21:01 tkSrc/templates/jinja/appVault.jinja
+-rw-r--r--  2.0 unx      406 b- defN 24-Apr-29 21:01 tkSrc/templates/jinja/backup.jinja
+-rw-r--r--  2.0 unx      374 b- defN 24-Apr-29 21:01 tkSrc/templates/jinja/hook.jinja
+-rw-r--r--  2.0 unx      277 b- defN 24-Apr-29 21:01 tkSrc/templates/jinja/ipr.jinja
+-rw-r--r--  2.0 unx      417 b- defN 24-Apr-29 21:01 tkSrc/templates/jinja/protection.jinja
+-rw-r--r--  2.0 unx      584 b- defN 24-Apr-29 21:01 tkSrc/templates/jinja/restore.jinja
+-rw-r--r--  2.0 unx      533 b- defN 24-Apr-29 21:01 tkSrc/templates/jinja/snapshot.jinja
+-rw-r--r--  2.0 unx    11357 b- defN 24-Apr-29 21:02 actoolkit-3.0.1b5.dist-info/LICENSE
+-rw-r--r--  2.0 unx     9193 b- defN 24-Apr-29 21:02 actoolkit-3.0.1b5.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-Apr-29 21:02 actoolkit-3.0.1b5.dist-info/WHEEL
+-rw-r--r--  2.0 unx       43 b- defN 24-Apr-29 21:02 actoolkit-3.0.1b5.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       23 b- defN 24-Apr-29 21:02 actoolkit-3.0.1b5.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     4255 b- defN 24-Apr-29 21:02 actoolkit-3.0.1b5.dist-info/RECORD
+54 files, 539811 bytes uncompressed, 118259 bytes compressed:  78.1%
```

## zipnote {}

```diff
@@ -138,26 +138,26 @@
 
 Filename: tkSrc/templates/jinja/restore.jinja
 Comment: 
 
 Filename: tkSrc/templates/jinja/snapshot.jinja
 Comment: 
 
-Filename: actoolkit-3.0.1b4.dist-info/LICENSE
+Filename: actoolkit-3.0.1b5.dist-info/LICENSE
 Comment: 
 
-Filename: actoolkit-3.0.1b4.dist-info/METADATA
+Filename: actoolkit-3.0.1b5.dist-info/METADATA
 Comment: 
 
-Filename: actoolkit-3.0.1b4.dist-info/WHEEL
+Filename: actoolkit-3.0.1b5.dist-info/WHEEL
 Comment: 
 
-Filename: actoolkit-3.0.1b4.dist-info/entry_points.txt
+Filename: actoolkit-3.0.1b5.dist-info/entry_points.txt
 Comment: 
 
-Filename: actoolkit-3.0.1b4.dist-info/top_level.txt
+Filename: actoolkit-3.0.1b5.dist-info/top_level.txt
 Comment: 
 
-Filename: actoolkit-3.0.1b4.dist-info/RECORD
+Filename: actoolkit-3.0.1b5.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## toolkit.py

```diff
@@ -166,14 +166,16 @@
         )
 
     # Manually passing args into argparse via parse_args() shouldn't include the function name
     argv = argv[1:] if "toolkit" in argv[0] else argv
     tkParser = tkSrc.parser.ToolkitParser(acl, plaidMode=plaidMode, v3=v3)
     parser = tkParser.main()
     args = parser.parse_args(args=argv)
+    tkParser, parser = None, None  # Memory optimization
+
     if args.v3:
         v3_dict = {"deploy": ["acp", "chart"]}
         v3_dict.update(
             dict.fromkeys(
                 ["create", "destroy"],
                 [
                     "backup",
@@ -216,40 +218,42 @@
                     "restores",
                     "schedules",
                     "secrets",
                     "snapshots",
                 ],
             )
         )
-        tkSrc.helpers.checkv3Support(args, parser, v3_dict)
+        tkSrc.helpers.checkv3Support(args, v3_dict)
     if args.dry_run and not args.v3:
-        parser.error("--dry-run can only be used in conjunction with --v3")
+        tkSrc.helpers.parserError("--dry-run can only be used in conjunction with --v3")
     elif args.skip_tls_verify and not args.v3:
-        parser.error("--insecure-skip-tls-verify can only be used in conjunction with --v3")
+        tkSrc.helpers.parserError(
+            "--insecure-skip-tls-verify can only be used in conjunction with --v3"
+        )
 
     if args.subcommand == "deploy":
-        tkSrc.deploy.main(args, parser, ard)
+        tkSrc.deploy.main(args, ard)
     elif args.subcommand == "clone" or args.subcommand == "restore":
-        tkSrc.clone.main(args, parser, ard)
+        tkSrc.clone.main(args, ard)
     elif args.subcommand == "ipr":
-        tkSrc.ipr.main(args, parser, ard)
+        tkSrc.ipr.main(args, ard)
     elif args.subcommand == "list" or args.subcommand == "get":
         tkSrc.list.main(args)
     elif args.subcommand == "copy":
         tkSrc.copy.main(args)
     elif args.subcommand == "create":
-        tkSrc.create.main(args, parser, ard)
+        tkSrc.create.main(args, ard)
     elif args.subcommand == "manage" or args.subcommand == "define":
-        tkSrc.manage.main(args, parser, ard)
+        tkSrc.manage.main(args, ard)
     elif args.subcommand == "destroy":
-        tkSrc.destroy.main(args, parser, ard)
+        tkSrc.destroy.main(args, ard)
     elif args.subcommand == "unmanage":
-        tkSrc.unmanage.main(args, parser, ard)
+        tkSrc.unmanage.main(args, ard)
     elif args.subcommand == "update":
-        tkSrc.update.main(args, parser, ard)
+        tkSrc.update.main(args, ard)
 
 
 if __name__ == "__main__":
     try:
         main()
     except KeyboardInterrupt:
         pass
```

## astraSDK/protections.py

```diff
@@ -34,26 +34,29 @@
                 yaml: output in yaml"""
         self.quiet = quiet
         self.verbose = verbose
         self.output = output
         super().__init__()
         self.apps = getApps(quiet=True, verbose=verbose).main()
 
-    def main(self, appFilter=None):
+    def main(self, appFilter=None, clusterFilter=None):
         if self.apps is False:
             print("Call to getApps() failed")
             return False
 
         protections = {}
         protections["items"] = []
 
         for app in self.apps["items"]:
             if appFilter:
                 if app["name"] != appFilter and app["id"] != appFilter:
                     continue
+            if clusterFilter:
+                if app["clusterName"] != clusterFilter and app["clusterID"] != clusterFilter:
+                    continue
             endpoint = f"k8s/v1/apps/{app['id']}/schedules"
             url = self.base + endpoint
 
             data = {}
             params = {}
 
             ret = super().apicall(
```

## tkSrc/classes.py

```diff
@@ -11,14 +11,16 @@
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 """
 
+from tkSrc.helpers import parserError
+
 
 class ArgparseChoicesLists:
     """This Class defines a set of Lists which are used in the "choices" section of the Argparse
     parser. An empty list is perfectly valid, so all possible lists are pre-defined. These lists
     are added to by tkSrc/choices.py, and then used in tkSrc/parser.py"""
 
     def __init__(self):
@@ -89,18 +91,18 @@
                 for x in (
                     y for y in getattr(self, name)["items"] if self.recursiveGet(fKey, y) == fVal
                 )
             ]
         except TypeError:
             return []
 
-    def getSingleDict(self, name, key, value, parser):
+    def getSingleDict(self, name, key, value):
         """Returns a single dict within the "items" list of the main resource dict, based on a
         matching key/value pair"""
         try:
             return next(
                 x for x in getattr(self, name)["items"] if self.recursiveGet(key, x) == value
             )
         except StopIteration:
-            parser.error(
+            parserError(
                 f"A resource with a '{key}:{value}' pair in the '{name}' dict was not found"
             )
```

## tkSrc/clone.py

```diff
@@ -257,28 +257,27 @@
 
 def doV3Clone(
     v3,
     dry_run,
     skip_tls_verify,
     quiet,
     verbose,
-    parser,
     ard,
     sourceApp,
     appName,
     cluster,
     crossCluster,
     newStorageClass=None,
     newNamespace=None,
     multiNsMapping=None,
 ):
     """Performs a live clone by first creating either a snapshot (same-cluster) or backup (cross-
     cluster) of the sourcApp, and then it calls doV3Restore for the remaining restore operation,
     which consists of a BackupRestore or SnapshotRestore and an Application definition."""
-    bucketDict = helpers.getCommonAppVault(v3, cluster, parser, skip_tls_verify=skip_tls_verify)
+    bucketDict = helpers.getCommonAppVault(v3, cluster, skip_tls_verify=skip_tls_verify)
     if dry_run == "client":
         print(f"# This must be applied on the source cluster specified by '{v3}'")
     if crossCluster:
         restoreSourceDict = create.createV3Backup(
             v3,
             dry_run,
             skip_tls_verify,
@@ -313,15 +312,14 @@
         restoreSourceDict = waitForDpCompletion(restoreSourceDict, v3, skip_tls_verify)
     doV3Restore(
         v3,
         dry_run,
         skip_tls_verify,
         quiet,
         verbose,
-        parser,
         ard,
         restoreSourceDict,
         appName,
         cluster,
         crossCluster,
         newStorageClass=newStorageClass,
         newNamespace=newNamespace,
@@ -331,15 +329,14 @@
 
 def setupV3Restore(
     v3,
     dry_run,
     skip_tls_verify,
     quiet,
     verbose,
-    parser,
     ard,
     restoreSource,
     appName,
     cluster,
     crossCluster,
     newStorageClass=None,
     newNamespace=None,
@@ -357,17 +354,17 @@
         ).main("backups")
     if ard.needsattr("snapshots"):
         ard.snapshots = astraSDK.k8s.getResources(
             config_context=v3, skip_tls_verify=skip_tls_verify
         ).main("snapshots")
     # For restore, we need to figure out if a backup or a snapshot source was provided
     if restoreSource in ard.buildList("backups", "metadata.name"):
-        restoreSourceDict = ard.getSingleDict("backups", "metadata.name", restoreSource, parser)
+        restoreSourceDict = ard.getSingleDict("backups", "metadata.name", restoreSource)
     elif restoreSource in ard.buildList("snapshots", "metadata.name"):
-        restoreSourceDict = ard.getSingleDict("snapshots", "metadata.name", restoreSource, parser)
+        restoreSourceDict = ard.getSingleDict("snapshots", "metadata.name", restoreSource)
         # crossCluster requires a backup, so create a backup from the specified snapshot
         if crossCluster:
             if dry_run == "client":
                 print(f"# This must be applied on the source cluster specified by '{v3}'")
             restoreSourceDict = create.createV3Backup(
                 v3,
                 dry_run,
@@ -387,22 +384,23 @@
                     + "Backup.status.appArchivePath"
                 )
                 if dry_run == "client":
                     print("---")
             else:
                 restoreSourceDict = waitForDpCompletion(restoreSourceDict, v3, skip_tls_verify)
     else:
-        parser.error(f"the restoreSource '{restoreSource}' is not a valid backup or snapshot")
+        helpers.parserError(
+            f"the restoreSource '{restoreSource}' is not a valid backup or snapshot"
+        )
     doV3Restore(
         v3,
         dry_run,
         skip_tls_verify,
         quiet,
         verbose,
-        parser,
         ard,
         restoreSourceDict,
         appName,
         cluster,
         crossCluster,
         newStorageClass=newStorageClass,
         newNamespace=newNamespace,
@@ -414,55 +412,51 @@
 
 def doV3Restore(
     v3,
     dry_run,
     skip_tls_verify,
     quiet,
     verbose,
-    parser,
     ard,
     restoreSourceDict,
     appName,
     cluster,
     crossCluster,
     newStorageClass=None,
     newNamespace=None,
     multiNsMapping=None,
     filterSelection=None,
     filterSet=None,
 ):
     """Restores an app by creating a BackupRestore or SnapshotRestore (based on the contents of
     restoreSourceDict), and then creates the Application definition."""
-    oApp = ard.getSingleDict(
-        "apps", "metadata.name", restoreSourceDict["spec"]["applicationRef"], parser
-    )
+    oApp = ard.getSingleDict("apps", "metadata.name", restoreSourceDict["spec"]["applicationRef"])
     namespaceMapping = helpers.createNamespaceMapping(
-        oApp["spec"]["includedNamespaces"], newNamespace, multiNsMapping, parser
+        oApp["spec"]["includedNamespaces"], newNamespace, multiNsMapping
     )
     template = helpers.setupJinja("restore")
     try:
         v3_gen = yaml.safe_load_all(
             template.render(
                 kind=restoreSourceDict["kind"],
                 restoreName=f"{appName}-restore-",
                 appArchivePath=restoreSourceDict["status"]["appArchivePath"],
                 appVaultRef=(
                     helpers.swapAppVaultRef(
                         restoreSourceDict["spec"]["appVaultRef"],
                         v3,
                         cluster,
-                        parser,
                         skip_tls_verify=skip_tls_verify,
                     )
                     if crossCluster
                     else restoreSourceDict["spec"]["appVaultRef"]
                 ),
                 namespaceMapping=helpers.prependDump(namespaceMapping, prepend=4),
                 resourceFilter=helpers.prependDump(
-                    helpers.createFilterSet(filterSelection, filterSet, None, parser, v3=True),
+                    helpers.createFilterSet(filterSelection, filterSet, None, v3=True),
                     prepend=4,
                 ),
                 newStorageClass=newStorageClass,
                 appName=appName,
                 appSpec=helpers.prependDump(
                     helpers.updateNamespaceSpec(namespaceMapping, copy.deepcopy(oApp["spec"])),
                     prepend=2,
@@ -485,27 +479,27 @@
                     v3_dict["metadata"]["namespace"],
                     v3_dict,
                     version="v1",
                     group="astra.netapp.io",
                 )
     except KeyError as err:
         rName = restoreSourceDict["metadata"]["name"]
-        parser.error(
+        helpers.parserError(
             f"{err} key not found in '{rName}' object, please ensure "
             f"{rName}' is a valid backup/snapshot"
         )
 
 
-def main(args, parser, ard):
+def main(args, ard):
     # Ensure proper use of resource filters
     if args.subcommand == "restore":
         if (args.filterSelection and not args.filterSet) or (
             args.filterSet and not args.filterSelection
         ):
-            parser.error(
+            helpers.parserError(
                 "either both or none of --filterSelection and --filterSet should be specified"
             )
 
     if args.v3:
         # args.newNamespace is not required, but we do need it set for proper YAML generation
         if args.newNamespace is None and args.multiNsMapping is None:
             args.newNamespace = args.appName
@@ -517,15 +511,14 @@
         if args.subcommand == "clone":
             doV3Clone(
                 args.v3,
                 args.dry_run,
                 args.skip_tls_verify,
                 args.quiet,
                 args.verbose,
-                parser,
                 ard,
                 args.sourceApp,
                 args.appName,
                 args.cluster,
                 not helpers.sameK8sCluster(
                     args.v3, args.cluster, skip_tls_verify=args.skip_tls_verify
                 ),
@@ -536,15 +529,14 @@
         elif args.subcommand == "restore":
             setupV3Restore(
                 args.v3,
                 args.dry_run,
                 args.skip_tls_verify,
                 args.quiet,
                 args.verbose,
-                parser,
                 ard,
                 args.restoreSource,
                 args.appName,
                 args.cluster,
                 not helpers.sameK8sCluster(
                     args.v3, args.cluster, skip_tls_verify=args.skip_tls_verify
                 ),
@@ -579,44 +571,43 @@
             if args.restoreSource in ard.buildList("backups", "id"):
                 dataProtections = ard.backups
                 backup = args.restoreSource
             elif args.restoreSource in ard.buildList("snapshots", "id"):
                 dataProtections = ard.snapshots
                 snapshot = args.restoreSource
             else:
-                parser.error(
+                helpers.parserError(
                     f"the restoreSource '{args.restoreSource}' is not a valid backup or snapshot"
                 )
             for app in ard.apps["items"]:
                 for dp in dataProtections["items"]:
                     if app["id"] == dp["appID"] and dp["id"] == args.restoreSource:
                         oApp = app
         # Ensure appIDstr is not equal to "", if so bad values were passed in with plaidMode
         if not oApp:
-            parser.error(
+            helpers.parserError(
                 "the corresponding app was not found in the system, please check "
                 + "your inputs and try again."
             )
 
         doClone(
-            helpers.isRFC1123(args.appName, parser=parser),
+            helpers.isRFC1123(args.appName),
             args.cluster,
             oApp,
             helpers.createNamespaceMapping(
-                oApp["namespaceScopedResources"], args.newNamespace, args.multiNsMapping, parser
+                oApp["namespaceScopedResources"], args.newNamespace, args.multiNsMapping
             ),
             args.newStorageClass,
             backup,
             snapshot,
             args.sourceApp,
             helpers.createFilterSet(
                 args.filterSelection,
                 args.filterSet,
                 astraSDK.apps.getAppAssets().main(oApp["id"]),
-                parser,
             ),
             pollTimer=args.pollTimer,
             background=args.background,
             verb=args.subcommand,
             verbose=args.verbose,
             quiet=args.quiet,
         )
```

## tkSrc/create.py

```diff
@@ -22,24 +22,24 @@
 import time
 import yaml
 
 import astraSDK
 from tkSrc import helpers
 
 
-def monitorProtectionTask(protectionID, protectionType, appID, background, pollTimer, parser):
+def monitorProtectionTask(protectionID, protectionType, appID, background, pollTimer):
     """Ensure backup/snapshot task was created successfully, then monitor"""
     if protectionID is False:
         return False
     if protectionType == "backup":
         protection_class = astraSDK.backups.getBackups()
     elif protectionType == "snapshot":
         protection_class = astraSDK.snapshots.getSnaps()
     else:
-        parser.error(f"unknown protection type: {protectionType}")
+        helpers.parserError(f"unknown protection type: {protectionType}")
 
     print(f"Starting {protectionType} of {appID}")
     if background:
         print(
             f"Background {protectionType} flag selected, run 'list {protectionType}s' to get status"
         )
         return True
@@ -71,15 +71,15 @@
         except Exception as err:
             err_counter.append(err)
     for err in set([str(e) for e in err_counter]):
         protection_class.printError(err + "\n")
     return False
 
 
-def monitorV3ProtectionTask(protection, pollTimer, parser, v3, skip_tls_verify):
+def monitorV3ProtectionTask(protection, pollTimer, v3, skip_tls_verify):
     name = protection["metadata"]["name"]
     singular = protection["kind"].lower()
     resource_class = astraSDK.k8s.getResources(config_context=v3, skip_tls_verify=skip_tls_verify)
     print(f"Waiting for {singular} to complete.", end="")
     sys.stdout.flush()
     err_counter = []
     while len(err_counter) < 3:
@@ -118,32 +118,32 @@
         f"kubectl --insecure-skip-tls-verify={skip_tls_verify} --context={context} "
         f"-v={6 if verbose else 0} apply --dry_run={dry_run if dry_run else 'none'} -f "
         f"{helpers.getOperatorURL(operator_version)}",
         env={"KUBECONFIG": os.path.expanduser(config_file)} if config_file != "None" else None,
     )
 
 
-def createCloudCredential(quiet, verbose, path, name, cloudType, parser):
+def createCloudCredential(quiet, verbose, path, name, cloudType):
     """Create a public cloud (AWS/Azure/GCP) credential via the API"""
-    credDict = helpers.openJson(path, parser)
+    credDict = helpers.openJson(path)
     encodedStr = base64.b64encode(json.dumps(credDict).encode("utf-8")).decode("utf-8")
     rc = astraSDK.credentials.createCredential(quiet=quiet, verbose=verbose).main(
         "astra-sa@" + name,
         "service-account",
         {"base64": encodedStr},
         cloudType,
     )
     if rc:
         return rc
     raise SystemExit("astraSDK.credentials.createCredential() failed")
 
 
-def createV3CloudCredential(v3, dry_run, skip_tls_verify, quiet, verbose, path, name, parser):
+def createV3CloudCredential(v3, dry_run, skip_tls_verify, quiet, verbose, path, name):
     """Create a public cloud (AWS/Azure/GCP) credential via a Kubernetes secret"""
-    credDict = helpers.openJson(path, parser)
+    credDict = helpers.openJson(path)
     encodedStr = base64.b64encode(json.dumps(credDict).encode("utf-8")).decode("utf-8")
     data = {"credentials.json": encodedStr}
     namespace = "astra-connector"
     if dry_run == "client":
         secret_dict = {
             "apiVersion": "v1",
             "kind": "Secret",
@@ -159,15 +159,15 @@
         dry_run=dry_run,
         verbose=verbose,
         config_context=v3,
         skip_tls_verify=skip_tls_verify,
     ).main(f"{name}-", data, generateName=True, namespace=namespace)
 
 
-def createLdapCredential(quiet, verbose, username, password, parser):
+def createLdapCredential(quiet, verbose, username, password):
     """Create an LDAP bind credential via the API"""
     bindDn = base64.b64encode(username.encode("utf-8")).decode("utf-8")
     enpass = base64.b64encode(password.encode("utf-8")).decode("utf-8")
     rc = astraSDK.credentials.createCredential(quiet=quiet, verbose=verbose).main(
         "ldapBindCredential-" + username.split("@")[0],
         "generic",
         {"bindDn": bindDn, "password": enpass},
@@ -264,32 +264,31 @@
 
 def createV3Hook(
     v3,
     dry_run,
     skip_tls_verify,
     quiet,
     verbose,
-    parser,
     app,
     name,
     filePath,
     operation,
     hookArguments=None,
     containerImage=None,
     namespace=None,
     podName=None,
     label=None,
     containerName=None,
 ):
     """Creates an exec hook via a Kubernetes custom resource"""
-    encodedStr = helpers.openScript(filePath, parser)
+    encodedStr = helpers.openScript(filePath)
     template = helpers.setupJinja("hook")
     v3_dict = yaml.safe_load(
         template.render(
-            name=helpers.isRFC1123(name, parser=parser),
+            name=helpers.isRFC1123(name),
             action=operation.split("-")[1],
             appName=app,
             arguments=helpers.prependDump(helpers.createHookList(hookArguments), prepend=4),
             hookSource=encodedStr,
             matchingCriteria=helpers.prependDump(
                 helpers.createCriteriaList(
                     containerImage if containerImage else [],
@@ -413,60 +412,57 @@
             v3_dict["metadata"]["namespace"],
             v3_dict,
             version="v1",
             group="astra.netapp.io",
         )
 
 
-def main(args, parser, ard):
+def main(args, ard):
     if args.objectType == "backup":
         if args.v3:
             if ard.needsattr("buckets"):
                 ard.buckets = astraSDK.k8s.getResources(
                     config_context=args.v3, skip_tls_verify=args.skip_tls_verify
                 ).main("appvaults")
             if args.bucket is None:
-                args.bucket = ard.getSingleDict("buckets", "status.state", "available", parser)[
-                    "metadata"
-                ]["name"]
+                args.bucket = ard.getSingleDict("buckets", "status.state", "available")["metadata"][
+                    "name"
+                ]
             backup = createV3Backup(
                 args.v3,
                 args.dry_run,
                 args.skip_tls_verify,
                 args.quiet,
                 args.verbose,
                 args.name,
                 args.app,
                 args.bucket,
                 args.snapshot,
                 args.reclaimPolicy,
             )
             if backup and not args.dry_run and not args.background:
-                monitorV3ProtectionTask(
-                    backup, args.pollTimer, parser, args.v3, args.skip_tls_verify
-                )
+                monitorV3ProtectionTask(backup, args.pollTimer, args.v3, args.skip_tls_verify)
         else:
             protectionID = astraSDK.backups.takeBackup(quiet=args.quiet, verbose=args.verbose).main(
                 args.app,
-                helpers.isRFC1123(args.name, parser=parser),
+                helpers.isRFC1123(args.name),
                 bucketID=args.bucket,
                 snapshotID=args.snapshot,
             )
             rc = monitorProtectionTask(
                 protectionID,
                 args.objectType,
                 args.app,
                 args.background,
                 args.pollTimer,
-                parser,
             )
             if rc is False:
                 raise SystemExit("monitorProtectionTask() failed")
     elif args.objectType == "cluster":
-        kubeconfigDict = helpers.openYaml(args.filePath, parser)
+        kubeconfigDict = helpers.openYaml(args.filePath)
         encodedStr = base64.b64encode(json.dumps(kubeconfigDict).encode("utf-8")).decode("utf-8")
         rc = astraSDK.credentials.createCredential(quiet=args.quiet, verbose=args.verbose).main(
             kubeconfigDict["clusters"][0]["name"],
             "kubeconfig",
             {"base64": encodedStr},
             cloudName="private",
         )
@@ -479,17 +475,17 @@
             if rc is False:
                 raise SystemExit("astraSDK.clusters.createCluster() failed")
         else:
             raise SystemExit("astraSDK.credentials.createCredential() failed")
     elif args.objectType == "group":
         ldapGroups = astraSDK.groups.getLdapGroups().main(dnFilter=args.dn, matchType="eq")
         if len(ldapGroups["items"]) == 0:
-            parser.error(f"0 LDAP groups found with DN '{args.dn}'")
+            helpers.parserError(f"0 LDAP groups found with DN '{args.dn}'")
         elif len(ldapGroups["items"]) > 1:
-            parser.error(f"multiple LDAP users found with DN '{args.dn}'")
+            helpers.parserError(f"multiple LDAP users found with DN '{args.dn}'")
         # First create the group
         grc = astraSDK.groups.createGroup(quiet=args.quiet, verbose=args.verbose).main(args.dn)
         if grc:
             # Next create the role binding
             if not astraSDK.rolebindings.createRolebinding(
                 quiet=args.quiet, verbose=args.verbose
             ).main(
@@ -506,15 +502,14 @@
         if args.v3:
             createV3Hook(
                 args.v3,
                 args.dry_run,
                 args.skip_tls_verify,
                 args.quiet,
                 args.verbose,
-                parser,
                 args.app,
                 args.name,
                 args.filePath,
                 args.operation,
                 hookArguments=args.hookArguments,
                 containerImage=args.containerImage,
                 namespace=args.namespace,
@@ -537,19 +532,17 @@
                     args.label,
                     args.containerName,
                 ),
             )
             if rc is False:
                 raise SystemExit("astraSDK.hooks.createHook() failed")
     elif args.objectType == "ldap":
-        credential = createLdapCredential(
-            args.quiet, args.verbose, args.username, args.password, parser
-        )
+        credential = createLdapCredential(args.quiet, args.verbose, args.username, args.password)
         ard.settings = astraSDK.settings.getSettings().main()
-        ldapSetting = ard.getSingleDict("settings", "name", "astra.account.ldap", parser)
+        ldapSetting = ard.getSingleDict("settings", "name", "astra.account.ldap")
         rc = astraSDK.settings.createLdap(quiet=args.quiet, verbose=args.verbose).main(
             ldapSetting["id"],
             args.url,
             args.port,
             credential["id"],
             args.userBaseDN,
             args.userSearchFilter,
@@ -560,46 +553,46 @@
         )
         if rc is False:
             raise SystemExit("astraSDK.settings.createLdap() failed")
     elif args.objectType == "protection" or args.objectType == "schedule":
         naStr = "" if args.v3 else "*"
         if args.granularity == "hourly":
             if args.hour:
-                parser.error("'hourly' granularity must not specify -H / --hour")
+                helpers.parserError("'hourly' granularity must not specify -H / --hour")
             args.hour = naStr
             args.dayOfWeek = naStr
             args.dayOfMonth = naStr
         elif args.granularity == "daily":
             if not isinstance(args.hour, int) and not args.hour:
-                parser.error("'daily' granularity requires -H / --hour")
+                helpers.parserError("'daily' granularity requires -H / --hour")
             args.dayOfWeek = naStr
             args.dayOfMonth = naStr
         elif args.granularity == "weekly":
             if not isinstance(args.hour, int) and not args.hour:
-                parser.error("'weekly' granularity requires -H / --hour")
+                helpers.parserError("'weekly' granularity requires -H / --hour")
             if not isinstance(args.dayOfWeek, int) and not args.dayOfWeek:
-                parser.error("'weekly' granularity requires -W / --dayOfWeek")
+                helpers.parserError("'weekly' granularity requires -W / --dayOfWeek")
             args.dayOfMonth = naStr
         elif args.granularity == "monthly":
             if not isinstance(args.hour, int) and not args.hour:
-                parser.error("'monthly' granularity requires -H / --hour")
+                helpers.parserError("'monthly' granularity requires -H / --hour")
             if args.dayOfWeek:
-                parser.error("'monthly' granularity must not specify -W / --dayOfWeek")
+                helpers.parserError("'monthly' granularity must not specify -W / --dayOfWeek")
             if not args.dayOfMonth:
-                parser.error("'monthly' granularity requires -M / --dayOfMonth")
+                helpers.parserError("'monthly' granularity requires -M / --dayOfMonth")
             args.dayOfWeek = naStr
         if args.v3:
             if ard.needsattr("buckets"):
                 ard.buckets = astraSDK.k8s.getResources(
                     config_context=args.v3, skip_tls_verify=args.skip_tls_verify
                 ).main("appvaults")
             if args.bucket is None:
-                args.bucket = ard.getSingleDict("buckets", "status.state", "available", parser)[
-                    "metadata"
-                ]["name"]
+                args.bucket = ard.getSingleDict("buckets", "status.state", "available")["metadata"][
+                    "name"
+                ]
             createV3Protection(
                 args.v3,
                 args.dry_run,
                 args.skip_tls_verify,
                 args.quiet,
                 args.verbose,
                 args.app,
@@ -633,17 +626,19 @@
         if ":" in args.offset:
             hours = args.offset.split(":")[0].zfill(2)
             minutes = args.offset.split(":")[1].zfill(2)
         else:
             hours = "00"
             minutes = args.offset.zfill(2)
         if int(hours) < 0 or int(hours) > 23:
-            parser.error(f"offset {args.offset} hours must be between 0 and 23, inclusive")
+            helpers.parserError(f"offset {args.offset} hours must be between 0 and 23, inclusive")
         elif int(minutes) < 0 or int(minutes) > 59:
-            parser.error(f"offset '{args.offset}' minutes must be between 0 and 59, inclusive")
+            helpers.parserError(
+                f"offset '{args.offset}' minutes must be between 0 and 59, inclusive"
+            )
         dtstart = "DTSTART:20220101T" + hours + minutes + "00Z\n"
         # Create RRULE string
         rrule = "RRULE:FREQ=MINUTELY;INTERVAL="
         if "m" in args.replicationFrequency:
             rrule += args.replicationFrequency.strip("m")
         else:
             rrule += str(int(args.replicationFrequency.strip("h")) * 60)
@@ -685,70 +680,66 @@
                 dtstart + rrule,
             )
             if prc is False:
                 raise SystemExit("astraSDK.protections.createProtectionpolicy() failed")
         else:
             raise SystemExit("astraSDK.replications.createReplicationpolicy() failed")
     elif args.objectType == "script":
-        encodedStr = helpers.openScript(args.filePath, parser)
+        encodedStr = helpers.openScript(args.filePath)
         rc = astraSDK.scripts.createScript(quiet=args.quiet, verbose=args.verbose).main(
             name=args.name, source=encodedStr, description=args.description
         )
         if rc is False:
             raise SystemExit("astraSDK.scripts.createScript() failed")
     elif args.objectType == "snapshot":
         if args.v3:
             if ard.needsattr("buckets"):
                 ard.buckets = astraSDK.k8s.getResources(
                     config_context=args.v3, skip_tls_verify=args.skip_tls_verify
                 ).main("appvaults")
             if args.bucket is None:
-                args.bucket = ard.getSingleDict("buckets", "status.state", "available", parser)[
-                    "metadata"
-                ]["name"]
+                args.bucket = ard.getSingleDict("buckets", "status.state", "available")["metadata"][
+                    "name"
+                ]
             snapshot = createV3Snapshot(
                 args.v3,
                 args.dry_run,
                 args.skip_tls_verify,
                 args.quiet,
                 args.verbose,
                 args.name,
                 args.app,
                 args.bucket,
                 reclaimPolicy=args.reclaimPolicy,
                 createdTimeout=args.createdTimeout,
                 readyToUseTimeout=args.readyToUseTimeout,
             )
             if snapshot and not args.dry_run and not args.background:
-                monitorV3ProtectionTask(
-                    snapshot, args.pollTimer, parser, args.v3, args.skip_tls_verify
-                )
+                monitorV3ProtectionTask(snapshot, args.pollTimer, args.v3, args.skip_tls_verify)
         else:
             protectionID = astraSDK.snapshots.takeSnap(quiet=args.quiet, verbose=args.verbose).main(
-                args.app,
-                helpers.isRFC1123(args.name, parser=parser),
+                args.app, helpers.isRFC1123(args.name)
             )
             rc = monitorProtectionTask(
                 protectionID,
                 args.objectType,
                 args.app,
                 args.background,
                 args.pollTimer,
-                parser,
             )
             if rc is False:
                 raise SystemExit("monitorProtectionTask() failed")
     elif args.objectType == "user":
         # Handle LDAP use cases
         if args.ldap:
             ldapUsers = astraSDK.users.getLdapUsers().main(emailFilter=args.email, matchType="eq")
             if len(ldapUsers["items"]) == 0:
-                parser.error(f"0 LDAP users found with email '{args.email}'")
+                helpers.parserError(f"0 LDAP users found with email '{args.email}'")
             elif len(ldapUsers["items"]) > 1:
-                parser.error(f"multiple LDAP users found with email '{args.email}'")
+                helpers.parserError(f"multiple LDAP users found with email '{args.email}'")
             args.firstName = ldapUsers["items"][0]["firstName"]
             args.lastName = ldapUsers["items"][0]["lastName"]
             args.ldap = "ldap"
         # First create the user
         urc = astraSDK.users.createUser(quiet=args.quiet, verbose=args.verbose).main(
             args.email, firstName=args.firstName, lastName=args.lastName, authProvider=args.ldap
         )
```

## tkSrc/deploy.py

```diff
@@ -177,28 +177,30 @@
                 minute,
                 appID,
             )
             if cppRet is False:
                 raise SystemExit(f"cpp.main({period}...) returned False")
 
 
-def main(args, parser, ard):
+def main(args, ard):
     if args.objectType == "acp":
         if args.v3:
             # Ensure the trident orchestrator is already running
             torc = astraSDK.k8s.getClusterResources(
                 quiet=args.quiet,
                 verbose=args.verbose,
                 config_context=args.v3,
                 skip_tls_verify=args.skip_tls_verify,
             ).main("tridentorchestrators")
             if torc is None or len(torc["items"]) == 0:
-                parser.error("trident operator not found on current Kubernetes context")
+                helpers.parserError("trident operator not found on current Kubernetes context")
             elif len(torc["items"]) > 1:
-                parser.error("multiple trident operators found on current Kubernetes context")
+                helpers.parserError(
+                    "multiple trident operators found on current Kubernetes context"
+                )
             # Handle the registry secret
             if not args.regCred:
                 cred = astraSDK.k8s.createRegCred(
                     quiet=args.quiet,
                     dry_run=args.dry_run,
                     verbose=args.verbose,
                     config_context=args.v3,
@@ -208,27 +210,27 @@
                     raise SystemExit("astraSDK.k8s.createRegCred() failed")
                 args.regCred = cred["metadata"]["name"]
             else:
                 if ard.needsattr("credentials"):
                     ard.credentials = astraSDK.k8s.getSecrets(
                         config_context=args.v3, skip_tls_verify=args.skip_tls_verify
                     ).main(namespace="trident")
-                cred = ard.getSingleDict("credentials", "metadata.name", args.regCred, parser)
+                cred = ard.getSingleDict("credentials", "metadata.name", args.regCred)
             # Handle default registry
             if not args.registry:
                 try:
                     args.registry = next(
                         iter(
                             json.loads(
                                 base64.b64decode(cred["data"][".dockerconfigjson"]).decode()
                             )["auths"].keys()
                         )
                     )
                 except KeyError as err:
-                    parser.error(
+                    helpers.parserError(
                         f"{args.regCred} does not appear to be a Docker secret: {err} key not found"
                     )
             # Create the patch spec
             torc_name = torc["items"][0]["metadata"]["name"]
             torc_version = torc["items"][0]["status"]["version"][1:]
             torc_spec = {"spec": torc["items"][0]["spec"]}
             torc_spec["spec"]["enableACP"] = True
@@ -243,33 +245,33 @@
                 skip_tls_verify=args.skip_tls_verify,
             ).main("tridentorchestrators", torc_name, torc_spec)
             if torc_update:
                 print(f"tridentorchestrator.trident.netapp.io/{torc_name} edited")
             else:
                 raise SystemExit("astraSDK.k8s.updateClusterResource() failed")
         else:
-            parser.error(
+            helpers.parserError(
                 "'deploy acp' is currently only supported as a --v3 command, please re-run with "
                 "--v3 and an optional context, kubeconfig_file, or context@kubeconfig_file mapping"
             )
     elif args.objectType == "chart":
         if not hasattr(args, "bucket"):
             args.bucket = None
         if args.v3:
             if ard.needsattr("buckets"):
                 ard.buckets = astraSDK.k8s.getResources(
                     config_context=args.v3, skip_tls_verify=args.skip_tls_verify
                 ).main("appvaults")
             if args.bucket is None:
-                args.bucket = ard.getSingleDict("buckets", "status.state", "available", parser)[
-                    "metadata"
-                ]["name"]
+                args.bucket = ard.getSingleDict("buckets", "status.state", "available")["metadata"][
+                    "name"
+                ]
         deployHelm(
             args.chart,
-            helpers.isRFC1123(args.app, parser=parser),
+            helpers.isRFC1123(args.app),
             args.namespace,
             args.set,
             args.values,
             args.bucket,
             args.verbose,
             args.quiet,
             v3=args.v3,
```

## tkSrc/destroy.py

```diff
@@ -14,15 +14,15 @@
    See the License for the specific language governing permissions and
    limitations under the License.
 """
 
 import astraSDK
 
 
-def main(args, parser, ard):
+def main(args, ard):
     if args.objectType == "backup":
         if args.v3:
             rc = astraSDK.k8s.destroyResource(
                 quiet=args.quiet,
                 dry_run=args.dry_run,
                 verbose=args.verbose,
                 config_context=args.v3,
@@ -35,15 +35,15 @@
             if rc:
                 print(f"Backup {args.backup} destroyed")
             else:
                 raise SystemExit(f"Failed destroying backup: {args.backup}")
     elif args.objectType == "cluster":
         if ard.needsattr("clusters"):
             ard.clusters = astraSDK.clusters.getClusters().main()
-        cluster = ard.getSingleDict("clusters", "id", args.cluster, parser)
+        cluster = ard.getSingleDict("clusters", "id", args.cluster)
         rc = astraSDK.clusters.deleteCluster(quiet=args.quiet, verbose=args.verbose).main(
             cluster["id"], cluster["cloudID"]
         )
         if not rc:
             raise SystemExit(f"Failed destroying cluster: {args.cluster}")
     elif args.objectType == "credential" or args.objectType == "secret":
         if args.v3:
@@ -61,15 +61,15 @@
             if rc:
                 print(f"Credential {args.credential} destroyed")
             else:
                 raise SystemExit(f"Failed destroying credential: {args.credential}")
     elif args.objectType == "group":
         if ard.needsattr("rolebindings"):
             ard.rolebindings = astraSDK.rolebindings.getRolebindings().main()
-        rb = ard.getSingleDict("rolebindings", "groupID", args.groupID, parser)
+        rb = ard.getSingleDict("rolebindings", "groupID", args.groupID)
         if astraSDK.rolebindings.destroyRolebinding(quiet=args.quiet, verbose=args.verbose).main(
             rb["id"]
         ):
             print(f"RoleBinding {rb['id']} destroyed")
             if astraSDK.groups.destroyGroup(quiet=args.quiet, verbose=args.verbose).main(
                 args.groupID
             ):
@@ -93,15 +93,15 @@
             )
             if rc:
                 print(f"Hook {args.hook} destroyed")
             else:
                 raise SystemExit(f"Failed destroying hook: {args.hook}")
     elif args.objectType == "ldap":
         ard.settings = astraSDK.settings.getSettings().main()
-        ldapSetting = ard.getSingleDict("settings", "name", "astra.account.ldap", parser)
+        ldapSetting = ard.getSingleDict("settings", "name", "astra.account.ldap")
         if astraSDK.settings.destroyLdap(quiet=args.quiet, verbose=args.verbose).main(
             ldapSetting["id"]
         ):
             if ldapSetting["currentConfig"].get("credentialId"):
                 rc = astraSDK.credentials.destroyCredential(
                     quiet=args.quiet, verbose=args.verbose
                 ).main(ldapSetting["currentConfig"]["credentialId"])
@@ -188,16 +188,16 @@
             else:
                 raise SystemExit(f"Failed destroying snapshot: {args.snapshot}")
     elif args.objectType == "user":
         if ard.needsattr("users"):
             ard.users = astraSDK.users.getUsers().main()
         if ard.needsattr("rolebindings"):
             ard.rolebindings = astraSDK.rolebindings.getRolebindings().main()
-        user = ard.getSingleDict("users", "id", args.userID, parser)
-        rb = ard.getSingleDict("rolebindings", "userID", args.userID, parser)
+        user = ard.getSingleDict("users", "id", args.userID)
+        rb = ard.getSingleDict("rolebindings", "userID", args.userID)
         if astraSDK.rolebindings.destroyRolebinding(quiet=args.quiet, verbose=args.verbose).main(
             rb["id"]
         ):
             print(f"RoleBinding {rb['id']} destroyed")
         else:
             raise SystemExit(f"Failed destroying user {args.userID} with roleBinding {rb['id']}")
         # Only LDAP users also need to be destroyed
```

## tkSrc/helpers.py

```diff
@@ -85,31 +85,31 @@
         + createFilterTypeList("namespaceName", namespaces)
         + createFilterTypeList("podName", pods)
         + createFilterTypeList("podLabel", labels)
         + createFilterTypeList("containerName", names)
     )
 
 
-def createNamespaceMapping(appNamespaces, singleNs, multiNsMapping, parser):
+def createNamespaceMapping(appNamespaces, singleNs, multiNsMapping):
     """Create a list of dictionaries of source and destination namespaces for cloning an
     application, as the user can provide a variety of input.  Return object format:
     [ { "source": "sourcens1", "destination": "destns1" },
       { "source": "sourcens2", "destination": "destns2" } ]"""
     # Ensure that multiNsMapping was used for multi-namespace apps
     if multiNsMapping is None and len(appNamespaces) > 1:
-        parser.error("for multi-namespace apps, --multiNsMapping must be used.")
+        parserError("for multi-namespace apps, --multiNsMapping must be used.")
     # For single-namespace apps, the namespace mapping is **not** a required field
     elif singleNs is None and multiNsMapping is None:
         return None
     # Handle --cloneNamespace argument
     elif singleNs:
         return [
             {
                 "source": appNamespaces[0]["namespace"],
-                "destination": isRFC1123(singleNs, parser=parser),
+                "destination": isRFC1123(singleNs),
             }
         ]
     # Handle multiNsMapping cases
     elif multiNsMapping:
         # Create a single list of mappings (nargs can produce a variety of lists of lists)
         mappingList = []
         for NsMapping in multiNsMapping:
@@ -133,15 +133,15 @@
             )
         # Generate the return mapping list and return it
         returnList = []
         for mapping in mappingList:
             returnList.append(
                 {
                     "source": mapping.split("=")[0],
-                    "destination": isRFC1123(mapping.split("=")[1], parser=parser),
+                    "destination": isRFC1123(mapping.split("=")[1]),
                 }
             )
         return returnList
     else:
         raise SystemExit("Unknown Error")
 
 
@@ -306,38 +306,35 @@
     else:
         if captureOutput:
             return ret.stdout
         else:
             return True
 
 
-def isRFC1123(string, parser=None, ignore_length=False):
+def isRFC1123(string, ignore_length=False):
     """isRFC1123 returns the input 'string' if it conforms to RFC 1123 spec,
     otherwise it throws an error and exits"""
     regex = re.compile("[a-z0-9]([-a-z0-9]*[a-z0-9])?$")
     if regex.match(string) is not None and (len(string) < 64 or ignore_length):
         return string
     else:
         error = (
             f"'{string}' must consist of lower case alphanumeric characters or '-', must start "
             "and end with an alphanumeric character, and must be at most 63 characters (for "
             "example 'my-name' or '123-abc')."
         )
-        if parser is not None:
-            parser.error(error)
-        else:
-            raise SystemExit(f"Error: {error}")
+        parserError(error)
 
 
-def dupeKeyError(key, parser):
+def dupeKeyError(key):
     """Print an error message if duplicate keys are used"""
-    parser.error(f"'{key}' should not be specified multiple times within a single --filterSet arg")
+    parserError(f"'{key}' should not be specified multiple times within a single --filterSet arg")
 
 
-def createSetDict(setDict, filterStr, assets, parser, v3=False):
+def createSetDict(setDict, filterStr, assets, v3=False):
     """Given a filterStr such as:
         label=app.kubernetes.io/tier=backend,name=mysql,kind=Deployment
     Return a setDict with the following format:
         {
             "labelSelectors": ["app.kubernetes.io/tier=backend"],
             "names": ["mysql"],
             "kind": "Deployment",
@@ -349,51 +346,49 @@
         if "namespace" in key:
             setDict.setdefault("namespaces", []).append(isRFC1123(val))
         elif "name" in key:
             setDict.setdefault("names", []).append(isRFC1123(val))
         elif "label" in key:
             setDict.setdefault("labelSelectors", []).append(val)
         elif "group" in key:
-            setDict["group"] = val if not setDict.get("group") else dupeKeyError("group", parser)
+            setDict["group"] = val if not setDict.get("group") else dupeKeyError("group")
         elif "version" in key:
-            setDict["version"] = (
-                val if not setDict.get("version") else dupeKeyError("version", parser)
-            )
+            setDict["version"] = val if not setDict.get("version") else dupeKeyError("version")
         elif "kind" in key:
-            setDict["kind"] = val if not setDict.get("kind") else dupeKeyError("kind", parser)
+            setDict["kind"] = val if not setDict.get("kind") else dupeKeyError("kind")
         else:
-            parser.error(
+            parserError(
                 f"'{key}' not one of ['namespace', 'name', 'label', 'group', 'version', 'kind']"
             )
     # TODO: Add v3 validation once ASTRACTL-31946 is complete
     if not v3:
         # Validate the inputs are valid assets for this app
         for key in ["group", "version", "kind"]:
             if setDict.get(key) and setDict[key] not in [a["GVK"][key] for a in assets["items"]]:
-                parser.error(
+                parserError(
                     f"'{setDict[key]}' is not a valid '{key}' for this application, please run '"
                     f"list assets {assets['metadata']['appID']}' to view possible '{key}' choices"
                 )
         # Validate the inputs are valid GVK combinations
         for key1 in ["group", "version", "kind"]:
             for key2 in ["group", "version", "kind"]:
                 if key1 == key2:
                     continue
                 if setDict.get(key1) and setDict.get(key2):
                     if setDict[key1] not in [
                         a["GVK"][key1] for a in assets["items"] if a["GVK"][key2] == setDict[key2]
                     ]:
-                        parser.error(
+                        parserError(
                             f"'{key1}={setDict[key1]}' does not match with '{key2}={setDict[key2]}'"
                             f", please run 'list assets {assets['metadata']['appID']}' to view "
                             "valid GVK combinations"
                         )
 
 
-def createFilterSet(selection, filters, assets, parser, v3=False):
+def createFilterSet(selection, filters, assets, v3=False):
     """createFilterSet takes in a selection string, and a filters array of arrays, for example:
         [
             ['group=apps,version=v1,kind=Deployment'],
             ['label=app.kubernetes.io/tier=backend,name=mysql,namespace=wordpress']
         ]
     And returns an object for use in a restore filter, like so:
         {
@@ -420,22 +415,22 @@
     else:
         filterKey = "GVKN"
     rFilter = {filterKey: [], "resourceSelectionCriteria": selection}
     for fil in filters:
         setDict = {}
         if isinstance(fil, list):
             for f in fil:
-                createSetDict(setDict, f, assets, parser, v3=v3)
+                createSetDict(setDict, f, assets, v3=v3)
         else:
-            createSetDict(setDict, fil, assets, parser, v3=v3)
+            createSetDict(setDict, fil, assets, v3=v3)
         rFilter[filterKey].append(setDict)
     return rFilter
 
 
-def createSingleSecretKeyDict(credKeyPair, ard, parser):
+def createSingleSecretKeyDict(credKeyPair, ard):
     """Given a credKeyPair list like ['s3-creds', 'accessKeyID']
 
     Return a dict with the following format:
     {
     "valueFromSecret":
       {
         "name": "s3-creds",
@@ -445,56 +440,56 @@
 
     Also validate that a given key exists in the corresponding secret"""
     # argparse ensures len(args.credential) is 2, but can't ensure a valid name/key pair
     if credKeyPair[0] in [x["metadata"]["name"] for x in ard.credentials["items"]]:
         cred, key = credKeyPair
     else:
         key, cred = credKeyPair
-    credDict = ard.getSingleDict("credentials", "metadata.name", cred, parser)
+    credDict = ard.getSingleDict("credentials", "metadata.name", cred)
     if key not in credDict["data"].keys():
-        parser.error(
+        parserError(
             f"'{credKeyPair[1]}' not found in '{credKeyPair[0]}' data keys: "
             f"{', '.join(credDict['data'].keys())}"
         )
     return {"valueFromSecret": {"name": cred, "key": key}}
 
 
-def createSecretKeyDict(keyNameList, credential, provider, ard, parser):
+def createSecretKeyDict(keyNameList, credential, provider, ard):
     """Use keyNameList to ensure number of credential arguments inputted is correct,
     and build the full providerCredentials dictionary"""
     # Ensure correct credential length matches keyNameList length
     if len(credential) != len(keyNameList):
-        parser.error(
+        parserError(
             f"-s/--credential must be specified {len(keyNameList)} time(s) for "
             f"'{provider}' provider"
         )
     # argparse ensures len(args.credential) is 2, but can't ensure a valid name/key pair
     providerCredentials = {}
     for i, credKeyPair in enumerate(credential):
-        providerCredentials[keyNameList[i]] = createSingleSecretKeyDict(credKeyPair, ard, parser)
+        providerCredentials[keyNameList[i]] = createSingleSecretKeyDict(credKeyPair, ard)
     return providerCredentials
 
 
 def prependDump(obj, prepend, indent=2):
     """Function to prepend a certain amount of spaces in a yaml.dump(obj) to properly
     align in nested yaml"""
     if obj is not None:
         arr = [(" " * prepend + i) for i in yaml.dump(obj, indent=indent).split("\n")]
         return "\n".join(arr).rstrip()
     return None
 
 
-def checkv3Support(args, parser, supportedDict):
+def checkv3Support(args, supportedDict):
     """Function to ensure a v3-specific actoolkit command is currently supported by v3"""
     if supported := supportedDict.get(args.subcommand):
         if supported is True:
             return True
         elif args.objectType in supported:
             return True
-    parser.error(f"'{args.subcommand} {args.objectType}' is not currently a supported --v3 command")
+    parserError(f"'{args.subcommand} {args.objectType}' is not currently a supported --v3 command")
 
 
 def setupJinja(
     objectType, filesystem=os.path.dirname(os.path.realpath(__file__)) + "/templates/jinja"
 ):
     """Function to load a jinja template from the filesystem based on parser objectType"""
     env = Environment(loader=FileSystemLoader(filesystem))
@@ -524,33 +519,33 @@
     ks1 = next(n for n in namespaces1["items"] if n["metadata"]["name"] == "kube-system")
     ks2 = next(n for n in namespaces2["items"] if n["metadata"]["name"] == "kube-system")
     if ks1["metadata"]["uid"] == ks2["metadata"]["uid"]:
         return True
     return False
 
 
-def getCommonAppVault(cluster1, cluster2, parser, skip_tls_verify=False):
+def getCommonAppVault(cluster1, cluster2, skip_tls_verify=False):
     """Function which takes in two cluster contexts, and finds and returns an appVault that's
     common between the two of them, as designated by status.uid"""
     c1AppVaults = astraSDK.k8s.getResources(
         config_context=cluster1, skip_tls_verify=skip_tls_verify
     ).main("appvaults")
     c2AppVaults = astraSDK.k8s.getResources(
         config_context=cluster2, skip_tls_verify=skip_tls_verify
     ).main("appvaults")
     for c1av in c1AppVaults["items"]:
         for c2av in c2AppVaults["items"]:
             if c1av.get("status") and c1av["status"].get("uid"):
                 if c2av.get("status") and c2av["status"].get("uid"):
                     if c1av["status"]["uid"] == c2av["status"]["uid"]:
                         return c1av
-    parser.error(f"A common appVault was not found between cluster {cluster1} and {cluster2}")
+    parserError(f"A common appVault was not found between cluster {cluster1} and {cluster2}")
 
 
-def swapAppVaultRef(sourceAppVaultRef, sourceCluster, destCluster, parser, skip_tls_verify=False):
+def swapAppVaultRef(sourceAppVaultRef, sourceCluster, destCluster, skip_tls_verify=False):
     """Function which takes in the name of a sourceCluster's appVaultRef, and then returns
     the name of the destCluster's same appVaultRef (appVaults can be named differently across
     clusters due to Astra Control auto-appending a unique identifier)."""
     sourceAppVaults = astraSDK.k8s.getResources(
         config_context=sourceCluster, skip_tls_verify=skip_tls_verify
     ).main("appvaults")
     destAppVaults = astraSDK.k8s.getResources(
@@ -558,55 +553,55 @@
     ).main("appvaults")
     try:
         sourceAppVault = next(
             a for a in sourceAppVaults["items"] if a["metadata"]["name"] == sourceAppVaultRef
         )
         sourceUid = sourceAppVault["status"]["uid"]
     except StopIteration:
-        parser.error(f"'{sourceAppVaultRef}' not found on the source cluster,\n{sourceAppVaults=}")
+        parserError(f"'{sourceAppVaultRef}' not found on the source cluster,\n{sourceAppVaults=}")
     except KeyError as err:
-        parser.error(f"{err} key not found in '{sourceAppVaultRef}' object,\n{sourceAppVaults=}")
+        parserError(f"{err} key not found in '{sourceAppVaultRef}' object,\n{sourceAppVaults=}")
     try:
         destAppVault = next(a for a in destAppVaults["items"] if a["status"]["uid"] == sourceUid)
         return destAppVault["metadata"]["name"]
     except StopIteration:
         destAppVaultSum = [
             {"name": d["metadata"]["name"], "uid": d["status"]["uid"]}
             for d in destAppVaults["items"]
         ]
-        parser.error(
+        parserError(
             f"An appVault with status.uid of '{sourceUid}' not found on the destination cluster,"
             f" destination app vaults: {destAppVaultSum}"
         )
     except KeyError as err:
-        parser.error(f"{err} key not found in 'destAppVault' object,\n{destAppVaults=}")
+        parserError(f"{err} key not found in 'destAppVault' object,\n{destAppVaults=}")
 
 
-def openJson(path, parser):
+def openJson(path):
     """Given a file path, open the json file, and return a dict of its contents"""
     with open(path, encoding="utf8") as f:
         try:
             return json.loads(f.read().rstrip())
         except json.decoder.JSONDecodeError:
-            parser.error(f"{path} does not seem to be valid JSON")
+            parserError(f"{path} does not seem to be valid JSON")
 
 
-def openScript(path, parser):
+def openScript(path):
     """Given a file path, open the text file, and return a str of its contents"""
     with open(path, encoding="utf8") as f:
         return base64.b64encode(f.read().rstrip().encode("utf-8")).decode("utf-8")
 
 
-def openYaml(path, parser):
+def openYaml(path):
     """Given a file path, open the yaml file, and return a dict of its contents"""
     with open(path, encoding="utf8") as f:
         try:
             return yaml.load(f.read().rstrip(), Loader=yaml.SafeLoader)
         except (yaml.scanner.ScannerError, IsADirectoryError):
-            parser.error(f"{path} does not seem to be valid YAML")
+            parserError(f"{path} does not seem to be valid YAML")
 
 
 def getNestedValue(obj, key):
     """Iterate through a nested dict / list to search for a particular key,
     it returns the first match"""
     if hasattr(obj, "items"):
         for k, o in obj.items():
@@ -617,25 +612,36 @@
                     yield result
             elif isinstance(o, list):
                 for d in o:
                     for result in getNestedValue(d, key):
                         yield result
 
 
-def extractAwsKeys(path, parser):
+def extractAwsKeys(path):
     """Returns a tuple of the AccessKeyId, SecretAccessKey in an AWS credential JSON"""
-    awsCreds = openJson(path, parser)
+    awsCreds = openJson(path)
     accessKeyID = "".join(getNestedValue(awsCreds, "AccessKeyId"))
     secretAccessKey = "".join(getNestedValue(awsCreds, "SecretAccessKey"))
     if not accessKeyID:
-        parser.error(f"'AccessKeyId' not found in '{path}'")
+        parserError(f"'AccessKeyId' not found in '{path}'")
     if not secretAccessKey:
-        parser.error(f"'SecretAccessKey' not found in '{path}'")
+        parserError(f"'SecretAccessKey' not found in '{path}'")
     return accessKeyID, secretAccessKey
 
 
 def combineResources(*args):
     """Accepts any number of {"items":[]} inputs, concatenates the lists, returns a dict"""
     base_dict = {"apiVersion": "v1", "items": [], "kind": "List"}
     for resource in args:
         base_dict["items"] += resource["items"]
     return base_dict
+
+
+def parserError(message):
+    """Prints an argparse-like generic error message"""
+    prog = "actoolkit"
+    usage = (
+        "usage: actoolkit [-h] [-v] [-o {json,yaml,table}] [-q] [-f] [--v3] "
+        "[--dry-run {client,server}] [--insecure-skip-tls-verify] "
+        "{deploy,clone,restore,ipr,list,get,copy,create,manage,define,destroy,unmanage,update} ..."
+    )
+    raise SystemExit(f"{usage}\n{prog}: error: {message}")
```

## tkSrc/ipr.py

```diff
@@ -26,44 +26,43 @@
 
 def doV3Ipr(
     v3,
     dry_run,
     skip_tls_verify,
     quiet,
     verbose,
-    parser,
     ard,
     backup=None,
     snapshot=None,
     filterSelection=None,
     filterSet=None,
 ):
     if backup:
         if ard.needsattr("backups"):
             ard.backups = astraSDK.k8s.getResources(
                 config_context=v3, skip_tls_verify=skip_tls_verify
             ).main("backups")
-        iprSourceDict = ard.getSingleDict("backups", "metadata.name", backup, parser)
+        iprSourceDict = ard.getSingleDict("backups", "metadata.name", backup)
     elif snapshot:
         if ard.needsattr("snapshots"):
             ard.snapshots = astraSDK.k8s.getResources(
                 config_context=v3, skip_tls_verify=skip_tls_verify
             ).main("snapshots")
-        iprSourceDict = ard.getSingleDict("snapshots", "metadata.name", snapshot, parser)
+        iprSourceDict = ard.getSingleDict("snapshots", "metadata.name", snapshot)
 
     template = helpers.setupJinja("ipr")
     try:
         v3_dict = yaml.safe_load(
             template.render(
                 kind=iprSourceDict["kind"],
                 iprName=f"{iprSourceDict['kind'].lower()}ipr-{uuid.uuid4()}",
                 appArchivePath=iprSourceDict["status"]["appArchivePath"],
                 appVaultRef=iprSourceDict["spec"]["appVaultRef"],
                 resourceFilter=helpers.prependDump(
-                    helpers.createFilterSet(filterSelection, filterSet, None, parser, v3=True),
+                    helpers.createFilterSet(filterSelection, filterSet, None, v3=True),
                     prepend=4,
                 ),
             )
         )
         if dry_run == "client":
             print(yaml.dump(v3_dict).rstrip("\n"))
         else:
@@ -78,34 +77,35 @@
                 v3_dict["metadata"]["namespace"],
                 v3_dict,
                 version="v1",
                 group="astra.netapp.io",
             )
     except KeyError as err:
         iprSourceName = backup if backup else snapshot
-        parser.error(
+        helpers.parserError(
             f"{err} key not found in '{iprSourceName}' object, please ensure "
             f"'{iprSourceName}' is a valid backup/snapshot"
         )
 
 
-def main(args, parser, ard):
+def main(args, ard):
     if (args.filterSelection and not args.filterSet) or (
         args.filterSet and not args.filterSelection
     ):
-        parser.error("either both or none of --filterSelection and --filterSet should be specified")
+        helpers.parserError(
+            "either both or none of --filterSelection and --filterSet should be specified"
+        )
 
     if args.v3:
         doV3Ipr(
             args.v3,
             args.dry_run,
             args.skip_tls_verify,
             args.quiet,
             args.verbose,
-            parser,
             ard,
             backup=args.backup,
             snapshot=args.snapshot,
             filterSelection=args.filterSelection,
             filterSet=args.filterSet,
         )
     else:
@@ -113,15 +113,14 @@
             args.app,
             backupID=args.backup,
             snapshotID=args.snapshot,
             resourceFilter=helpers.createFilterSet(
                 args.filterSelection,
                 args.filterSet,
                 astraSDK.apps.getAppAssets().main(args.app),
-                parser,
             ),
         )
         if rc:
             if args.background:
                 print("In-Place-Restore job submitted successfully")
                 print("Background flag selected, run 'list apps' to get status")
                 return True
```

## tkSrc/list.py

```diff
@@ -397,15 +397,15 @@
                 args.verbose,
                 skip_tls_verify=args.skip_tls_verify,
                 app=args.app,
             )
         else:
             rc = astraSDK.protections.getProtectionpolicies(
                 quiet=args.quiet, verbose=args.verbose, output=args.output
-            ).main(appFilter=args.app)
+            ).main(appFilter=args.app, clusterFilter=args.cluster)
             if rc is False:
                 raise SystemExit("astraSDK.protections.getProtectionpolicies() failed")
     elif args.objectType == "replications":
         rc = astraSDK.replications.getReplicationpolicies(
             quiet=args.quiet, verbose=args.verbose, output=args.output
         ).main(appFilter=args.app)
         if rc is False:
```

## tkSrc/manage.py

```diff
@@ -93,35 +93,34 @@
     provider,
     storageAccount,
     serverURL,
     http,
     skipCertValidation,
     credential,
     ard,
-    parser,
 ):
     """Manage a bucket via a Kubernetes custom resource"""
     # Create providerCredentials based on provider input
     if provider == "azure":
         keyNameList = ["accountKey"]
     elif provider == "gcp":
         keyNameList = ["credentials"]
     else:
         keyNameList = ["accessKeyID", "secretAccessKey"]
     template = helpers.setupJinja("appVault")
     v3_dict = yaml.safe_load(
         template.render(
-            bucketName=helpers.isRFC1123(bucketName, parser=parser),
+            bucketName=helpers.isRFC1123(bucketName),
             providerType=provider,
             accountName=storageAccount,
             endpoint=serverURL,
             secure=("false" if http else None),
             skipCertValidation=("true" if skipCertValidation else None),
             providerCredentials=helpers.prependDump(
-                helpers.createSecretKeyDict(keyNameList, credential, provider, ard, parser),
+                helpers.createSecretKeyDict(keyNameList, credential, provider, ard),
                 prepend=4,
             ),
         )
     )
     if dry_run == "client":
         print(yaml.dump(v3_dict).rstrip("\n"))
     else:
@@ -149,17 +148,16 @@
     clusterName,
     operator_version,
     regCred,
     registry,
     cloudID,
     headless,
     ard,
-    parser,
 ):
-    helpers.isRFC1123(clusterName, parser=parser)
+    helpers.isRFC1123(clusterName)
     create.createV3ConnectorOperator(v3, dry_run, skip_tls_verify, verbose, operator_version)
     # Create the astra API token secret
     if not headless:
         apiToken = astraSDK.k8s.createAstraApiToken(
             quiet=quiet,
             dry_run=dry_run,
             verbose=verbose,
@@ -179,15 +177,15 @@
             raise SystemExit("astraSDK.k8s.createRegCred() failed")
         regCred = cred["metadata"]["name"]
     else:
         if ard.needsattr("credentials"):
             ard.credentials = astraSDK.k8s.getSecrets(
                 config_context=v3, skip_tls_verify=skip_tls_verify
             ).main()
-        cred = ard.getSingleDict("credentials", "metadata.name", regCred, parser)
+        cred = ard.getSingleDict("credentials", "metadata.name", regCred)
     # Create the AstraConnector CR
     if headless:
         connector = astraSDK.k8s.createHeadlessConnector(
             quiet=quiet,
             dry_run=dry_run,
             verbose=verbose,
             config_context=v3,
@@ -201,52 +199,54 @@
             config_context=v3,
             skip_tls_verify=skip_tls_verify,
         ).main(clusterName, cloudID, apiToken["metadata"]["name"], regCred, registry=registry)
     if not connector:
         raise SystemExit("astraSDK.k8s.createAstraConnector() failed")
 
 
-def validateBucketArgs(args, parser):
+def validateBucketArgs(args):
     """Validate that user provided inputs for managing a bucket are valid"""
     # Validate serverURL and storageAccount args depending upon provider type
     if args.serverURL is None and args.provider in [
         "aws",
         "generic-s3",
         "ontap-s3",
         "storagegrid-s3",
     ]:
-        parser.error(f"--serverURL must be provided for '{args.provider}' provider.")
+        helpers.parserError(f"--serverURL must be provided for '{args.provider}' provider.")
     if args.storageAccount is None and args.provider == "azure":
-        parser.error("--storageAccount must be provided for 'azure' provider.")
+        helpers.parserError("--storageAccount must be provided for 'azure' provider.")
     # Error if credential was specified with any other argument
     if args.credential is not None:
         if args.json is not None or args.accessKey is not None or args.accessSecret is not None:
-            parser.error(
+            helpers.parserError(
                 "if an existing credential is specified, no other credentialGroup arguments "
                 "can be specified"
             )
     # Error if json was specified with accessKey/Secret
     elif args.json is not None:
         if args.accessKey is not None or args.accessSecret is not None:
-            parser.error(
+            helpers.parserError(
                 "if a public cloud JSON credential file is specified, no other credentialGroup "
                 "arguments can be specified"
             )
     # If neither credential or json was specified, make sure both accessKey/Secret were
     elif args.accessKey is None or args.accessSecret is None:
-        parser.error(
+        helpers.parserError(
             "either an (existing credential) OR (public cloud JSON credential) OR "
             "(accessKey AND accessSecret) must be specified"
         )
     # If json was specified, ensure provider is a public cloud
     if args.json is not None and args.provider not in ["aws", "azure", "gcp"]:
-        parser.error("--json should only be specified for public cloud providers (aws, azure, gcp)")
+        helpers.parserError(
+            "--json should only be specified for public cloud providers (aws, azure, gcp)"
+        )
 
 
-def main(args, parser, ard):
+def main(args, ard):
     if args.objectType == "app" or args.objectType == "application":
         if args.additionalNamespace:
             args.additionalNamespace = helpers.createNamespaceList(
                 args.additionalNamespace, v3=args.v3
             )
         if args.clusterScopedResource:
             if args.v3:
@@ -291,15 +291,15 @@
                 ard.apiresources = astraSDK.apiresources.getApiResources().main(
                     cluster=args.clusterID
                 )
             # Validate input as argparse+choices is unable to only validate the first input
             api_res_list = [f"{a['apiVersion']}/{a['kind']}" for a in ard.apiresources["items"]]
             for csr in args.clusterScopedResource:
                 if csr[0] not in api_res_list:
-                    parser.error(
+                    helpers.parserError(
                         f"argument -c/--clusterScopedResource: invalid choice: '{csr[0]}' "
                         f"(choose from {', '.join(api_res_list)})"
                     )
             args.clusterScopedResource = helpers.createCsrList(
                 args.clusterScopedResource, ard.apiresources, v3=args.v3
             )
         if args.v3:
@@ -313,34 +313,34 @@
                 args.namespace,
                 labelSelectors=args.labelSelectors,
                 additionalNamespace=args.additionalNamespace,
                 clusterScopedResource=args.clusterScopedResource,
             )
         else:
             rc = astraSDK.apps.manageApp(quiet=args.quiet, verbose=args.verbose).main(
-                helpers.isRFC1123(args.appName, parser=parser),
+                helpers.isRFC1123(args.appName),
                 args.namespace,
                 args.clusterID,
                 args.labelSelectors,
                 addNamespaces=args.additionalNamespace,
                 clusterScopedResources=args.clusterScopedResource,
             )
             if rc is False:
                 raise SystemExit("astraSDK.apps.manageApp() failed")
 
     elif args.objectType == "bucket" or args.objectType == "appVault":
-        validateBucketArgs(args, parser)
+        validateBucketArgs(args)
         if ard.needsattr("credentials"):
             ard.credentials = astraSDK.k8s.getSecrets(
                 config_context=args.v3, skip_tls_verify=args.skip_tls_verify
             ).main()
         if args.v3:
             if args.accessKey or (args.json and args.provider == "aws"):
                 if args.json and args.provider == "aws":
-                    args.accessKey, args.accessSecret = helpers.extractAwsKeys(args.json, parser)
+                    args.accessKey, args.accessSecret = helpers.extractAwsKeys(args.json)
                 crc = create.createV3S3Credential(
                     args.v3,
                     args.dry_run,
                     args.skip_tls_verify,
                     args.quiet,
                     args.verbose,
                     args.accessKey,
@@ -352,15 +352,14 @@
                     args.v3,
                     args.dry_run,
                     args.skip_tls_verify,
                     args.quiet,
                     args.verbose,
                     args.json,
                     args.bucketName,
-                    parser,
                 )
             if args.accessKey or args.json:
                 args.credential = []
                 for key in crc["data"].keys():
                     args.credential.append([crc["metadata"]["name"], key])
                 ard.credentials["items"].append(crc)
             manageV3Bucket(
@@ -373,30 +372,28 @@
                 args.provider,
                 args.storageAccount,
                 args.serverURL,
                 args.http,
                 args.skipCertValidation,
                 args.credential,
                 ard,
-                parser,
             )
         else:
             if args.accessKey:
                 crc = create.createS3Credential(
                     args.quiet, args.verbose, args.accessKey, args.accessSecret, args.bucketName
                 )
                 args.credential = crc["id"]
             elif args.json:
                 crc = create.createCloudCredential(
                     args.quiet,
                     args.verbose,
                     args.json,
                     args.bucketName,
                     args.provider,
-                    parser,
                 )
                 args.credential = crc["id"]
             manageBucket(
                 args.provider,
                 args.bucketName,
                 args.storageAccount,
                 args.serverURL,
@@ -416,48 +413,48 @@
                 args.clusterName,
                 args.operator_version,
                 args.regCred,
                 args.registry,
                 args.cloudID,
                 args.headless,
                 ard,
-                parser,
             )
         else:
             rc = astraSDK.clusters.manageCluster(quiet=args.quiet, verbose=args.verbose).main(
                 args.cluster, args.defaultStorageClassID
             )
             if rc is False:
                 raise SystemExit("astraSDK.clusters.manageCluster() failed")
 
     elif args.objectType == "cloud":
         credentialID = None
         # First create the credential
         if args.cloudType != "private":
             if args.credentialPath is None:
-                parser.error(f"--credentialPath is required for cloudType of {args.cloudType}")
+                helpers.parserError(
+                    f"--credentialPath is required for cloudType of {args.cloudType}"
+                )
             rc = create.createCloudCredential(
                 args.quiet,
                 args.verbose,
                 args.credentialPath,
                 args.cloudName,
                 args.cloudType,
-                parser,
             )
             credentialID = rc["id"]
         # Next manage the cloud
         rc = astraSDK.clouds.manageCloud(quiet=args.quiet, verbose=args.verbose).main(
             args.cloudName,
             args.cloudType,
             credentialID=credentialID,
             defaultBucketID=args.defaultBucketID,
         )
         if rc is False:
             raise SystemExit("astraSDK.clouds.manageCloud() failed")
     elif args.objectType == "ldap":
         ard.settings = astraSDK.settings.getSettings().main()
-        ldapSetting = ard.getSingleDict("settings", "name", "astra.account.ldap", parser)
+        ldapSetting = ard.getSingleDict("settings", "name", "astra.account.ldap")
         rc = astraSDK.settings.manageLdap(quiet=args.quiet, verbose=args.verbose).main(
             ldapSetting["id"], ldapSetting["currentConfig"]
         )
         if rc is False:
             raise SystemExit("astraSDK.settings.manageLdap() failed")
```

## tkSrc/parser.py

```diff
@@ -1009,14 +1009,21 @@
         )
 
     def list_protections_args(self):
         """list protection policies args and flags"""
         self.subparserListProtections.add_argument(
             "-a", "--app", default=None, help="Only show protection policies from this app"
         )
+        if not self.v3:
+            self.subparserListProtections.add_argument(
+                "-c",
+                "--cluster",
+                default=None,
+                help="Only show protection policies from this cluster",
+            )
 
     def list_replications_args(self):
         """list replication policies args and flags"""
         self.subparserListReplications.add_argument(
             "-a", "--app", default=None, help="Only show replication policies from this app"
         )
```

## tkSrc/unmanage.py

```diff
@@ -11,18 +11,19 @@
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 """
 
+from tkSrc import helpers
 import astraSDK
 
 
-def main(args, parser, ard):
+def main(args, ard):
     if args.objectType == "app" or args.objectType == "application":
         if args.v3:
             astraSDK.k8s.destroyResource(
                 quiet=args.quiet,
                 dry_run=args.dry_run,
                 verbose=args.verbose,
                 config_context=args.v3,
@@ -54,17 +55,19 @@
         if args.v3:
             # Ensure we have an AstraConnector CR installed
             if ard.needsattr("connectors"):
                 ard.connectors = astraSDK.k8s.getResources(
                     config_context=args.v3, skip_tls_verify=args.skip_tls_verify
                 ).main("astraconnectors", version="v1", group="astra.netapp.io")
             if ard.connectors is None or len(ard.connectors["items"]) == 0:
-                parser.error("AstraConnector operator not found on current Kubernetes context")
+                helpers.parserError(
+                    "AstraConnector operator not found on current Kubernetes context"
+                )
             elif len(ard.connectors["items"]) > 1:
-                parser.error(
+                helpers.parserError(
                     "multiple AstraConnector operators found on current Kubernetes context"
                 )
             connector = ard.connectors["items"][0]
             # Destroy the AstraConnector CR and api token secret
             if astraSDK.k8s.destroyResource(
                 quiet=args.quiet,
                 dry_run=args.dry_run,
@@ -137,13 +140,13 @@
                             print("Credential deleted")
                         else:
                             raise SystemExit("astraSDK.credentials.destroyCredential() failed")
         else:
             raise SystemExit("astraSDK.clusters.unmanageCloud() failed")
     elif args.objectType == "ldap":
         ard.settings = astraSDK.settings.getSettings().main()
-        ldapSetting = ard.getSingleDict("settings", "name", "astra.account.ldap", parser)
+        ldapSetting = ard.getSingleDict("settings", "name", "astra.account.ldap")
         rc = astraSDK.settings.unmanageLdap(quiet=args.quiet, verbose=args.verbose).main(
             ldapSetting["id"], ldapSetting["currentConfig"]
         )
         if rc is False:
             raise SystemExit("astraSDK.settings.unmanageLdap() failed")
```

## tkSrc/update.py

```diff
@@ -15,32 +15,32 @@
    limitations under the License.
 """
 
 import base64
 import json
 import yaml
 
-
+from tkSrc import helpers
 import astraSDK
 
 
-def main(args, parser, ard):
+def main(args, ard):
     if args.objectType == "bucket":
         # Validate that both credentialID and accessKey/accessSecret were not specified
         if args.credentialID is not None and (
             args.accessKey is not None or args.accessSecret is not None
         ):
-            parser.error(
+            helpers.parserError(
                 "if a credentialID is specified, neither accessKey nor accessSecret"
                 + " should be specified."
             )
         # Validate args and create credential if credentialID was not specified
         if args.credentialID is None:
             if args.accessKey is None or args.accessSecret is None:
-                parser.error(
+                helpers.parserError(
                     "if a credentialID is not specified, both accessKey and "
                     + "accessSecret arguments must be provided."
                 )
             if ard.needsattr("buckets"):
                 ard.buckets = astraSDK.buckets.getBuckets().main()
             encodedKey = base64.b64encode(args.accessKey.encode("utf-8")).decode("utf-8")
             encodedSecret = base64.b64encode(args.accessSecret.encode("utf-8")).decode("utf-8")
@@ -50,15 +50,15 @@
                 ).main(
                     next(b for b in ard.buckets["items"] if b["id"] == args.bucketID)["name"],
                     "s3",
                     {"accessKey": encodedKey, "accessSecret": encodedSecret},
                     cloudName="s3",
                 )
             except StopIteration:
-                parser.error(f"{args.bucketID} does not seem to be a valid bucketID")
+                helpers.parserError(f"{args.bucketID} does not seem to be a valid bucketID")
             if crc:
                 args.credentialID = crc["id"]
             else:
                 raise SystemExit("astraSDK.credentials.createCredential() failed")
         # Call updateBucket class
         rc = astraSDK.buckets.updateBucket(quiet=args.quiet, verbose=args.verbose).main(
             args.bucketID, credentialID=args.credentialID
@@ -67,22 +67,22 @@
             raise SystemExit("astraSDK.buckets.updateBucket() failed")
     elif args.objectType == "cloud":
         if args.credentialPath:
             with open(args.credentialPath, encoding="utf8") as f:
                 try:
                     credDict = json.loads(f.read().rstrip())
                 except json.decoder.JSONDecodeError:
-                    parser.error(f"{args.credentialPath} does not seem to be valid JSON")
+                    helpers.parserError(f"{args.credentialPath} does not seem to be valid JSON")
             encodedStr = base64.b64encode(json.dumps(credDict).encode("utf-8")).decode("utf-8")
             if ard.needsattr("clouds"):
                 ard.clouds = astraSDK.clouds.getClouds().main()
             try:
                 cloud = next(c for c in ard.clouds["items"] if c["id"] == args.cloudID)
             except StopIteration:
-                parser.error(f"{args.cloudID} does not seem to be a valid cloudID")
+                helpers.parserError(f"{args.cloudID} does not seem to be a valid cloudID")
             rc = astraSDK.credentials.createCredential(quiet=args.quiet, verbose=args.verbose).main(
                 "astra-sa@" + cloud["name"],
                 "service-account",
                 {"base64": encodedStr},
                 cloud["cloudType"],
             )
             if rc:
@@ -97,15 +97,15 @@
         )
         if rc is False:
             raise SystemExit("astraSDK.clouds.updateCloud() failed")
     elif args.objectType == "cluster":
         # Get the cluster information based on the clusterID input
         if ard.needsattr("clusters"):
             ard.clusters = astraSDK.clusters.getClusters().main()
-        cluster = ard.getSingleDict("clusters", "id", args.clusterID, parser)
+        cluster = ard.getSingleDict("clusters", "id", args.clusterID)
         # Currently this is required to be True, but this will not always be the case
         if args.credentialPath:
             with open(args.credentialPath, encoding="utf8") as f:
                 kubeconfigDict = yaml.load(f.read().rstrip(), Loader=yaml.SafeLoader)
                 encodedStr = base64.b64encode(json.dumps(kubeconfigDict).encode("utf-8")).decode(
                     "utf-8"
                 )
@@ -122,24 +122,24 @@
                 defaultBucketID=args.defaultBucketID,
             )
             if rc is False:
                 raise SystemExit("astraSDK.clusters.updateCluster() failed")
     elif args.objectType == "protection" or args.objectType == "schedule":
         if ard.needsattr("protections"):
             ard.protections = astraSDK.protections.getProtectionpolicies().main()
-        protection = ard.getSingleDict("protections", "id", args.protection, parser)
+        protection = ard.getSingleDict("protections", "id", args.protection)
         granularity = protection["granularity"]
         if granularity == "hourly" and args.hour:
-            parser.error(f"{granularity} granularity must not specify -H / --hour")
+            helpers.parserError(f"{granularity} granularity must not specify -H / --hour")
         if granularity == "hourly" or granularity == "daily" or granularity == "monthly":
             if args.dayOfWeek:
-                parser.error(f"{granularity} granularity must not specify -W / --dayOfWeek")
+                helpers.parserError(f"{granularity} granularity must not specify -W / --dayOfWeek")
         if granularity == "hourly" or granularity == "daily" or granularity == "weekly":
             if args.dayOfMonth:
-                parser.error(f"{granularity} granularity must not specify -M / --dayOfMonth")
+                helpers.parserError(f"{granularity} granularity must not specify -M / --dayOfMonth")
         rc = astraSDK.protections.updateProtectionpolicy(
             quiet=args.quiet, verbose=args.verbose
         ).main(
             protection["appID"],
             protection["id"],
             protection["granularity"],
             str(args.backupRetention) if args.backupRetention else protection["backupRetention"],
@@ -157,27 +157,27 @@
         if rc is False:
             raise SystemExit("astraSDK.protection.updateProtectionpolicy() failed")
     elif args.objectType == "replication":
         # Gather replication data
         if ard.needsattr("replications"):
             ard.replications = astraSDK.replications.getReplicationpolicies().main()
             if not ard.replications:  # Gracefully handle ACS env
-                parser.error("'replication' commands are currently only supported in ACC.")
+                helpers.parserError("'replication' commands are currently only supported in ACC.")
         repl = None
         for replication in ard.replications["items"]:
             if args.replicationID == replication["id"]:
                 repl = replication
         if not repl:
-            parser.error(f"replicationID {args.replicationID} not found")
+            helpers.parserError(f"replicationID {args.replicationID} not found")
         # Make call based on operation type
         if args.operation == "resync":
             if not args.dataSource:
-                parser.error("--dataSource must be provided for 'resync' operations")
+                helpers.parserError("--dataSource must be provided for 'resync' operations")
             if repl["state"] != "failedOver":
-                parser.error(
+                helpers.parserError(
                     "to resync a replication, it must be in a 'failedOver' state"
                     + f", not a(n) '{repl['state']}' state"
                 )
             if args.dataSource in [repl["sourceAppID"], repl["sourceClusterID"]]:
                 rc = astraSDK.replications.updateReplicationpolicy(
                     quiet=args.quiet, verbose=args.verbose
                 ).main(
@@ -196,24 +196,24 @@
                     "established",
                     sourceAppID=repl["destinationAppID"],
                     sourceClusterID=repl["destinationClusterID"],
                     destinationAppID=repl["sourceAppID"],
                     destinationClusterID=repl["sourceClusterID"],
                 )
             else:
-                parser.error(
+                helpers.parserError(
                     f"dataSource '{args.dataSource}' not one of:\n"
                     + f"\t{repl['sourceAppID']}\t(original sourceAppID)\n"
                     + f"\t{repl['sourceClusterID']}\t(original sourceClusterID)\n"
                     + f"\t{repl['destinationAppID']}\t(original destinationAppID)\n"
                     + f"\t{repl['destinationClusterID']}\t(original destinationClusterID)"
                 )
         elif args.operation == "reverse":
             if repl["state"] != "established" and repl["state"] != "failedOver":
-                parser.error(
+                helpers.parserError(
                     "to reverse a replication, it must be in an `established` or "
                     + f"'failedOver' state, not a(n) '{repl['state']}' state"
                 )
             rc = astraSDK.replications.updateReplicationpolicy(
                 quiet=args.quiet, verbose=args.verbose
             ).main(
                 args.replicationID,
@@ -221,15 +221,15 @@
                 sourceAppID=repl["destinationAppID"],
                 sourceClusterID=repl["destinationClusterID"],
                 destinationAppID=repl["sourceAppID"],
                 destinationClusterID=repl["sourceClusterID"],
             )
         else:  # failover
             if repl["state"] != "established":
-                parser.error(
+                helpers.parserError(
                     "to failover a replication, it must be in an 'established' state"
                     + f", not a(n) '{repl['state']}' state"
                 )
             rc = astraSDK.replications.updateReplicationpolicy(
                 quiet=args.quiet, verbose=args.verbose
             ).main(args.replicationID, "failedOver")
         # Exit based on response
```

## Comparing `actoolkit-3.0.1b4.dist-info/LICENSE` & `actoolkit-3.0.1b5.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `actoolkit-3.0.1b4.dist-info/METADATA` & `actoolkit-3.0.1b5.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: actoolkit
-Version: 3.0.1b4
+Version: 3.0.1b5
 Summary: Toolkit and SDK for interacting with Astra Control
 Home-page: https://github.com/NetApp/netapp-astra-toolkits
 Author: Michael Haigh
 Author-email: Michael.Haigh@netapp.com
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: OSI Approved :: Apache Software License
 Classifier: Operating System :: OS Independent
```

## Comparing `actoolkit-3.0.1b4.dist-info/RECORD` & `actoolkit-3.0.1b5.dist-info/RECORD`

 * *Files 11% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-toolkit.py,sha256=WETiKTr6PWUIoUvpKeXLzHAlC7MJ25hZRR3aCiv125o,10160
+toolkit.py,sha256=n8LtxJpNmGP0fl8hLVQONW6fFYxqxHD_SDmVElSOH3Q,10194
 astraSDK/__init__.py,sha256=9IogQObmUB6rrUv2B_MemA3XJI6BraZzfJn5ewLrGww,1139
 astraSDK/apiresources.py,sha256=rz_8JYN0qeY4y1K5H6OzI1HQmhQMqRgcUogY1d9HJhs,3659
 astraSDK/apps.py,sha256=HQ7ADBoj1pONiRBKMaroG3uL8m6kAIw6W-VzZqqCKBg,16993
 astraSDK/backups.py,sha256=wVk_kSInOcSniDYyty07T5yy2Mp1AmZz40G9saNRMSs,8289
 astraSDK/buckets.py,sha256=0dKsmhlg9VRxMIXCbamqDZZ5YuHJwhxWs3i-wJgED4E,7355
 astraSDK/clouds.py,sha256=qcE1r0WbU3v3JSIF17Jlbsnv81kLE0M_uI8xFwqV5s0,6972
 astraSDK/clusters.py,sha256=GIFDwGJBeXeYgMkNd5lFjmGZrDYWjrzqos9YYot5X2k,10776
@@ -10,45 +10,45 @@
 astraSDK/credentials.py,sha256=tmvbJ9YwiqUhP0WKcSIysRYSB9gkCwXyVhYeKXB8xiA,9115
 astraSDK/entitlements.py,sha256=cWfWWEG-3i1aZbpKxD9adNaIcY50Ezm5Ykszu_sfp2A,2663
 astraSDK/groups.py,sha256=YoGysVgQGkJLw7VKUZBdBx8lC1B-9rNFqvFhrKdVRCc,7958
 astraSDK/hooks.py,sha256=7ato-tpUjzm2p8EWybGLVRhKnqvEOJpdRVGIqUuxp0c,7162
 astraSDK/k8s.py,sha256=EWoqrt0DxTm5XAKUZ3KO1CfijF89Es0FpF7Vt8MwLpk,45273
 astraSDK/namespaces.py,sha256=NExkodJpRKHPbDlpAxcCcmp5vGaHV8JFrCXi02LQwFQ,5458
 astraSDK/notifications.py,sha256=cnurpqSBXwRL-vTNxp6SYAl-xz7qzJnLT6w8kwBo4r4,3576
-astraSDK/protections.py,sha256=VdM475JgYtu1XmyS2lPKwPxCf5rl13faC99EXlZakFM,10989
+astraSDK/protections.py,sha256=GISBkrOPl4IgrVViSrm7SpAznuzWD9NSV74G1RqFTJE,11162
 astraSDK/replications.py,sha256=1sFZtKDZ1k_0Y2f7V71ZZzoNP1vkR-3Xk8ESHB7j4gQ,9735
 astraSDK/rolebindings.py,sha256=C_fTyegWZ1XLaajIzI_ftybpkLEsPMnCmyn4mNn3g1M,5757
 astraSDK/scripts.py,sha256=AHMjcDhE5am8PhbUhALh7W22h2lSFe99qDRHTasGjtQ,7090
 astraSDK/settings.py,sha256=FjLCGalV_CVq_aQXixAPTe0GDCNYYV3NopLtVlk0_80,9821
 astraSDK/snapshots.py,sha256=P3FU7zUMnmAYmlorYp_qq1knU24Fa3VrymvS_Pn-hVg,7083
 astraSDK/storagebackends.py,sha256=U4xh-hv5P7ip69Je6e9HIqhGPusU0VukHmzugtUpk_o,2434
 astraSDK/storageclasses.py,sha256=YKMkLFqALreDcUPs1xQzzsadzLZPaLXmuwuJbKoMlXk,5023
 astraSDK/users.py,sha256=nuUS9llQ8I75XEjkRlWvFaai9Kg_VAIO9U7UK7xeKfo,9007
 tkSrc/__init__.py,sha256=bEBPw__Mr4AQFYM-nje4IiKl3_0ljSg_WvdfKItXS20,883
 tkSrc/choices.py,sha256=E1jIQGVpIO0wgKNeECMItq-Mv0U_AP-YZM873onpQoA,32031
-tkSrc/classes.py,sha256=a7CZwV9WgT4eNytrPQiAtmR_EMUQH7N7OyW-EhIbGU0,3962
-tkSrc/clone.py,sha256=BEBC8-lFODegWluIkA3OoY8YVnaOwqZ2S8veyqARNjk,24645
+tkSrc/classes.py,sha256=y3vFRoRsJS0UXWBrBjcG8ULUotd5NZEQedZu5TqYlPQ,3992
+tkSrc/clone.py,sha256=iPfMNVQkN3k6B6bqZ2IHI2a0Qya2aTapklxqu2A3ykQ,24437
 tkSrc/copy.py,sha256=sIiVt1gE4IJVJmwxXiHlhj-jKmYFrYSxdx3COSGG534,2011
-tkSrc/create.py,sha256=2md6C6xXu2KreaEokLW_hyrJdY_Mp-g_C9qkZCDmkC8,30083
-tkSrc/deploy.py,sha256=mwqv2wD9IuH4FU2kfiDYPgk_98HzDhp8jaroM-ryxE4,11071
-tkSrc/destroy.py,sha256=kBMvuLjTCKTgxnjG7P0lQaWdpGktMIYP5ElXqFClzMM,9791
-tkSrc/helpers.py,sha256=3npJ1jdtr6ycAqIuQf_6mvpibbmSlTdTYSdqDKeqR5s,26842
-tkSrc/ipr.py,sha256=fxJWqGVHCffaynh9udAq-7p262-XH55UstIU_yRSPLQ,4964
-tkSrc/list.py,sha256=qy43Uh-rdTFGnlBtGZpJfgTp3DYHcJim0WCBL1pkCEY,19364
-tkSrc/manage.py,sha256=UCkbzcFlTUpqDRIG7rzfTWmTEmMoSgwwmiEOL0f1_FQ,17049
-tkSrc/parser.py,sha256=8I_QzdYBenHlOCudT2wwBSAvOOywWw6J8yWXuGk3Y40,81156
-tkSrc/unmanage.py,sha256=rrpHGXOQPBGYKkHUTTKMy8CnAMRhpBu_EzVEWionIo4,7187
-tkSrc/update.py,sha256=Yv9bTpwmqjk_J-9-qDbwcZKY_JRbkM0QuvFfHXLnkXs,12238
+tkSrc/create.py,sha256=6LYdDPV4-MI2Li2Nl2rhRssVzs-zcSAThLpaK4CC-5I,29823
+tkSrc/deploy.py,sha256=FSw4ulNKV9OpVc9F6m9abrxy0LXzLbRvfUSTowpvTFo,11098
+tkSrc/destroy.py,sha256=R7wjXt-QZR_EJRi0zj1AwCiuPN4VCNWuaIg6baUeAzE,9743
+tkSrc/helpers.py,sha256=8tGOVsmppExCeclfAmoyYr_iUzrUxylpytMMRUIKAB8,26916
+tkSrc/ipr.py,sha256=jtPyaUm7dOAezJbh8KoIEcYdqwAUG_AeY0XyZcCK-GU,4912
+tkSrc/list.py,sha256=usUgWx7zPwlNA2ndeZhh_m10MYbT9-VJOmMAgGx2qIk,19392
+tkSrc/manage.py,sha256=CL6BKukA70x_A542HRtlGGn6PlYNKS5WyfspmyZccDM,16912
+tkSrc/parser.py,sha256=afxHFUE8Y549Yue4utmCZX-8Yg5Ir1vZema9P-JA6l0,81403
+tkSrc/unmanage.py,sha256=UnbLOD-zmQOyjY1bnnAj6cSowRqkf0AVqseoV89h43E,7249
+tkSrc/update.py,sha256=vplEyjae--CAUdeO07KkSTCDhcZ2d0CNg37XG123i80,12344
 tkSrc/templates/jinja/app.jinja,sha256=6hkzd1kb3M2NWv1fOHERBacuIZ6Y4f-ymJthwPWHaF8,446
 tkSrc/templates/jinja/appVault.jinja,sha256=pJccPuk1Co6oGvwqYwy0kHGoLGtrmKqLMewYLovSYcU,532
 tkSrc/templates/jinja/backup.jinja,sha256=0m1Z-plkxS8xIa8QgmnnR5eNaLxHQkM1EJwgTGKOPF0,406
 tkSrc/templates/jinja/hook.jinja,sha256=shg7mtmw-pxyQPvc1ApJBk9h1ra33X5zWY6QXVnemE0,374
 tkSrc/templates/jinja/ipr.jinja,sha256=o24Gd86lkZicpwrlRRxz2asvQBDzGGpv8q7XGeNKO9A,277
 tkSrc/templates/jinja/protection.jinja,sha256=W2kXOkrkSLoHuAJJY3RFesc0HF_LSyuJ5dFBBMiwE-U,417
 tkSrc/templates/jinja/restore.jinja,sha256=yofEKvIBF5dwBVbdjIlLBoMk99JR9h97HzUmBbYaNw0,584
 tkSrc/templates/jinja/snapshot.jinja,sha256=kyEShlXwosIr7jYbywD-VcuaezhI2HpXYvVDleC7KzU,533
-actoolkit-3.0.1b4.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
-actoolkit-3.0.1b4.dist-info/METADATA,sha256=tbiB91UCCkBxaLifJvrD9iSBCPczp_SSQnuKGdP1VwI,9193
-actoolkit-3.0.1b4.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
-actoolkit-3.0.1b4.dist-info/entry_points.txt,sha256=MdrJm8ktNHa01CEY7q5irB9JDPT_qg6hVpZWUhbKXWU,43
-actoolkit-3.0.1b4.dist-info/top_level.txt,sha256=wWyEWMBpCvR7Kv5mt_hBl4SEOLoVTV_9blXZhzBu7Y8,23
-actoolkit-3.0.1b4.dist-info/RECORD,,
+actoolkit-3.0.1b5.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
+actoolkit-3.0.1b5.dist-info/METADATA,sha256=GAEatgod0fnMibAofrd_SMkWszZ9QgcXnYsG6m7vpRg,9193
+actoolkit-3.0.1b5.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+actoolkit-3.0.1b5.dist-info/entry_points.txt,sha256=MdrJm8ktNHa01CEY7q5irB9JDPT_qg6hVpZWUhbKXWU,43
+actoolkit-3.0.1b5.dist-info/top_level.txt,sha256=wWyEWMBpCvR7Kv5mt_hBl4SEOLoVTV_9blXZhzBu7Y8,23
+actoolkit-3.0.1b5.dist-info/RECORD,,
```

