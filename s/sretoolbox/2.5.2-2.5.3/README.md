# Comparing `tmp/sretoolbox-2.5.2-py3-none-any.whl.zip` & `tmp/sretoolbox-2.5.3-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,27 +1,27 @@
-Zip file size: 35412 bytes, number of entries: 25
--rw-r--r--  2.0 unx        0 b- defN 24-Feb-22 21:45 sretoolbox/__init__.py
--rw-r--r--  2.0 unx      950 b- defN 24-Feb-22 21:45 sretoolbox/binaries/__init__.py
--rw-r--r--  2.0 unx     8886 b- defN 24-Feb-22 21:45 sretoolbox/binaries/base.py
--rw-r--r--  2.0 unx     2344 b- defN 24-Feb-22 21:45 sretoolbox/binaries/kubectl_package.py
--rw-r--r--  2.0 unx     2640 b- defN 24-Feb-22 21:45 sretoolbox/binaries/mtcli.py
--rw-r--r--  2.0 unx     2755 b- defN 24-Feb-22 21:45 sretoolbox/binaries/oc.py
--rw-r--r--  2.0 unx     2108 b- defN 24-Feb-22 21:45 sretoolbox/binaries/operator_sdk.py
--rw-r--r--  2.0 unx     2070 b- defN 24-Feb-22 21:45 sretoolbox/binaries/opm.py
--rw-r--r--  2.0 unx      744 b- defN 24-Feb-22 21:45 sretoolbox/container/__init__.py
--rw-r--r--  2.0 unx    24266 b- defN 24-Feb-22 21:45 sretoolbox/container/image.py
--rw-r--r--  2.0 unx     4885 b- defN 24-Feb-22 21:45 sretoolbox/container/skopeo.py
--rw-r--r--  2.0 unx      823 b- defN 24-Feb-22 21:45 sretoolbox/utils/__init__.py
--rw-r--r--  2.0 unx     4432 b- defN 24-Feb-22 21:45 sretoolbox/utils/concurrent.py
--rw-r--r--  2.0 unx     1220 b- defN 24-Feb-22 21:45 sretoolbox/utils/datatransformation.py
--rw-r--r--  2.0 unx     1350 b- defN 24-Feb-22 21:45 sretoolbox/utils/exception.py
--rw-r--r--  2.0 unx     2999 b- defN 24-Feb-22 21:45 sretoolbox/utils/logger.py
--rw-r--r--  2.0 unx     2825 b- defN 24-Feb-22 21:45 sretoolbox/utils/multiprocess.py
--rw-r--r--  2.0 unx      891 b- defN 24-Feb-22 21:45 sretoolbox/utils/process.py
--rw-r--r--  2.0 unx     3403 b- defN 24-Feb-22 21:45 sretoolbox/utils/retry.py
--rw-r--r--  2.0 unx     3522 b- defN 24-Feb-22 21:45 sretoolbox/utils/threaded.py
--rw-r--r--  2.0 unx    11357 b- defN 24-Feb-22 21:45 sretoolbox-2.5.2.dist-info/LICENSE
--rw-r--r--  2.0 unx     2188 b- defN 24-Feb-22 21:45 sretoolbox-2.5.2.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-Feb-22 21:45 sretoolbox-2.5.2.dist-info/WHEEL
--rw-r--r--  2.0 unx       11 b- defN 24-Feb-22 21:45 sretoolbox-2.5.2.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     2122 b- defN 24-Feb-22 21:45 sretoolbox-2.5.2.dist-info/RECORD
-25 files, 88883 bytes uncompressed, 31970 bytes compressed:  64.0%
+Zip file size: 35401 bytes, number of entries: 25
+-rw-r--r--  2.0 unx        0 b- defN 24-Apr-30 11:39 sretoolbox/__init__.py
+-rw-r--r--  2.0 unx      950 b- defN 24-Apr-30 11:39 sretoolbox/binaries/__init__.py
+-rw-r--r--  2.0 unx     8720 b- defN 24-Apr-30 11:39 sretoolbox/binaries/base.py
+-rw-r--r--  2.0 unx     2345 b- defN 24-Apr-30 11:39 sretoolbox/binaries/kubectl_package.py
+-rw-r--r--  2.0 unx     2640 b- defN 24-Apr-30 11:39 sretoolbox/binaries/mtcli.py
+-rw-r--r--  2.0 unx     2664 b- defN 24-Apr-30 11:39 sretoolbox/binaries/oc.py
+-rw-r--r--  2.0 unx     2060 b- defN 24-Apr-30 11:39 sretoolbox/binaries/operator_sdk.py
+-rw-r--r--  2.0 unx     2023 b- defN 24-Apr-30 11:39 sretoolbox/binaries/opm.py
+-rw-r--r--  2.0 unx      744 b- defN 24-Apr-30 11:39 sretoolbox/container/__init__.py
+-rw-r--r--  2.0 unx    24260 b- defN 24-Apr-30 11:39 sretoolbox/container/image.py
+-rw-r--r--  2.0 unx     4841 b- defN 24-Apr-30 11:39 sretoolbox/container/skopeo.py
+-rw-r--r--  2.0 unx      822 b- defN 24-Apr-30 11:39 sretoolbox/utils/__init__.py
+-rw-r--r--  2.0 unx     4433 b- defN 24-Apr-30 11:39 sretoolbox/utils/concurrent.py
+-rw-r--r--  2.0 unx     1220 b- defN 24-Apr-30 11:39 sretoolbox/utils/datatransformation.py
+-rw-r--r--  2.0 unx     1350 b- defN 24-Apr-30 11:39 sretoolbox/utils/exception.py
+-rw-r--r--  2.0 unx     2971 b- defN 24-Apr-30 11:39 sretoolbox/utils/logger.py
+-rw-r--r--  2.0 unx     2801 b- defN 24-Apr-30 11:39 sretoolbox/utils/multiprocess.py
+-rw-r--r--  2.0 unx      827 b- defN 24-Apr-30 11:39 sretoolbox/utils/process.py
+-rw-r--r--  2.0 unx     3394 b- defN 24-Apr-30 11:39 sretoolbox/utils/retry.py
+-rw-r--r--  2.0 unx     3497 b- defN 24-Apr-30 11:39 sretoolbox/utils/threaded.py
+-rw-r--r--  2.0 unx    11357 b- defN 24-Apr-30 11:39 sretoolbox-2.5.3.dist-info/LICENSE
+-rw-r--r--  2.0 unx     2187 b- defN 24-Apr-30 11:39 sretoolbox-2.5.3.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-Apr-30 11:39 sretoolbox-2.5.3.dist-info/WHEEL
+-rw-r--r--  2.0 unx       11 b- defN 24-Apr-30 11:39 sretoolbox-2.5.3.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     2122 b- defN 24-Apr-30 11:39 sretoolbox-2.5.3.dist-info/RECORD
+25 files, 88331 bytes uncompressed, 31959 bytes compressed:  63.8%
```

## zipnote {}

```diff
@@ -54,23 +54,23 @@
 
 Filename: sretoolbox/utils/retry.py
 Comment: 
 
 Filename: sretoolbox/utils/threaded.py
 Comment: 
 
-Filename: sretoolbox-2.5.2.dist-info/LICENSE
+Filename: sretoolbox-2.5.3.dist-info/LICENSE
 Comment: 
 
-Filename: sretoolbox-2.5.2.dist-info/METADATA
+Filename: sretoolbox-2.5.3.dist-info/METADATA
 Comment: 
 
-Filename: sretoolbox-2.5.2.dist-info/WHEEL
+Filename: sretoolbox-2.5.3.dist-info/WHEEL
 Comment: 
 
-Filename: sretoolbox-2.5.2.dist-info/top_level.txt
+Filename: sretoolbox-2.5.3.dist-info/top_level.txt
 Comment: 
 
-Filename: sretoolbox-2.5.2.dist-info/RECORD
+Filename: sretoolbox-2.5.3.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## sretoolbox/binaries/__init__.py

 * *Ordering differences only*

```diff
@@ -12,19 +12,19 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
 """
 Exposes the binary libs for easy access.
 """
 
+from sretoolbox.binaries.kubectl_package import KubectlPackage
 from sretoolbox.binaries.mtcli import Mtcli
 from sretoolbox.binaries.oc import Oc
 from sretoolbox.binaries.operator_sdk import OperatorSDK
 from sretoolbox.binaries.opm import Opm
-from sretoolbox.binaries.kubectl_package import KubectlPackage
 
 __all__ = [
     "Mtcli",
     "Oc",
     "OperatorSDK",
     "Opm",
     "KubectlPackage",
```

## sretoolbox/binaries/base.py

```diff
@@ -14,27 +14,23 @@
 
 """
 Abstractions around system binaries.
 """
 
 import logging
 import os
-
-from abc import ABCMeta
-from abc import abstractmethod
+from abc import ABCMeta, abstractmethod
 from collections import Counter
 from pathlib import Path
 
 import requests
-
 from semver import VersionInfo
 
 from sretoolbox.utils import run
 
-
 LOG = logging.getLogger(__name__)
 
 
 class CommandNotFoundError(Exception):
     """
     Used when a binary is not available in the system.
     """
@@ -49,29 +45,29 @@
     :param version: the semantic version of the binary
     :param download_path: the path where to download the binary to,
                           in case we have to download it.
 
     :type version: str
     :type download_path: Path or str
     """
-    binary_template = ''
-    download_url_template = ''
+
+    binary_template = ""
+    download_url_template = ""
 
     def __init__(self, version, download_path):
         # Making sure that the version contains
         # valid minor and patch elements
         counter = Counter(version)
-        if counter['.'] == 0:
-            version += '.0.0'
-        elif counter['.'] == 1:
-            version += '.0'
+        if counter["."] == 0:
+            version += ".0.0"
+        elif counter["."] == 1:
+            version += ".0"
 
         self.expected_version = VersionInfo.parse(version=version)
-        LOG.debug('Expected %s version: %s', self.binary,
-                  self.expected_version)
+        LOG.debug("Expected %s version: %s", self.binary, self.expected_version)
 
         self.download_path = Path(download_path)
 
         downloaded = False
         # First try to get the path from the system
         self._command = self._get_command_path(self.binary)
 
@@ -80,49 +76,55 @@
             downloaded_file = self._download()
             self._command = self.process_download(path=downloaded_file)
             downloaded = True
 
         # No luck. Binary is not on the system and it also can't
         # be downloaded.
         if self._command is None:
-            raise CommandNotFoundError(f'Not able to find or download '
-                                       f'{self.binary} version '
-                                       f'{self.expected_version}')
+            raise CommandNotFoundError(
+                f"Not able to find or download "
+                f"{self.binary} version "
+                f"{self.expected_version}"
+            )
 
         # Checking if we have the right version
         result = run(cmd=self.get_version_command())
         self._command_version = self.parse_version(version=result)
-        if not self._compare(expected=self.expected_version,
-                             actual=self._command_version):
-
+        if not self._compare(
+            expected=self.expected_version, actual=self._command_version
+        ):
             if downloaded:
                 # If even after download, the version doesn't match,
                 # we are done trying.
-                raise CommandNotFoundError(f'Downloaded version of '
-                                           f'{self.binary} did not match '
-                                           f'the expected version '
-                                           f'{self.expected_version}')
+                raise CommandNotFoundError(
+                    f"Downloaded version of "
+                    f"{self.binary} did not match "
+                    f"the expected version "
+                    f"{self.expected_version}"
+                )
 
             # Version doesn't match and we didn't try to download
             # so far. Downloading.
             downloaded_file = self._download()
             self._command = self.process_download(path=downloaded_file)
             if self._command is None:
-                raise CommandNotFoundError(f'Not able to download '
-                                           f'{self.binary}')
+                raise CommandNotFoundError(f"Not able to download " f"{self.binary}")
 
             # Checking if we have the right version after download
             result = run(cmd=self.get_version_command())
             self._command_version = self.parse_version(version=result)
-            if not self._compare(expected=self.expected_version,
-                                 actual=self._command_version):
-                raise CommandNotFoundError(f'Downloaded version of '
-                                           f'{self.binary} did not match '
-                                           f'the expected version '
-                                           f'{self.expected_version}')
+            if not self._compare(
+                expected=self.expected_version, actual=self._command_version
+            ):
+                raise CommandNotFoundError(
+                    f"Downloaded version of "
+                    f"{self.binary} did not match "
+                    f"the expected version "
+                    f"{self.expected_version}"
+                )
 
     @property
     def command(self):
         """
         The binary command full path.
         """
         return self._command
@@ -147,15 +149,15 @@
         The download URL.
         """
         return self.download_url_template.format(
             major=self.expected_version.major,
             minor=self.expected_version.minor,
             patch=self.expected_version.patch,
             prerelease=self.expected_version.prerelease,
-            build=self.expected_version.build
+            build=self.expected_version.build,
         )
 
     def run(self, *args):
         """
         Runs binary with arbitrary options.
         """
         cmd = [self.command, *args]
@@ -177,17 +179,17 @@
         """
         expected_version_dict = expected.to_dict()
         actual_version_dict = actual.to_dict()
         for item, value in expected_version_dict.items():
             if value is None:
                 continue
             if actual_version_dict[item] != value:
-                LOG.debug('Version mismatch: %s != %s', expected, actual)
+                LOG.debug("Version mismatch: %s != %s", expected, actual)
                 return False
-        LOG.debug('Version match: %s == %s', expected, actual)
+        LOG.debug("Version match: %s == %s", expected, actual)
         return True
 
     def _get_command_path(self, cmd, check_exec=True):
         """
         Find a given command in the system.
 
         :param cmd: The command name.
@@ -196,25 +198,25 @@
         :type cmd: str
         :type check_exec: bool
 
         :return: The command full path, when found.
         :rtype: string
         """
         bin_paths = [self.download_path]
-        os_path = os.environ.get('PATH')
+        os_path = os.environ.get("PATH")
         if os_path is not None:
-            bin_paths.extend([Path(item) for item in os_path.split(':')])
+            bin_paths.extend([Path(item) for item in os_path.split(":")])
 
         for dir_path in bin_paths:
             cmd_path = dir_path / cmd
             if cmd_path.is_file():
                 if check_exec:
                     if not os.access(cmd_path, os.R_OK | os.X_OK):
                         continue
-                LOG.debug('Found %s', cmd_path)
+                LOG.debug("Found %s", cmd_path)
                 return str(cmd_path.resolve())
 
         return None
 
     @abstractmethod
     def get_version_command(self):
         """
@@ -249,24 +251,24 @@
     def _download(self):
         """
         Gets the binary from the internet in a specific version.
 
         :return: the command full path after downloaded
         :rtype: str or None
         """
-        LOG.debug('Downloading %s', self.download_url)
+        LOG.debug("Downloading %s", self.download_url)
         response = requests.get(self.download_url, allow_redirects=True)
         if response.status_code >= 300:
             if response.status_code == 404:
                 LOG.debug(
                     "%s not found for the current system and architecture",
                     self.binary,
                 )
             raise requests.exceptions.HTTPError(
                 f"Error downloading {self.download_url}: {response.reason}"
             )
 
         bin_path = self.download_path / self.binary
-        with open(bin_path, 'wb') as file_obj:
+        with open(bin_path, "wb") as file_obj:
             file_obj.write(response.content)
-        LOG.debug('Downloaded %s', bin_path)
+        LOG.debug("Downloaded %s", bin_path)
         return str(bin_path)
```

## sretoolbox/binaries/kubectl_package.py

```diff
@@ -25,14 +25,15 @@
 from sretoolbox.binaries.base import Binary
 
 
 class KubectlPackage(Binary):
     """
     Defines the properties of KubectlPackage.
     """
+
     system = platform.system().lower()
     machine = platform.machine()
     if machine == "x86_64":
         sanitized_machine = "amd64"
     else:
         sanitized_machine = machine
```

## sretoolbox/binaries/oc.py

```diff
@@ -14,77 +14,79 @@
 
 """
 Abstractions around the OC binary.
 """
 
 import os
 import platform
-
 import tarfile
 
 from semver import VersionInfo
 
 from sretoolbox.binaries.base import Binary
 
 
 class Oc(Binary):
     """
     Defines the properties of OC.
     """
-    binary_template = 'oc-{version}'
-    system = 'mac' if platform.system().lower() == 'darwin' else 'linux'
-    download_url_template = ('https://mirror.openshift.com/pub/'
-                             'openshift-v{major}/'
-                             'clients/ocp/'
-                             '{major}.{minor}.{patch}/'
-                             f'openshift-client-{system}-'
-                             '{major}.{minor}.{patch}.tar.gz')
+
+    binary_template = "oc-{version}"
+    system = "mac" if platform.system().lower() == "darwin" else "linux"
+    download_url_template = (
+        "https://mirror.openshift.com/pub/"
+        "openshift-v{major}/"
+        "clients/ocp/"
+        "{major}.{minor}.{patch}/"
+        f"openshift-client-{system}-"
+        "{major}.{minor}.{patch}.tar.gz"
+    )
 
     def get_version_command(self):
         """
         Gets the command and its option(s) to check the version.
 
         :return: version command
         :rtype: list
         """
-        return [self.command, 'version', '--client']
+        return [self.command, "version", "--client"]
 
     def parse_version(self, version):
         """
         Parses version string as returned by the command execution
         to a VersionInfo instance.
 
         :param version: the return from the version command
         :type version: str
 
         :return: the parsed version as a VersionInfo object
         :rtype: VersionInfo
         """
         # Example:
         # Client Version: 4.6.1
-        oc_version = version.split(':')[1].strip()
+        oc_version = version.split(":")[1].strip()
         return VersionInfo.parse(version=oc_version)
 
     def process_download(self, path):
         """
         Processes a downloaded file and returns the executable binary path.
 
         :param path: The downloaded file path
         :return: The executable binary path.
         """
         # The downloaded file is actually a
         # tgz. Renaming first.
-        tgz = f'{path}.tgz'
+        tgz = f"{path}.tgz"
         os.rename(path, tgz)
 
         # Now we have to extract OC from the tgz to
         # the download_path
         with tarfile.open(tgz) as file_obj:
-            file_obj.extract('oc', path=self.download_path)
-        bin_path = f'{self.download_path}/oc'
-        oc_path = f'{self.download_path}/{self.binary}'
+            file_obj.extract("oc", path=self.download_path)
+        bin_path = f"{self.download_path}/oc"
+        oc_path = f"{self.download_path}/{self.binary}"
         os.rename(bin_path, oc_path)
 
         # Making it executable
         os.chmod(oc_path, 0o777)
 
         return oc_path
```

## sretoolbox/binaries/operator_sdk.py

```diff
@@ -24,42 +24,45 @@
 from sretoolbox.binaries.base import Binary
 
 
 class OperatorSDK(Binary):
     """
     Defines the properties of OperatorSDK.
     """
-    binary_template = 'operator-sdk-{version}'
+
+    binary_template = "operator-sdk-{version}"
     system = platform.system().lower()
-    download_url_template = ('https://github.com/operator-framework/'
-                             'operator-sdk/releases/download/'
-                             'v{major}.{minor}.{patch}/'
-                             f'operator-sdk_{system}_amd64')
+    download_url_template = (
+        "https://github.com/operator-framework/"
+        "operator-sdk/releases/download/"
+        "v{major}.{minor}.{patch}/"
+        f"operator-sdk_{system}_amd64"
+    )
 
     def get_version_command(self):
         """
         Gets the command and its option(s) to check the version.
 
         :return: version command
         :rtype: list
         """
-        return [self.command, 'version']
+        return [self.command, "version"]
 
     def parse_version(self, version):
         """
         Parses version string as returned by the command execution
         to a VersionInfo instance.
 
         :param version: the return from the version command
         :type version: str
 
         :return: the parsed version as a VersionInfo object
         :rtype: VersionInfo
         """
-        opm_version = version.split('"')[1].split('v', 1)[1]
+        opm_version = version.split('"')[1].split("v", 1)[1]
         return VersionInfo.parse(version=opm_version)
 
     def process_download(self, path):
         """
         Processes a downloaded file and returns the executable binary path.
 
         :param path: The downloaded file path
```

## sretoolbox/binaries/opm.py

```diff
@@ -16,49 +16,53 @@
 Abstractions around the OPM binary.
 """
 
 import os
 import platform
 
 from semver import VersionInfo
+
 from sretoolbox.binaries.base import Binary
 
 
 class Opm(Binary):
     """
     Defines the properties of OPM.
     """
-    binary_template = 'opm-{version}'
+
+    binary_template = "opm-{version}"
     system = platform.system().lower()
-    download_url_template = ('https://github.com/operator-framework/'
-                             'operator-registry/releases/download/'
-                             'v{major}.{minor}.{patch}/'
-                             f'{system}-amd64-opm')
+    download_url_template = (
+        "https://github.com/operator-framework/"
+        "operator-registry/releases/download/"
+        "v{major}.{minor}.{patch}/"
+        f"{system}-amd64-opm"
+    )
 
     def get_version_command(self):
         """
         Gets the command and its option(s) to check the version.
 
         :return: version command
         :rtype: list
         """
-        return [self.command, 'version']
+        return [self.command, "version"]
 
     def parse_version(self, version):
         """
         Parses version string as returned by the command execution
         to a VersionInfo instance.
 
         :param version: the return from the version command
         :type version: str
 
         :return: the parsed version as a VersionInfo object
         :rtype: VersionInfo
         """
-        opm_version = version.split('"')[1].split('v', 1)[1]
+        opm_version = version.split('"')[1].split("v", 1)[1]
         return VersionInfo.parse(version=opm_version)
 
     def process_download(self, path):
         """
         Processes a downloaded file and returns the executable binary path.
 
         :param path: The downloaded file path
```

## sretoolbox/container/__init__.py

```diff
@@ -15,8 +15,8 @@
 """
 Exposes the container libs for easy access.
 """
 
 from sretoolbox.container.image import Image
 from sretoolbox.container.skopeo import Skopeo
 
-__all__ = ['Image', 'Skopeo']
+__all__ = ["Image", "Skopeo"]
```

## sretoolbox/container/image.py

```diff
@@ -18,37 +18,33 @@
 
 import json
 import logging
 import re
 from http import HTTPStatus
 
 import requests
-
 from requests.exceptions import HTTPError
 
 from sretoolbox.utils import retry
 
-
 _LOG = logging.getLogger(__name__)
 
-SCHEMA1_MANIFEST_MEDIA_TYPE = \
-    'application/vnd.docker.distribution.manifest.v1+json'
-SCHEMA1_SIGNED_MANIFEST_MEDIA_TYPE = \
-    'application/vnd.docker.distribution.manifest.v1+prettyjws'
-SCHEMA2_MANIFEST_MEDIA_TYPE = \
-    'application/vnd.docker.distribution.manifest.v2+json'
-SCHEMA2_MANIFEST_LIST_MEDIA_TYPE = \
-    'application/vnd.docker.distribution.manifest.list.v2+json'
-OCI_MANIFEST_MEDIA_TYPE = 'application/vnd.oci.image.manifest.v1+json'
-OCI_IMAGE_INDEX_MEDIA_TYPE = 'application/vnd.oci.image.index.v1+json'
-
-SINGLE_ARCH_MEDIA_TYPES = [SCHEMA2_MANIFEST_MEDIA_TYPE,
-                           OCI_MANIFEST_MEDIA_TYPE]
-MULTI_ARCH_MEDIA_TYPES = [SCHEMA2_MANIFEST_LIST_MEDIA_TYPE,
-                          OCI_IMAGE_INDEX_MEDIA_TYPE]
+SCHEMA1_MANIFEST_MEDIA_TYPE = "application/vnd.docker.distribution.manifest.v1+json"
+SCHEMA1_SIGNED_MANIFEST_MEDIA_TYPE = (
+    "application/vnd.docker.distribution.manifest.v1+prettyjws"
+)
+SCHEMA2_MANIFEST_MEDIA_TYPE = "application/vnd.docker.distribution.manifest.v2+json"
+SCHEMA2_MANIFEST_LIST_MEDIA_TYPE = (
+    "application/vnd.docker.distribution.manifest.list.v2+json"
+)
+OCI_MANIFEST_MEDIA_TYPE = "application/vnd.oci.image.manifest.v1+json"
+OCI_IMAGE_INDEX_MEDIA_TYPE = "application/vnd.oci.image.index.v1+json"
+
+SINGLE_ARCH_MEDIA_TYPES = [SCHEMA2_MANIFEST_MEDIA_TYPE, OCI_MANIFEST_MEDIA_TYPE]
+MULTI_ARCH_MEDIA_TYPES = [SCHEMA2_MANIFEST_LIST_MEDIA_TYPE, OCI_IMAGE_INDEX_MEDIA_TYPE]
 
 
 class ImageComparisonError(Exception):
     """
     Used when the comparison between images is not possible.
     """
 
@@ -62,16 +58,15 @@
 class NoTagForImageByDigest(Exception):
     """
     Raised when the Image was constructed with a by-digest URL and an
     operation is attempted that requires a tag.
     """
 
     def __init__(self, image):
-        super().__init__(
-            f"Can't determine a unique tag for Image: {str(image)}")
+        super().__init__(f"Can't determine a unique tag for Image: {str(image)}")
 
 
 class ImageInvalidManifestError(Exception):
     """
     Raised when there was an error decoding the manifest payload as json
     """
 
@@ -101,56 +96,65 @@
     _HANDLE_RESPONSE_CACHE_METHODS = {
         "docker.io": "_handle_docker_content_digest",
         "quay.io": "_handle_docker_content_digest",
         "gcr.io": "_handle_docker_content_digest",
         "registry.access.redhat.com": "_handle_conditional_request",
     }
 
-    def __init__(self, url, tag_override=None, username=None, password=None,
-                 auth_server=None, response_cache=None, auth_token=None,
-                 ssl_verify=True, session=None, timeout=None):
+    def __init__(
+        self,
+        url,
+        tag_override=None,
+        username=None,
+        password=None,
+        auth_server=None,
+        response_cache=None,
+        auth_token=None,
+        ssl_verify=True,
+        session=None,
+        timeout=None,
+    ):
         image_data = self._parse_image_url(url)
-        self.scheme = image_data['scheme']
-        self.registry = image_data['registry']
-        self.repository = image_data['repository']
-        self.image = image_data['image']
+        self.scheme = image_data["scheme"]
+        self.registry = image_data["registry"]
+        self.repository = image_data["repository"]
+        self.image = image_data["image"]
         self.response_cache = response_cache
         self.ssl_verify = ssl_verify
         self.session = session
         self.timeout = timeout
 
         self.auth_token = auth_token
         if tag_override is None:
-            self.tag = image_data['tag']
+            self.tag = image_data["tag"]
         else:
             self.tag = tag_override
 
         self._cache_digest = None
         # If the URL was by-digest, we can cache this right away.
-        if image_data['digest']:
+        if image_data["digest"]:
             self._cache_digest = f"{image_data['digest']}"
 
         self.username = username
         self.password = password
-        if all([username is not None,
-                password is not None]):
+        if all([username is not None, password is not None]):
             self.auth = (username, password)
         else:
             self.auth = None
         # When the auth_server is provided, we must check if
         # it matches the registry, otherwise we don't send the
         # auth headers (to avoid leaking the credentials)
         self.auth_server = auth_server
         if self.auth_server is not None and self.auth_server != self.registry:
             self.auth = None
 
-        if self.registry == 'docker.io':
-            self.registry_api = 'https://registry-1.docker.io'
+        if self.registry == "docker.io":
+            self.registry_api = "https://registry-1.docker.io"
         else:
-            self.registry_api = f'https://{self.registry}'
+            self.registry_api = f"https://{self.registry}"
 
         self._cache_tags = None
         self._cache_manifest = None
         self._cache_content_type = None
 
         if self.response_cache is not None:
             self.response_cache_hits = self.response_cache_misses = 0
@@ -168,98 +172,107 @@
         Property to return the Content-Type header from the manifest retrieval.
         It caches the result.
         """
         if self._cache_content_type is None:
             _ = self.manifest
 
         if self._cache_content_type is None:
-            raise HTTPError('Content-Type header not found.')
+            raise HTTPError("Content-Type header not found.")
 
         return self._cache_content_type
 
     @property
     def digest(self):
         """
         Property to return the Docker-Content-Digest header from the manifest
         retrieval. It caches the result.
         """
         if self._cache_digest is None:
             _ = self.manifest
 
         if self._cache_digest is None:
-            raise HTTPError('Docker-Content-Digest header not found.')
+            raise HTTPError("Docker-Content-Digest header not found.")
 
         return self._cache_digest
 
     def _requester(self):
         if self.session is not None:
             return self.session.request
         return requests.request
 
     @retry(exceptions=(HTTPError, requests.ConnectionError), max_attempts=5)
     def _do_request(self, url, method="GET", headers=None):
         # Use any cached tokens, they may still be valid
         request_headers = {
-            'Accept': ",".join([
-                SCHEMA1_MANIFEST_MEDIA_TYPE,
-                SCHEMA1_SIGNED_MANIFEST_MEDIA_TYPE,
-                SCHEMA2_MANIFEST_MEDIA_TYPE,
-                SCHEMA2_MANIFEST_LIST_MEDIA_TYPE,
-                OCI_MANIFEST_MEDIA_TYPE,
-                OCI_IMAGE_INDEX_MEDIA_TYPE,
-            ])
+            "Accept": ",".join(
+                [
+                    SCHEMA1_MANIFEST_MEDIA_TYPE,
+                    SCHEMA1_SIGNED_MANIFEST_MEDIA_TYPE,
+                    SCHEMA2_MANIFEST_MEDIA_TYPE,
+                    SCHEMA2_MANIFEST_LIST_MEDIA_TYPE,
+                    OCI_MANIFEST_MEDIA_TYPE,
+                    OCI_IMAGE_INDEX_MEDIA_TYPE,
+                ]
+            )
         }
 
         if headers:
             request_headers.update(headers)
 
         if self.auth_token:
-            request_headers['Authorization'] = self.auth_token
+            request_headers["Authorization"] = self.auth_token
             auth = None
         else:
             auth = self.auth
 
         request = self._requester()
-        response = request(method, url, headers=request_headers, auth=auth,
-                           verify=self.ssl_verify, timeout=self.timeout)
+        response = request(
+            method,
+            url,
+            headers=request_headers,
+            auth=auth,
+            verify=self.ssl_verify,
+            timeout=self.timeout,
+        )
 
         # Unauthorized, meaning we have to acquire a new token
         if response.status_code == 401:
-            auth_specs = response.headers.get('Www-Authenticate')
+            auth_specs = response.headers.get("Www-Authenticate")
             if auth_specs is None:
                 self._raise_for_status(response)
 
             www_auth = self._parse_www_auth(auth_specs)
 
             # Try again, with the new Authorization header
             self.auth_token = self._get_auth(www_auth)
-            request_headers['Authorization'] = self.auth_token
-            response = request(method, url, headers=request_headers,
-                               timeout=self.timeout)
+            request_headers["Authorization"] = self.auth_token
+            response = request(
+                method, url, headers=request_headers, timeout=self.timeout
+            )
 
         self._raise_for_status(response)
         return response
 
     def _get_cache_key(self, url):
         # Returns the cache key. It uses the username as entries in the cache
         # may have been added by a different user with different permissions.
         return (url, self.username)
 
     def _get_manifest(self):
         # Retrieve the image manifest from the internet or from the response
         # cache if it exists.
-        url = f'{self.registry_api}/v2'
+        url = f"{self.registry_api}/v2"
         if self.repository is not None:
-            url += f'/{self.repository}'
+            url += f"/{self.repository}"
         # NOTE(efried): This should never go to the network. If the image was
         # initialized by digest, the `digest` property uses that value.
         reference = self.tag or self.digest
         # NOTE(efried): At least for quay, this returns schemaVersion 1 by tag
         # and 2 by digest.
-        url += f'/{self.image}/manifests/{reference}'
+        url += f"/{self.image}/manifests/{reference}"
 
         if self.response_cache is None or not self._can_response_be_cached():
             return self._do_request(url)
 
         key = self._get_cache_key(url)
         if key in self.response_cache:
             # We use a dispatch table to handle how different registries handle
@@ -277,35 +290,35 @@
 
     def _get_tags(self):
         """
         Goes to the internet to retrieve all the image tags.
         """
         tags_per_page = 50
 
-        url = f'{self.registry_api}/v2'
+        url = f"{self.registry_api}/v2"
         if self.repository is not None:
-            url += f'/{self.repository}'
-        url += f'/{self.image}/tags/list?n={tags_per_page}'
+            url += f"/{self.repository}"
+        url += f"/{self.image}/tags/list?n={tags_per_page}"
 
         response = self._do_request(url)
-        tags = all_tags = response.json()['tags']
+        tags = all_tags = response.json()["tags"]
 
         # Tags are paginated
         while not len(tags) < tags_per_page:
-            next_page = response.links.get('next')
+            next_page = response.links.get("next")
 
             if next_page is None:
                 break
             if self.registry_api in next_page["url"]:
                 url = next_page["url"]
             else:
                 url = f'{self.registry_api}{next_page["url"]}'
             response = self._do_request(url)
 
-            tags = response.json()['tags']
+            tags = response.json()["tags"]
             all_tags.extend(tags)
 
         return all_tags
 
     def _handle_conditional_request(self, url):
         # Handle response cache entries using conditional requests.
         headers = {}
@@ -363,16 +376,16 @@
         current image.
 
         :param other: The base image to check against
         :type other: Image
         :return: True if the current image has the other image as base
         :rtype: bool
         """
-        for layer in other.manifest['fsLayers']:
-            if layer not in self.manifest['fsLayers']:
+        for layer in other.manifest["fsLayers"]:
+            if layer not in self.manifest["fsLayers"]:
                 return False
         return True
 
     def is_part_of(self, other):
         """
         Checks if this single-arch image is part of the given multi-arch
         image
@@ -382,26 +395,24 @@
         :raises ImageContainsError: if this image is not a single-arch
              image or other is not a multi-arch image
         :return: True if this single-arch image is part of the other
         :rtype: bool
         """
         if self.content_type not in SINGLE_ARCH_MEDIA_TYPES:
             raise ImageContainsError(
-                f"Unsupported image content type in {self}: "
-                f"'{self.content_type}'"
+                f"Unsupported image content type in {self}: " f"'{self.content_type}'"
             )
 
         if other.content_type not in MULTI_ARCH_MEDIA_TYPES:
             raise ImageContainsError(
-                f"Unsupported image content type in {other}: "
-                f"'{other.content_type}'"
+                f"Unsupported image content type in {other}: " f"'{other.content_type}'"
             )
 
-        for manifest in other.manifest['manifests']:
-            if manifest['digest'] == self.digest:
+        for manifest in other.manifest["manifests"]:
+            if manifest["digest"] == self.digest:
                 return True
 
         return False
 
     @property
     def manifest(self):
         """
@@ -412,42 +423,43 @@
             try:
                 self._cache_manifest = manifest.json()
             except json.decoder.JSONDecodeError as exc:
                 raise ImageInvalidManifestError(
                     f"Invalid manifest for {self.url_tag} - "
                     "could not decode manifest as json"
                 ) from exc
-            self._cache_content_type = manifest.headers.get('Content-Type')
-            self._cache_digest = manifest.headers.get('Docker-Content-Digest')
+            self._cache_content_type = manifest.headers.get("Content-Type")
+            self._cache_digest = manifest.headers.get("Docker-Content-Digest")
 
         return self._cache_manifest
 
     def _get_auth(self, www_auth):
         """
         Generates the authorization string using the token acquired
         from the www_auth endpoint.
         """
         scheme = www_auth.pop("scheme")
 
         url = f'{www_auth.pop("realm")}?'
         for key, value in www_auth.items():
-            url += f'{key}={value}&'
+            url += f"{key}={value}&"
 
         request = self._requester()
         response = request("GET", url, auth=self.auth, timeout=self.timeout)
 
         if response.status_code == 401:
             # Try again without auth
             response = request("GET", url, timeout=self.timeout)
 
-        self._raise_for_status(response, error_msg=f'unable to retrieve auth '
-                                                   f'token from {url}')
+        self._raise_for_status(
+            response, error_msg=f"unable to retrieve auth " f"token from {url}"
+        )
 
         data = response.json()["token"]
-        return f'{scheme} {data}'
+        return f"{scheme} {data}"
 
     @staticmethod
     def _parse_image_url(image_url):
         """
         Parser to split the image urls in its multiple components.
 
         Images are provided as URLs. E.g.:
@@ -474,105 +486,107 @@
         :type image_url: str
         :return: A data structure with all the parsed components of
                  the image URL, already filled with the defaults for
                  those not provided.
         :rtype: dict
         """
 
-        default_scheme = 'docker://'
-        default_registry = 'docker.io'
-        default_tag = 'latest'
+        default_scheme = "docker://"
+        default_registry = "docker.io"
+        default_tag = "latest"
 
         # The image is either specified by digest (...@sha256:xxxx...) or
         # by tag (...:tag-name). We decide based on the presence of the
         # '@' or the ':'. If we find neither, by-tag is assumed,
         # defaulting to 'latest'.
         parsed_image_url = re.search(
-            r'(?P<scheme>\w+://)?'  # Scheme (optional) e.g. docker://
-            r'(?P<registry>[\w\-]+[.][\w\-.]+)?'  # Registry domain (optional)
-            r'(?(registry)(?P<port_colon>[:]))?'  # Port colon (optional)
-            r'(?(port_colon)(?P<port>[0-9]+))'  # Port (optional)
-            r'(?(registry)(?P<registry_slash>/))'  # Slash after domain:port
-            r'(?P<repository>[\w\-]+)?'  # Repository (optional)
-            r'(?(repository)(?P<repo_slash>/))'  # Slash, if repo is present
-            r'(?P<image>[\w\-./]+)'  # Image path (mandatory)
+            r"(?P<scheme>\w+://)?"  # Scheme (optional) e.g. docker://
+            r"(?P<registry>[\w\-]+[.][\w\-.]+)?"  # Registry domain (optional)
+            r"(?(registry)(?P<port_colon>[:]))?"  # Port colon (optional)
+            r"(?(port_colon)(?P<port>[0-9]+))"  # Port (optional)
+            r"(?(registry)(?P<registry_slash>/))"  # Slash after domain:port
+            r"(?P<repository>[\w\-]+)?"  # Repository (optional)
+            r"(?(repository)(?P<repo_slash>/))"  # Slash, if repo is present
+            r"(?P<image>[\w\-./]+)"  # Image path (mandatory)
             # '@' delimiter iff it's a by-digest URI (optional)
-            r'(?P<digest_at>@)?'
+            r"(?P<digest_at>@)?"
             # Digest ('sha256:' + 64 lowercase hex chars) iff '@' is present
-            r'(?(digest_at)(?P<digest>sha256:[0-9a-f]{64}))'
+            r"(?(digest_at)(?P<digest>sha256:[0-9a-f]{64}))"
             # Tag colon if it's a by-digest URI (optional)
             # Not allowed if we found a digest
-            r'(?(digest)|(?P<tag_colon>:))?'
+            r"(?(digest)|(?P<tag_colon>:))?"
             # Tag (if tag colon is present)
-            r'(?(tag_colon)(?P<tag>[\w\-.]+))'
-            '$', image_url)
+            r"(?(tag_colon)(?P<tag>[\w\-.]+))"
+            "$",
+            image_url,
+        )
 
         if parsed_image_url is None:
             raise AttributeError(f'Not able to parse "{image_url}"')
 
         image_url_struct = parsed_image_url.groupdict()
 
-        if image_url_struct.get('scheme') is None:
-            image_url_struct['scheme'] = default_scheme
+        if image_url_struct.get("scheme") is None:
+            image_url_struct["scheme"] = default_scheme
 
-        if image_url_struct.get('registry') is None:
-            image_url_struct['registry'] = default_registry
+        if image_url_struct.get("registry") is None:
+            image_url_struct["registry"] = default_registry
 
-        port = image_url_struct.get('port')
+        port = image_url_struct.get("port")
         if port is not None:
-            image_url_struct['registry'] += f':{port}'
+            image_url_struct["registry"] += f":{port}"
 
-        if image_url_struct.get('repository') is None:
-            if image_url_struct['registry'] == 'docker.io':
-                image_url_struct['repository'] = 'library'
+        if image_url_struct.get("repository") is None:
+            if image_url_struct["registry"] == "docker.io":
+                image_url_struct["repository"] = "library"
             else:
-                image_url_struct['repository'] = None
+                image_url_struct["repository"] = None
 
         # By-digest URIs don't use tags; but otherwise default to `latest` if
         # absent
-        if all(image_url_struct.get(x) is None for x in ('tag', 'digest')):
-            image_url_struct['tag'] = default_tag
+        if all(image_url_struct.get(x) is None for x in ("tag", "digest")):
+            image_url_struct["tag"] = default_tag
 
         return image_url_struct
 
     @staticmethod
     def _parse_www_auth(value):
         www_authenticate = {}
-        www_authenticate['scheme'], params = value.split(' ', 1)
+        www_authenticate["scheme"], params = value.split(" ", 1)
 
         # According to the RFC6750, the scheme MUST be followed by
         # one or more auth-param values.
         # This regex gets the extra auth-params and adds them to
         # the www_authenticate dictionary
         for item in re.finditer('(?P<key>[^ ,]+)="(?P<value>[^"]+)"', params):
-            www_authenticate[item.group('key')] = item.group('value')
+            www_authenticate[item.group("key")] = item.group("value")
 
         return www_authenticate
 
     def _raise_for_status(self, response, error_msg=None):
         """
         Includes the error messages, important for a registry
         """
         if response.status_code < 400:
             return None
 
-        msg = ''
+        msg = ""
         if error_msg is not None:
-            msg += f'{error_msg}: '
+            msg += f"{error_msg}: "
 
-        msg += f'({response.status_code}) {response.reason}'
+        msg += f"({response.status_code}) {response.reason}"
         try:
             content = response.json()
         except json.decoder.JSONDecodeError as details:
             raise HTTPError(msg) from details
 
         if "errors" in content:
-            for error in content['errors']:
+            for error in content["errors"]:
                 msg += f', {error["message"]}'
-        _LOG.debug('[%s, %s]', str(self), msg)
+        _LOG.debug("[%s, %s]", str(self), msg)
         raise HTTPError(msg)
 
     @property
     def tags(self):
         """
         Returns the list of tags.
         """
@@ -585,36 +599,36 @@
         return self._cache_tags
 
     @property
     def url_digest(self):
         """
         Returns the image url in the digest format.
         """
-        url_digest = f'{self.registry}'
+        url_digest = f"{self.registry}"
         if self.repository is not None:
-            url_digest += f'/{self.repository}'
-        url_digest += f'/{self.image}@{self.digest}'
+            url_digest += f"/{self.repository}"
+        url_digest += f"/{self.image}@{self.digest}"
         return url_digest
 
     @property
     def url_tag(self):
         """
         Returns the image url in the tag format.
 
         If we were constructed with a by-digest URL, this will raise
         NoTagForImageByDigest since there may be more than one tag for a given
         image.
         """
         if self.tag is None:
             raise NoTagForImageByDigest(self)
 
-        url_tag = f'{self.registry}'
+        url_tag = f"{self.registry}"
         if self.repository is not None:
-            url_tag += f'/{self.repository}'
-        url_tag += f'/{self.image}:{self.tag}'
+            url_tag += f"/{self.repository}"
+        url_tag += f"/{self.image}:{self.tag}"
         return url_tag
 
     def __bool__(self):
         try:
             return bool(self.manifest)
         except HTTPError:
             return False
@@ -627,54 +641,56 @@
             return False
         try:
             manifest = self.manifest
             other_manifest = other.manifest
         except HTTPError as details:
             raise ImageComparisonError(details) from details
 
-        manifest_version = manifest['schemaVersion']
-        other_manifest_version = other_manifest['schemaVersion']
+        manifest_version = manifest["schemaVersion"]
+        other_manifest_version = other_manifest["schemaVersion"]
 
         if manifest_version != other_manifest_version:
             return False
 
         if manifest_version == 1:
-            layers_key = 'fsLayers'
+            layers_key = "fsLayers"
         else:
             manifest_content_type = self.content_type
             other_manifest_content_type = other.content_type
 
             if manifest_content_type != other_manifest_content_type:
                 return False
 
             if manifest_content_type in SINGLE_ARCH_MEDIA_TYPES:
-                layers_key = 'layers'
+                layers_key = "layers"
             elif manifest_content_type in MULTI_ARCH_MEDIA_TYPES:
-                layers_key = 'manifests'
+                layers_key = "manifests"
             else:
                 raise ImageComparisonError(
                     f"Found unsupported content type {manifest_content_type} "
                     "while comparing"
                 )
 
         if manifest[layers_key] == other_manifest[layers_key]:
             return True
 
         return False
 
     def __getitem__(self, item):
-        return Image(url=str(self),
-                     tag_override=str(item),
-                     username=self.username,
-                     password=self.password,
-                     auth_server=self.auth_server,
-                     response_cache=self.response_cache,
-                     auth_token=self.auth_token,
-                     session=self.session,
-                     timeout=self.timeout)
+        return Image(
+            url=str(self),
+            tag_override=str(item),
+            username=self.username,
+            password=self.password,
+            auth_server=self.auth_server,
+            response_cache=self.response_cache,
+            auth_token=self.auth_token,
+            session=self.session,
+            timeout=self.timeout,
+        )
 
     def __iter__(self):
         for tag in self.tags:
             yield tag
 
     def __len__(self):
         return len(self.tags)
@@ -683,8 +699,8 @@
         return f"{self.__class__.__name__}(url='{self}')"
 
     def __str__(self):
         if self.tag is None:
             url = self.url_digest
         else:
             url = self.url_tag
-        return f'{self.scheme}{url}'
+        return f"{self.scheme}{url}"
```

## sretoolbox/container/skopeo.py

```diff
@@ -14,36 +14,35 @@
 
 """
 Wrapper around the Skopeo utility.
 """
 
 import logging
 import subprocess
-
 from distutils import spawn
 
-
 _LOG = logging.getLogger(__name__)
 
 
 class SkopeoCmdError(Exception):
     """
     Indicates that the skopeo command failed.
     """
 
 
 class Skopeo:
     """Abstracts Skopeo and implements its features."""
 
     def __init__(self, dry_run=False):
         self.dry_run = dry_run
-        self.skopeo_cmd = spawn.find_executable('skopeo')
+        self.skopeo_cmd = spawn.find_executable("skopeo")
 
-    def copy(self, src_image, dst_image, src_creds=None, dest_creds=None,
-             copy_all=False):
+    def copy(
+        self, src_image, dst_image, src_creds=None, dest_creds=None, copy_all=False
+    ):
         """
         Runs the skopeo "copy" sub-command.
 
         The skopeo "copy" pulls the source image from the online repository
         and pushes it to the destination image online repository.
 
         :param src_image: The image to be pulled.
@@ -59,17 +58,22 @@
                            "username:password".
         :type dest_creds: str
         :param copy_all: (optional) Whether to copy all the architectures
                          from a given tag or only the architecture of the OS
                          Skopeo is running on.
         :type copy_all: bool
         """
-        self._run_skopeo('copy', str(src_image), str(dst_image),
-                         src_creds=src_creds, dest_creds=dest_creds,
-                         all_=copy_all)
+        self._run_skopeo(
+            "copy",
+            str(src_image),
+            str(dst_image),
+            src_creds=src_creds,
+            dest_creds=dest_creds,
+            all_=copy_all,
+        )
 
     def inspect(self, image, creds=None):
         """
         Runs the skopeo "inspect" sub-command.
 
         The skopeo "inspect" returns low-level information about the image.
         This implementation only checks that the command was successful,
@@ -78,21 +82,19 @@
         :param image: The image to be inspected.
         :type image: str
         :param creds: (optional) The source repository
                       credentials in the format
                       "username:password".
         :type creds: str
         """
-        self._run_skopeo('inspect', str(image), creds=creds)
+        self._run_skopeo("inspect", str(image), creds=creds)
 
-    def _run_skopeo(self, subcomand, *args,
-                    src_creds=None,
-                    dest_creds=None,
-                    creds=None,
-                    all_=False):
+    def _run_skopeo(
+        self, subcomand, *args, src_creds=None, dest_creds=None, creds=None, all_=False
+    ):
         """
         Helper to streamline the execution of skopeo commands
 
         :param subcomand: The skopeo subcommand to execute.
                           E.g. inspect, copy, ...
         :type subcomand: str
         :param *args: Additional positional arguments according
@@ -109,33 +111,34 @@
         :param all_: (optional) Whether to add the --all option to the
                      command line.
         :type all_: bool
         """
         cmd = [self.skopeo_cmd, subcomand]
 
         if src_creds is not None:
-            cmd.append(f'--src-creds={src_creds}')
+            cmd.append(f"--src-creds={src_creds}")
         if dest_creds is not None:
-            cmd.append(f'--dest-creds={dest_creds}')
+            cmd.append(f"--dest-creds={dest_creds}")
         if creds is not None:
-            cmd.append(f'--creds={creds}')
+            cmd.append(f"--creds={creds}")
         if all_:
-            cmd.append('--all')
+            cmd.append("--all")
         cmd.extend(args)
 
-        if subcomand == 'copy':
+        if subcomand == "copy":
             _LOG.info([subcomand, *args])
             if self.dry_run:
-                return ''
+                return ""
 
-        result = subprocess.run(cmd, check=False, stdout=subprocess.PIPE,
-                                stderr=subprocess.PIPE)
+        result = subprocess.run(
+            cmd, check=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE
+        )
 
         for line in result.stdout.decode().splitlines():
-            _LOG.debug(' %s', line)
+            _LOG.debug(" %s", line)
 
         if result.returncode:
             for line in result.stderr.decode().splitlines():
-                _LOG.error(' %s', line)
-            raise SkopeoCmdError(f'exit code: {result.returncode}')
+                _LOG.error(" %s", line)
+            raise SkopeoCmdError(f"exit code: {result.returncode}")
 
         return result.stdout
```

## sretoolbox/utils/__init__.py

```diff
@@ -13,16 +13,15 @@
 # limitations under the License.
 
 """
 Exposes the utilities for easy access.
 """
 
 from sretoolbox.utils.datatransformation import replace_values
-from sretoolbox.utils.retry import retry
 from sretoolbox.utils.process import run
-
+from sretoolbox.utils.retry import retry
 
 __all__ = [
-    'replace_values',
-    'retry',
-    'run',
+    "replace_values",
+    "retry",
+    "run",
 ]
```

## sretoolbox/utils/concurrent.py

```diff
@@ -11,14 +11,15 @@
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
 """
 Concurrent abstractions.
 """
+
 from concurrent.futures import Executor
 from functools import partial
 from typing import Any, Callable, Iterable, List, Type
 
 from sretoolbox.utils.exception import SystemExitWrapper
```

## sretoolbox/utils/logger.py

```diff
@@ -39,17 +39,15 @@
     :param stream: stream where to log
     :type stream: io.TextIOWrapper
     :param level: log level
     :type level: int
     :return: text logger
     :rtype: logging.Logger
     """
-    return LoggersSingleton(
-        name=name, kind=LoggerType.TEXT, stream=stream, level=level
-    )
+    return LoggersSingleton(name=name, kind=LoggerType.TEXT, stream=stream, level=level)
 
 
 def get_json_logger(name, stream=sys.stdout, level=logging.INFO):
     """
     Sets up or returns a singleton JSON logger.
 
     :param name: logger name
@@ -57,17 +55,15 @@
     :param stream: stream where to log
     :type stream: io.TextIOWrapper
     :param level: log level
     :type level: int
     :return: text logger
     :rtype: logging.Logger
     """
-    return LoggersSingleton(
-        name=name, kind=LoggerType.JSON, stream=stream, level=level
-    )
+    return LoggersSingleton(name=name, kind=LoggerType.JSON, stream=stream, level=level)
 
 
 def _setup_text_logger(name, stream, level):
     """Setup a text logger."""
     res = logging.getLogger(name)
     handler = logging.StreamHandler(stream)
     handler.setFormatter(logging.Formatter(fmt="%(message)s"))
```

## sretoolbox/utils/multiprocess.py

```diff
@@ -11,14 +11,15 @@
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
 """
 Multiprocessing abstractions.
 """
+
 from concurrent.futures import ProcessPoolExecutor
 from typing import Any, Callable, Iterable, List
 
 from sretoolbox.utils.concurrent import pmap
 
 
 def run(
@@ -64,13 +65,15 @@
         >>> def square(x):
         ...     return x ** 2
         >>> iterable = [1, 2, 3, 4, 5]
         >>> pool_size = 2
         >>> run(square, iterable, pool_size)
         [1, 4, 9, 16, 25]
     """
-    return pmap(func,
-                iterable,
-                ProcessPoolExecutor,
-                process_pool_size,
-                return_exceptions,
-                **kwargs)
+    return pmap(
+        func,
+        iterable,
+        ProcessPoolExecutor,
+        process_pool_size,
+        return_exceptions,
+        **kwargs,
+    )
```

## sretoolbox/utils/process.py

```diff
@@ -19,11 +19,10 @@
 import subprocess
 
 
 def run(cmd):
     """
     Calls subprocess.run with select options.
     """
-    return subprocess.run(cmd,
-                          stdout=subprocess.PIPE,
-                          stderr=subprocess.STDOUT,
-                          check=True).stdout.decode()
+    return subprocess.run(
+        cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, check=True
+    ).stdout.decode()
```

## sretoolbox/utils/retry.py

```diff
@@ -31,22 +31,20 @@
 
 """
 Functions to add resilience to function calls.
 """
 
 import itertools
 import time
-
 from functools import wraps
 
 
 # Original Code:
 # https://github.com/saltycrane/retry-decorator/blob/a26fe27/retry_decorator.py
-def retry(exceptions=Exception, max_attempts=3, no_retry_exceptions=(),
-          hook=None):
+def retry(exceptions=Exception, max_attempts=3, no_retry_exceptions=(), hook=None):
     """Adds resilience to function calls.
 
     This decorator will retry a function for several attempts if it raises an
     expected exception. Additionally it supports running a hook each time there
     is a new attempt.
 
     :param exceptions: collections of exceptions that will trigger a retry,
@@ -60,25 +58,27 @@
     :type no_retry_exceptions: tuple, optional
     :param hook: function which will be triggered each time there is a retry
         attempt, defaults to None
     :type hook: function(Exception), optional
     :return: decorated function
     :rtype: function
     """
-    def deco_retry(function):
 
+    def deco_retry(function):
         @wraps(function)
         def f_retry(*args, **kwargs):
             for attempt in itertools.count(1):
                 try:
                     return function(*args, **kwargs)
                 except no_retry_exceptions as exception:
                     raise exception
                 except exceptions as exception:  # pylint: disable=broad-except
                     if attempt > max_attempts - 1:
                         raise exception
                     if callable(hook):
                         hook(exception)
                     time.sleep(attempt)
             return None
+
         return f_retry
+
     return deco_retry
```

## sretoolbox/utils/threaded.py

```diff
@@ -65,20 +65,22 @@
         >>> def square(x):
         ...     return x ** 2
         >>> iterable = [1, 2, 3, 4, 5]
         >>> pool_size = 2
         >>> run(square, iterable, pool_size)
         [1, 4, 9, 16, 25]
     """
-    return pmap(func,
-                iterable,
-                ThreadPoolExecutor,
-                thread_pool_size,
-                return_exceptions,
-                **kwargs)
+    return pmap(
+        func,
+        iterable,
+        ThreadPoolExecutor,
+        thread_pool_size,
+        return_exceptions,
+        **kwargs,
+    )
 
 
 def estimate_available_thread_pool_size(
     thread_pool_size: int,
     targets_len: int,
 ) -> int:
     """estimates available thread pool size based when threading
```

## Comparing `sretoolbox-2.5.2.dist-info/LICENSE` & `sretoolbox-2.5.3.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `sretoolbox-2.5.2.dist-info/METADATA` & `sretoolbox-2.5.3.dist-info/METADATA`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: sretoolbox
-Version: 2.5.2
+Version: 2.5.3
 Summary: Set of libraries commonly used by multiple SRE projects
 Home-page: https://github.com/app-sre/sretoolbox
 Author: Red Hat Application SRE Team
 Author-email: sd-app-sre@redhat.com
 License: Apache-2.0
 Platform: UNKNOWN
 Classifier: Development Status :: 5 - Production/Stable
@@ -12,15 +12,15 @@
 Classifier: License :: OSI Approved :: Apache Software License
 Classifier: Natural Language :: English
 Classifier: Operating System :: POSIX :: Linux
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Topic :: Software Development :: Libraries
 Requires-Python: >=3.8
 Requires-Dist: requests (~=2.22)
-Requires-Dist: semver (~=2.13)
+Requires-Dist: semver (~=3.0)
 Requires-Dist: python-json-logger (~=2.0.2)
 
 SRE Toolbox
 ===========
 
 Set of libraries commonly used by multiple SRE projects:
```

